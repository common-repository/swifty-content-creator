var swifty;(function () { if (!swifty || !swifty.requirejs) {
if (!swifty) { swifty = {}; } else { require = swifty; }
/*
 RequireJS 2.1.14 Copyright (c) 2010-2014, The Dojo Foundation All Rights Reserved.
 Available via the MIT or new BSD license.
 see: http://github.com/jrburke/requirejs for details
*/
var requirejs,require,define;
(function(ba){function G(b){return"[object Function]"===K.call(b)}function H(b){return"[object Array]"===K.call(b)}function v(b,c){if(b){var d;for(d=0;d<b.length&&(!b[d]||!c(b[d],d,b));d+=1);}}function T(b,c){if(b){var d;for(d=b.length-1;-1<d&&(!b[d]||!c(b[d],d,b));d-=1);}}function t(b,c){return fa.call(b,c)}function m(b,c){return t(b,c)&&b[c]}function B(b,c){for(var d in b)if(t(b,d)&&c(b[d],d))break}function U(b,c,d,e){c&&B(c,function(c,g){if(d||!t(b,g))e&&"object"===typeof c&&c&&!H(c)&&!G(c)&&!(c instanceof
RegExp)?(b[g]||(b[g]={}),U(b[g],c,d,e)):b[g]=c});return b}function u(b,c){return function(){return c.apply(b,arguments)}}function ca(b){throw b;}function da(b){if(!b)return b;var c=ba;v(b.split("."),function(b){c=c[b]});return c}function C(b,c,d,e){c=Error(c+"\nhttp://requirejs.org/docs/errors.html#"+b);c.requireType=b;c.requireModules=e;d&&(c.originalError=d);return c}function ga(b){function c(a,k,b){var f,l,c,d,e,g,i,p,k=k&&k.split("/"),h=j.map,n=h&&h["*"];if(a){a=a.split("/");l=a.length-1;j.nodeIdCompat&&
Q.test(a[l])&&(a[l]=a[l].replace(Q,""));"."===a[0].charAt(0)&&k&&(l=k.slice(0,k.length-1),a=l.concat(a));l=a;for(c=0;c<l.length;c++)if(d=l[c],"."===d)l.splice(c,1),c-=1;else if(".."===d&&!(0===c||1==c&&".."===l[2]||".."===l[c-1])&&0<c)l.splice(c-1,2),c-=2;a=a.join("/")}if(b&&h&&(k||n)){l=a.split("/");c=l.length;a:for(;0<c;c-=1){e=l.slice(0,c).join("/");if(k)for(d=k.length;0<d;d-=1)if(b=m(h,k.slice(0,d).join("/")))if(b=m(b,e)){f=b;g=c;break a}!i&&(n&&m(n,e))&&(i=m(n,e),p=c)}!f&&i&&(f=i,g=p);f&&(l.splice(0,
g,f),a=l.join("/"))}return(f=m(j.pkgs,a))?f:a}function d(a){z&&v(document.getElementsByTagName("script"),function(k){if(k.getAttribute("data-requiremodule")===a&&k.getAttribute("data-requirecontext")===i.contextName)return k.parentNode.removeChild(k),!0})}function e(a){var k=m(j.paths,a);if(k&&H(k)&&1<k.length)return k.shift(),i.require.undef(a),i.makeRequire(null,{skipMap:!0})([a]),!0}function n(a){var k,c=a?a.indexOf("!"):-1;-1<c&&(k=a.substring(0,c),a=a.substring(c+1,a.length));return[k,a]}function p(a,
k,b,f){var l,d,e=null,g=k?k.name:null,j=a,p=!0,h="";a||(p=!1,a="_@r"+(K+=1));a=n(a);e=a[0];a=a[1];e&&(e=c(e,g,f),d=m(r,e));a&&(e?h=d&&d.normalize?d.normalize(a,function(a){return c(a,g,f)}):-1===a.indexOf("!")?c(a,g,f):a:(h=c(a,g,f),a=n(h),e=a[0],h=a[1],b=!0,l=i.nameToUrl(h)));b=e&&!d&&!b?"_unnormalized"+(O+=1):"";return{prefix:e,name:h,parentMap:k,unnormalized:!!b,url:l,originalName:j,isDefine:p,id:(e?e+"!"+h:h)+b}}function s(a){var k=a.id,b=m(h,k);b||(b=h[k]=new i.Module(a));return b}function q(a,
k,b){var f=a.id,c=m(h,f);if(t(r,f)&&(!c||c.defineEmitComplete))"defined"===k&&b(r[f]);else if(c=s(a),c.error&&"error"===k)b(c.error);else c.on(k,b)}function w(a,b){var c=a.requireModules,f=!1;if(b)b(a);else if(v(c,function(b){if(b=m(h,b))b.error=a,b.events.error&&(f=!0,b.emit("error",a))}),!f)g.onError(a)}function x(){R.length&&(ha.apply(A,[A.length,0].concat(R)),R=[])}function y(a){delete h[a];delete V[a]}function F(a,b,c){var f=a.map.id;a.error?a.emit("error",a.error):(b[f]=!0,v(a.depMaps,function(f,
d){var e=f.id,g=m(h,e);g&&(!a.depMatched[d]&&!c[e])&&(m(b,e)?(a.defineDep(d,r[e]),a.check()):F(g,b,c))}),c[f]=!0)}function D(){var a,b,c=(a=1E3*j.waitSeconds)&&i.startTime+a<(new Date).getTime(),f=[],l=[],g=!1,h=!0;if(!W){W=!0;B(V,function(a){var i=a.map,j=i.id;if(a.enabled&&(i.isDefine||l.push(a),!a.error))if(!a.inited&&c)e(j)?g=b=!0:(f.push(j),d(j));else if(!a.inited&&(a.fetched&&i.isDefine)&&(g=!0,!i.prefix))return h=!1});if(c&&f.length)return a=C("timeout","Load timeout for modules: "+f,null,
f),a.contextName=i.contextName,w(a);h&&v(l,function(a){F(a,{},{})});if((!c||b)&&g)if((z||ea)&&!X)X=setTimeout(function(){X=0;D()},50);W=!1}}function E(a){t(r,a[0])||s(p(a[0],null,!0)).init(a[1],a[2])}function I(a){var a=a.currentTarget||a.srcElement,b=i.onScriptLoad;a.detachEvent&&!Y?a.detachEvent("onreadystatechange",b):a.removeEventListener("load",b,!1);b=i.onScriptError;(!a.detachEvent||Y)&&a.removeEventListener("error",b,!1);return{node:a,id:a&&a.getAttribute("data-requiremodule")}}function J(){var a;
for(x();A.length;){a=A.shift();if(null===a[0])return w(C("mismatch","Mismatched anonymous define() module: "+a[a.length-1]));E(a)}}var W,Z,i,L,X,j={waitSeconds:7,baseUrl:"./",paths:{},bundles:{},pkgs:{},shim:{},config:{}},h={},V={},$={},A=[],r={},S={},aa={},K=1,O=1;L={require:function(a){return a.require?a.require:a.require=i.makeRequire(a.map)},exports:function(a){a.usingExports=!0;if(a.map.isDefine)return a.exports?r[a.map.id]=a.exports:a.exports=r[a.map.id]={}},module:function(a){return a.module?
a.module:a.module={id:a.map.id,uri:a.map.url,config:function(){return m(j.config,a.map.id)||{}},exports:a.exports||(a.exports={})}}};Z=function(a){this.events=m($,a.id)||{};this.map=a;this.shim=m(j.shim,a.id);this.depExports=[];this.depMaps=[];this.depMatched=[];this.pluginMaps={};this.depCount=0};Z.prototype={init:function(a,b,c,f){f=f||{};if(!this.inited){this.factory=b;if(c)this.on("error",c);else this.events.error&&(c=u(this,function(a){this.emit("error",a)}));this.depMaps=a&&a.slice(0);this.errback=
c;this.inited=!0;this.ignore=f.ignore;f.enabled||this.enabled?this.enable():this.check()}},defineDep:function(a,b){this.depMatched[a]||(this.depMatched[a]=!0,this.depCount-=1,this.depExports[a]=b)},fetch:function(){if(!this.fetched){this.fetched=!0;i.startTime=(new Date).getTime();var a=this.map;if(this.shim)i.makeRequire(this.map,{enableBuildCallback:!0})(this.shim.deps||[],u(this,function(){return a.prefix?this.callPlugin():this.load()}));else return a.prefix?this.callPlugin():this.load()}},load:function(){var a=
this.map.url;S[a]||(S[a]=!0,i.load(this.map.id,a))},check:function(){if(this.enabled&&!this.enabling){var a,b,c=this.map.id;b=this.depExports;var f=this.exports,l=this.factory;if(this.inited)if(this.error)this.emit("error",this.error);else{if(!this.defining){this.defining=!0;if(1>this.depCount&&!this.defined){if(G(l)){if(this.events.error&&this.map.isDefine||g.onError!==ca)try{f=i.execCb(c,l,b,f)}catch(d){a=d}else f=i.execCb(c,l,b,f);this.map.isDefine&&void 0===f&&((b=this.module)?f=b.exports:this.usingExports&&
(f=this.exports));if(a)return a.requireMap=this.map,a.requireModules=this.map.isDefine?[this.map.id]:null,a.requireType=this.map.isDefine?"define":"require",w(this.error=a)}else f=l;this.exports=f;if(this.map.isDefine&&!this.ignore&&(r[c]=f,g.onResourceLoad))g.onResourceLoad(i,this.map,this.depMaps);y(c);this.defined=!0}this.defining=!1;this.defined&&!this.defineEmitted&&(this.defineEmitted=!0,this.emit("defined",this.exports),this.defineEmitComplete=!0)}}else this.fetch()}},callPlugin:function(){var a=
this.map,b=a.id,d=p(a.prefix);this.depMaps.push(d);q(d,"defined",u(this,function(f){var l,d;d=m(aa,this.map.id);var e=this.map.name,P=this.map.parentMap?this.map.parentMap.name:null,n=i.makeRequire(a.parentMap,{enableBuildCallback:!0});if(this.map.unnormalized){if(f.normalize&&(e=f.normalize(e,function(a){return c(a,P,!0)})||""),f=p(a.prefix+"!"+e,this.map.parentMap),q(f,"defined",u(this,function(a){this.init([],function(){return a},null,{enabled:!0,ignore:!0})})),d=m(h,f.id)){this.depMaps.push(f);
if(this.events.error)d.on("error",u(this,function(a){this.emit("error",a)}));d.enable()}}else d?(this.map.url=i.nameToUrl(d),this.load()):(l=u(this,function(a){this.init([],function(){return a},null,{enabled:!0})}),l.error=u(this,function(a){this.inited=!0;this.error=a;a.requireModules=[b];B(h,function(a){0===a.map.id.indexOf(b+"_unnormalized")&&y(a.map.id)});w(a)}),l.fromText=u(this,function(f,c){var d=a.name,e=p(d),P=M;c&&(f=c);P&&(M=!1);s(e);t(j.config,b)&&(j.config[d]=j.config[b]);try{g.exec(f)}catch(h){return w(C("fromtexteval",
"fromText eval for "+b+" failed: "+h,h,[b]))}P&&(M=!0);this.depMaps.push(e);i.completeLoad(d);n([d],l)}),f.load(a.name,n,l,j))}));i.enable(d,this);this.pluginMaps[d.id]=d},enable:function(){V[this.map.id]=this;this.enabling=this.enabled=!0;v(this.depMaps,u(this,function(a,b){var c,f;if("string"===typeof a){a=p(a,this.map.isDefine?this.map:this.map.parentMap,!1,!this.skipMap);this.depMaps[b]=a;if(c=m(L,a.id)){this.depExports[b]=c(this);return}this.depCount+=1;q(a,"defined",u(this,function(a){this.defineDep(b,
a);this.check()}));this.errback&&q(a,"error",u(this,this.errback))}c=a.id;f=h[c];!t(L,c)&&(f&&!f.enabled)&&i.enable(a,this)}));B(this.pluginMaps,u(this,function(a){var b=m(h,a.id);b&&!b.enabled&&i.enable(a,this)}));this.enabling=!1;this.check()},on:function(a,b){var c=this.events[a];c||(c=this.events[a]=[]);c.push(b)},emit:function(a,b){v(this.events[a],function(a){a(b)});"error"===a&&delete this.events[a]}};i={config:j,contextName:b,registry:h,defined:r,urlFetched:S,defQueue:A,Module:Z,makeModuleMap:p,
nextTick:g.nextTick,onError:w,configure:function(a){a.baseUrl&&"/"!==a.baseUrl.charAt(a.baseUrl.length-1)&&(a.baseUrl+="/");var b=j.shim,c={paths:!0,bundles:!0,config:!0,map:!0};B(a,function(a,b){c[b]?(j[b]||(j[b]={}),U(j[b],a,!0,!0)):j[b]=a});a.bundles&&B(a.bundles,function(a,b){v(a,function(a){a!==b&&(aa[a]=b)})});a.shim&&(B(a.shim,function(a,c){H(a)&&(a={deps:a});if((a.exports||a.init)&&!a.exportsFn)a.exportsFn=i.makeShimExports(a);b[c]=a}),j.shim=b);a.packages&&v(a.packages,function(a){var b,
a="string"===typeof a?{name:a}:a;b=a.name;a.location&&(j.paths[b]=a.location);j.pkgs[b]=a.name+"/"+(a.main||"main").replace(ia,"").replace(Q,"")});B(h,function(a,b){!a.inited&&!a.map.unnormalized&&(a.map=p(b))});if(a.deps||a.callback)i.require(a.deps||[],a.callback)},makeShimExports:function(a){return function(){var b;a.init&&(b=a.init.apply(ba,arguments));return b||a.exports&&da(a.exports)}},makeRequire:function(a,e){function j(c,d,m){var n,q;e.enableBuildCallback&&(d&&G(d))&&(d.__requireJsBuild=
!0);if("string"===typeof c){if(G(d))return w(C("requireargs","Invalid require call"),m);if(a&&t(L,c))return L[c](h[a.id]);if(g.get)return g.get(i,c,a,j);n=p(c,a,!1,!0);n=n.id;return!t(r,n)?w(C("notloaded",'Module name "'+n+'" has not been loaded yet for context: '+b+(a?"":". Use require([])"))):r[n]}J();i.nextTick(function(){J();q=s(p(null,a));q.skipMap=e.skipMap;q.init(c,d,m,{enabled:!0});D()});return j}e=e||{};U(j,{isBrowser:z,toUrl:function(b){var d,e=b.lastIndexOf("."),k=b.split("/")[0];if(-1!==
e&&(!("."===k||".."===k)||1<e))d=b.substring(e,b.length),b=b.substring(0,e);return i.nameToUrl(c(b,a&&a.id,!0),d,!0)},defined:function(b){return t(r,p(b,a,!1,!0).id)},specified:function(b){b=p(b,a,!1,!0).id;return t(r,b)||t(h,b)}});a||(j.undef=function(b){x();var c=p(b,a,!0),e=m(h,b);d(b);delete r[b];delete S[c.url];delete $[b];T(A,function(a,c){a[0]===b&&A.splice(c,1)});e&&(e.events.defined&&($[b]=e.events),y(b))});return j},enable:function(a){m(h,a.id)&&s(a).enable()},completeLoad:function(a){var b,
c,d=m(j.shim,a)||{},g=d.exports;for(x();A.length;){c=A.shift();if(null===c[0]){c[0]=a;if(b)break;b=!0}else c[0]===a&&(b=!0);E(c)}c=m(h,a);if(!b&&!t(r,a)&&c&&!c.inited){if(j.enforceDefine&&(!g||!da(g)))return e(a)?void 0:w(C("nodefine","No define call for "+a,null,[a]));E([a,d.deps||[],d.exportsFn])}D()},nameToUrl:function(a,b,c){var d,e,h;(d=m(j.pkgs,a))&&(a=d);if(d=m(aa,a))return i.nameToUrl(d,b,c);if(g.jsExtRegExp.test(a))d=a+(b||"");else{d=j.paths;a=a.split("/");for(e=a.length;0<e;e-=1)if(h=a.slice(0,
e).join("/"),h=m(d,h)){H(h)&&(h=h[0]);a.splice(0,e,h);break}d=a.join("/");d+=b||(/^data\:|\?/.test(d)||c?"":".js");d=("/"===d.charAt(0)||d.match(/^[\w\+\.\-]+:/)?"":j.baseUrl)+d}return j.urlArgs?d+((-1===d.indexOf("?")?"?":"&")+j.urlArgs):d},load:function(a,b){g.load(i,a,b)},execCb:function(a,b,c,d){return b.apply(d,c)},onScriptLoad:function(a){if("load"===a.type||ja.test((a.currentTarget||a.srcElement).readyState))N=null,a=I(a),i.completeLoad(a.id)},onScriptError:function(a){var b=I(a);if(!e(b.id))return w(C("scripterror",
"Script error for: "+b.id,a,[b.id]))}};i.require=i.makeRequire();return i}var g,x,y,D,I,E,N,J,s,O,ka=/(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg,la=/[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,Q=/\.js$/,ia=/^\.\//;x=Object.prototype;var K=x.toString,fa=x.hasOwnProperty,ha=Array.prototype.splice,z=!!("undefined"!==typeof window&&"undefined"!==typeof navigator&&window.document),ea=!z&&"undefined"!==typeof importScripts,ja=z&&"PLAYSTATION 3"===navigator.platform?/^complete$/:/^(complete|loaded)$/,
Y="undefined"!==typeof opera&&"[object Opera]"===opera.toString(),F={},q={},R=[],M=!1;if("undefined"===typeof define){if("undefined"!==typeof requirejs){if(G(requirejs))return;q=requirejs;requirejs=void 0}"undefined"!==typeof require&&!G(require)&&(q=require,require=void 0);g=requirejs=function(b,c,d,e){var n,p="_";!H(b)&&"string"!==typeof b&&(n=b,H(c)?(b=c,c=d,d=e):b=[]);n&&n.context&&(p=n.context);(e=m(F,p))||(e=F[p]=g.s.newContext(p));n&&e.configure(n);return e.require(b,c,d)};g.config=function(b){return g(b)};
g.nextTick="undefined"!==typeof setTimeout?function(b){setTimeout(b,4)}:function(b){b()};require||(require=g);g.version="2.1.14";g.jsExtRegExp=/^\/|:|\?|\.js$/;g.isBrowser=z;x=g.s={contexts:F,newContext:ga};g({});v(["toUrl","undef","defined","specified"],function(b){g[b]=function(){var c=F._;return c.require[b].apply(c,arguments)}});if(z&&(y=x.head=document.getElementsByTagName("head")[0],D=document.getElementsByTagName("base")[0]))y=x.head=D.parentNode;g.onError=ca;g.createNode=function(b){var c=
b.xhtml?document.createElementNS("http://www.w3.org/1999/xhtml","html:script"):document.createElement("script");c.type=b.scriptType||"text/javascript";c.charset="utf-8";c.async=!0;return c};g.load=function(b,c,d){var e=b&&b.config||{};if(z)return e=g.createNode(e,c,d),e.setAttribute("data-requirecontext",b.contextName),e.setAttribute("data-requiremodule",c),e.attachEvent&&!(e.attachEvent.toString&&0>e.attachEvent.toString().indexOf("[native code"))&&!Y?(M=!0,e.attachEvent("onreadystatechange",b.onScriptLoad)):
(e.addEventListener("load",b.onScriptLoad,!1),e.addEventListener("error",b.onScriptError,!1)),e.src=d,J=e,D?y.insertBefore(e,D):y.appendChild(e),J=null,e;if(ea)try{importScripts(d),b.completeLoad(c)}catch(m){b.onError(C("importscripts","importScripts failed for "+c+" at "+d,m,[c]))}};z&&!q.skipDataMain&&T(document.getElementsByTagName("script"),function(b){y||(y=b.parentNode);if(I=b.getAttribute("data-main"))return s=I,q.baseUrl||(E=s.split("/"),s=E.pop(),O=E.length?E.join("/")+"/":"./",q.baseUrl=
O),s=s.replace(Q,""),g.jsExtRegExp.test(s)&&(s=I),q.deps=q.deps?q.deps.concat(s):[s],!0});define=function(b,c,d){var e,g;"string"!==typeof b&&(d=c,c=b,b=null);H(c)||(d=c,c=null);!c&&G(d)&&(c=[],d.length&&(d.toString().replace(ka,"").replace(la,function(b,d){c.push(d)}),c=(1===d.length?["require"]:["require","exports","module"]).concat(c)));if(M){if(!(e=J))N&&"interactive"===N.readyState||T(document.getElementsByTagName("script"),function(b){if("interactive"===b.readyState)return N=b}),e=N;e&&(b||
(b=e.getAttribute("data-requiremodule")),g=F[e.getAttribute("data-requirecontext")])}(g?g.defQueue:R).push([b,c,d])};define.amd={jQuery:!0};g.exec=function(b){return eval(b)};g(q)}})(this);

swifty.requirejs = requirejs;swifty.require = require;swifty.define = define;
}
}());
swifty.define("requireLib", function(){});

/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#util/can*/
swifty.define('can/util/can',[], function () {
    var glbl = typeof window !== 'undefined' ? window : typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope ? self : global;
    var can = {};
    if (typeof GLOBALCAN === 'undefined' || GLOBALCAN !== false) {
        glbl.can = can;
    }
    can.global = glbl;
    can.k = function () {
    };
    can.isDeferred = can.isPromise = function (obj) {
        return obj && typeof obj.then === 'function' && typeof obj.pipe === 'function';
    };
    can.isMapLike = function (obj) {
        return can.Map && (obj instanceof can.Map || obj && obj.___get);
    };
    var cid = 0;
    can.cid = function (object, name) {
        if (!object._cid) {
            cid++;
            object._cid = (name || '') + cid;
        }
        return object._cid;
    };
    can.VERSION = '2.3.21';
    can.simpleExtend = function (d, s) {
        for (var prop in s) {
            d[prop] = s[prop];
        }
        return d;
    };
    can.last = function (arr) {
        return arr && arr[arr.length - 1];
    };
    can.isDOM = function (el) {
        return (el.ownerDocument || el) === can.global.document;
    };
    can.childNodes = function (node) {
        var childNodes = node.childNodes;
        if ('length' in childNodes) {
            return childNodes;
        } else {
            var cur = node.firstChild;
            var nodes = [];
            while (cur) {
                nodes.push(cur);
                cur = cur.nextSibling;
            }
            return nodes;
        }
    };
    var protoBind = Function.prototype.bind;
    if (protoBind) {
        can.proxy = function (fn, context) {
            return protoBind.call(fn, context);
        };
    } else {
        can.proxy = function (fn, context) {
            return function () {
                return fn.apply(context, arguments);
            };
        };
    }
    can.frag = function (item, doc) {
        var document = doc || can.document || can.global.document;
        var frag;
        if (!item || typeof item === 'string') {
            frag = can.buildFragment(item == null ? '' : '' + item, document);
            if (!frag.childNodes.length) {
                frag.appendChild(document.createTextNode(''));
            }
            return frag;
        } else if (item.nodeType === 11) {
            return item;
        } else if (typeof item.nodeType === 'number') {
            frag = document.createDocumentFragment();
            frag.appendChild(item);
            return frag;
        } else if (typeof item.length === 'number') {
            frag = document.createDocumentFragment();
            can.each(item, function (item) {
                frag.appendChild(can.frag(item));
            });
            if (!can.childNodes(frag).length) {
                frag.appendChild(document.createTextNode(''));
            }
            return frag;
        } else {
            frag = can.buildFragment('' + item, document);
            if (!can.childNodes(frag).length) {
                frag.appendChild(document.createTextNode(''));
            }
            return frag;
        }
    };
    can.scope = can.viewModel = function (el, attr, val) {
        el = can.$(el);
        var scope = can.data(el, 'scope') || can.data(el, 'viewModel');
        if (!scope) {
            scope = new can.Map();
            can.data(el, 'scope', scope);
            can.data(el, 'viewModel', scope);
        }
        switch (arguments.length) {
        case 0:
        case 1:
            return scope;
        case 2:
            return scope.attr(attr);
        default:
            scope.attr(attr, val);
            return el;
        }
    };
    var parseURI = function (url) {
        var m = String(url).replace(/^\s+|\s+$/g, '').match(/^([^:\/?#]+:)?(\/\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
        return m ? {
            href: m[0] || '',
            protocol: m[1] || '',
            authority: m[2] || '',
            host: m[3] || '',
            hostname: m[4] || '',
            port: m[5] || '',
            pathname: m[6] || '',
            search: m[7] || '',
            hash: m[8] || ''
        } : null;
    };
    can.joinURIs = function (base, href) {
        function removeDotSegments(input) {
            var output = [];
            input.replace(/^(\.\.?(\/|$))+/, '').replace(/\/(\.(\/|$))+/g, '/').replace(/\/\.\.$/, '/../').replace(/\/?[^\/]*/g, function (p) {
                if (p === '/..') {
                    output.pop();
                } else {
                    output.push(p);
                }
            });
            return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
        }
        href = parseURI(href || '');
        base = parseURI(base || '');
        return !href || !base ? null : (href.protocol || base.protocol) + (href.protocol || href.authority ? href.authority : base.authority) + removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : href.pathname ? (base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname : base.pathname) + (href.protocol || href.authority || href.pathname ? href.search : href.search || base.search) + href.hash;
    };
    can['import'] = function (moduleName, parentName) {
        var deferred = new can.Deferred();
        if (typeof window.System === 'object' && can.isFunction(window.System['import'])) {
            window.System['import'](moduleName, { name: parentName }).then(can.proxy(deferred.resolve, deferred), can.proxy(deferred.reject, deferred));
        } else if (window.define && window.define.amd) {
            window.require([moduleName], function (value) {
                deferred.resolve(value);
            });
        } else if (window.steal) {
            steal.steal(moduleName, function (value) {
                deferred.resolve(value);
            });
        } else if (window.require) {
            deferred.resolve(window.require(moduleName));
        } else {
            deferred.resolve();
        }
        return deferred.promise();
    };
    can.__observe = function () {
    };
    can.isNode = typeof process === 'object' && {}.toString.call(process) === '[object process]';
    can.isBrowserWindow = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof SimpleDOM === 'undefined';
    can.isWebWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;
    return can;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#util/attr/attr*/
swifty.define('can/util/attr',['can/util/can'], function (can) {
    var setImmediate = can.global.setImmediate || function (cb) {
            return setTimeout(cb, 0);
        }, formElements = {
            'input': true,
            'textarea': true,
            'select': true
        }, hasProperty = function (el, attrName) {
            return attrName in el || can.document && formElements[el.nodeName.toLowerCase()];
        }, attr = {
            MutationObserver: can.global.MutationObserver || can.global.WebKitMutationObserver || can.global.MozMutationObserver,
            map: {
                'class': function (el, val) {
                    val = val || '';
                    if (el.namespaceURI === 'http://www.w3.org/2000/svg') {
                        el.setAttribute('class', val);
                    } else {
                        el.className = val;
                    }
                    return val;
                },
                'value': 'value',
                'innertext': 'innerText',
                'innerhtml': 'innerHTML',
                'textcontent': 'textContent',
                'for': 'htmlFor',
                'checked': true,
                'disabled': true,
                'readonly': function (el, val) {
                    el.readOnly = true;
                    return val;
                },
                'required': true,
                src: function (el, val) {
                    if (val == null || val === '') {
                        el.removeAttribute('src');
                        return null;
                    } else {
                        el.setAttribute('src', val);
                        return val;
                    }
                },
                style: function () {
                    var el = can.global.document && document.createElement('div');
                    if (el && el.style && 'cssText' in el.style) {
                        return function (el, val) {
                            return el.style.cssText = val || '';
                        };
                    } else {
                        return function (el, val) {
                            return el.setAttribute('style', val);
                        };
                    }
                }()
            },
            defaultValue: [
                'input',
                'textarea'
            ],
            setAttrOrProp: function (el, attrName, val) {
                attrName = attrName.toLowerCase();
                var prop = attr.map[attrName];
                if (prop === true && !val) {
                    this.remove(el, attrName);
                } else {
                    this.set(el, attrName, val);
                }
            },
            setSelectValue: function (el, val) {
                if (val != null) {
                    var options = el.getElementsByTagName('option');
                    for (var i = 0; i < options.length; i++) {
                        if (val == options[i].value) {
                            options[i].selected = true;
                            return;
                        }
                    }
                }
                el.selectedIndex = -1;
            },
            set: function (el, attrName, val) {
                var usingMutationObserver = can.isDOM(el) && attr.MutationObserver;
                attrName = attrName.toLowerCase();
                var oldValue;
                if (!usingMutationObserver) {
                    oldValue = attr.get(el, attrName);
                }
                var prop = attr.map[attrName], newValue;
                if (typeof prop === 'function') {
                    newValue = prop(el, val);
                } else if (prop === true && hasProperty(el, attrName)) {
                    newValue = el[attrName] = true;
                    if (attrName === 'checked' && el.type === 'radio') {
                        if (can.inArray((el.nodeName + '').toLowerCase(), attr.defaultValue) >= 0) {
                            el.defaultChecked = true;
                        }
                    }
                } else if (typeof prop === 'string' && hasProperty(el, prop)) {
                    newValue = val;
                    if (el[prop] !== val || el.nodeName.toUpperCase() === 'OPTION') {
                        el[prop] = val;
                    }
                    if (prop === 'value' && can.inArray((el.nodeName + '').toLowerCase(), attr.defaultValue) >= 0) {
                        el.defaultValue = val;
                    }
                } else {
                    attr.setAttribute(el, attrName, val);
                }
                if (!usingMutationObserver && newValue !== oldValue) {
                    attr.trigger(el, attrName, oldValue);
                }
            },
            setAttribute: function () {
                var doc = can.global.document;
                if (doc && document.createAttribute) {
                    try {
                        doc.createAttribute('{}');
                    } catch (e) {
                        var invalidNodes = {}, attributeDummy = document.createElement('div');
                        return function (el, attrName, val) {
                            var first = attrName.charAt(0), cachedNode, node;
                            if ((first === '{' || first === '(' || first === '*') && el.setAttributeNode) {
                                cachedNode = invalidNodes[attrName];
                                if (!cachedNode) {
                                    attributeDummy.innerHTML = '<div ' + attrName + '=""></div>';
                                    cachedNode = invalidNodes[attrName] = attributeDummy.childNodes[0].attributes[0];
                                }
                                node = cachedNode.cloneNode();
                                node.value = val;
                                el.setAttributeNode(node);
                            } else {
                                el.setAttribute(attrName, val);
                            }
                        };
                    }
                }
                return function (el, attrName, val) {
                    el.setAttribute(attrName, val);
                };
            }(),
            trigger: function (el, attrName, oldValue) {
                if (can.data(can.$(el), 'canHasAttributesBindings')) {
                    attrName = attrName.toLowerCase();
                    return setImmediate(function () {
                        can.trigger(el, {
                            type: 'attributes',
                            attributeName: attrName,
                            target: el,
                            oldValue: oldValue,
                            bubbles: false
                        }, []);
                    });
                }
            },
            get: function (el, attrName) {
                attrName = attrName.toLowerCase();
                var prop = attr.map[attrName];
                if (typeof prop === 'string' && hasProperty(el, prop)) {
                    return el[prop];
                } else if (prop === true && hasProperty(el, attrName)) {
                    return el[attrName];
                }
                return el.getAttribute(attrName);
            },
            remove: function (el, attrName) {
                attrName = attrName.toLowerCase();
                var oldValue;
                if (!attr.MutationObserver) {
                    oldValue = attr.get(el, attrName);
                }
                var setter = attr.map[attrName];
                if (typeof setter === 'function') {
                    setter(el, undefined);
                }
                if (setter === true && hasProperty(el, attrName)) {
                    el[attrName] = false;
                } else if (typeof setter === 'string' && hasProperty(el, setter)) {
                    el[setter] = '';
                } else {
                    el.removeAttribute(attrName);
                }
                if (!attr.MutationObserver && oldValue != null) {
                    attr.trigger(el, attrName, oldValue);
                }
            },
            has: function () {
                var el = can.global.document && document.createElement('div');
                if (el && el.hasAttribute) {
                    return function (el, name) {
                        return el.hasAttribute(name);
                    };
                } else {
                    return function (el, name) {
                        return el.getAttribute(name) !== null;
                    };
                }
            }()
        };
    return attr;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#event/event*/
swifty.define('can/event',['can/util/can'], function (can) {
    can.addEvent = function (event, handler) {
        var allEvents = this.__bindEvents || (this.__bindEvents = {}), eventList = allEvents[event] || (allEvents[event] = []);
        eventList.push({
            handler: handler,
            name: event
        });
        return this;
    };
    can.listenTo = function (other, event, handler) {
        var idedEvents = this.__listenToEvents;
        if (!idedEvents) {
            idedEvents = this.__listenToEvents = {};
        }
        var otherId = can.cid(other);
        var othersEvents = idedEvents[otherId];
        if (!othersEvents) {
            othersEvents = idedEvents[otherId] = {
                obj: other,
                events: {}
            };
        }
        var eventsEvents = othersEvents.events[event];
        if (!eventsEvents) {
            eventsEvents = othersEvents.events[event] = [];
        }
        eventsEvents.push(handler);
        can.bind.call(other, event, handler);
    };
    can.stopListening = function (other, event, handler) {
        var idedEvents = this.__listenToEvents, iterIdedEvents = idedEvents, i = 0;
        if (!idedEvents) {
            return this;
        }
        if (other) {
            var othercid = can.cid(other);
            (iterIdedEvents = {})[othercid] = idedEvents[othercid];
            if (!idedEvents[othercid]) {
                return this;
            }
        }
        for (var cid in iterIdedEvents) {
            var othersEvents = iterIdedEvents[cid], eventsEvents;
            other = idedEvents[cid].obj;
            if (!event) {
                eventsEvents = othersEvents.events;
            } else {
                (eventsEvents = {})[event] = othersEvents.events[event];
            }
            for (var eventName in eventsEvents) {
                var handlers = eventsEvents[eventName] || [];
                i = 0;
                while (i < handlers.length) {
                    if (handler && handler === handlers[i] || !handler) {
                        can.unbind.call(other, eventName, handlers[i]);
                        handlers.splice(i, 1);
                    } else {
                        i++;
                    }
                }
                if (!handlers.length) {
                    delete othersEvents.events[eventName];
                }
            }
            if (can.isEmptyObject(othersEvents.events)) {
                delete idedEvents[cid];
            }
        }
        return this;
    };
    can.removeEvent = function (event, fn, __validate) {
        if (!this.__bindEvents) {
            return this;
        }
        var events = this.__bindEvents[event] || [], i = 0, ev, isFunction = typeof fn === 'function';
        while (i < events.length) {
            ev = events[i];
            if (__validate ? __validate(ev, event, fn) : isFunction && ev.handler === fn || !isFunction && (ev.cid === fn || !fn)) {
                events.splice(i, 1);
            } else {
                i++;
            }
        }
        return this;
    };
    can.dispatch = function (event, args) {
        var events = this.__bindEvents;
        if (!events) {
            return;
        }
        var eventName;
        if (typeof event === 'string') {
            eventName = event;
            event = { type: event };
        } else {
            eventName = event.type;
        }
        var handlers = events[eventName];
        if (!handlers) {
            return;
        } else {
            handlers = handlers.slice(0);
        }
        var passed = [event];
        if (args) {
            passed.push.apply(passed, args);
        }
        for (var i = 0, len = handlers.length; i < len; i++) {
            handlers[i].handler.apply(this, passed);
        }
        return event;
    };
    can.one = function (event, handler) {
        var one = function () {
            can.unbind.call(this, event, one);
            return handler.apply(this, arguments);
        };
        can.bind.call(this, event, one);
        return this;
    };
    can.event = {
        on: function () {
            if (arguments.length === 0 && can.Control && this instanceof can.Control) {
                return can.Control.prototype.on.call(this);
            } else {
                return can.addEvent.apply(this, arguments);
            }
        },
        off: function () {
            if (arguments.length === 0 && can.Control && this instanceof can.Control) {
                return can.Control.prototype.off.call(this);
            } else {
                return can.removeEvent.apply(this, arguments);
            }
        },
        bind: can.addEvent,
        unbind: can.removeEvent,
        delegate: function (selector, event, handler) {
            return can.addEvent.call(this, event, handler);
        },
        undelegate: function (selector, event, handler) {
            return can.removeEvent.call(this, event, handler);
        },
        trigger: can.dispatch,
        one: can.one,
        addEvent: can.addEvent,
        removeEvent: can.removeEvent,
        listenTo: can.listenTo,
        stopListening: can.stopListening,
        dispatch: can.dispatch
    };
    return can.event;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#util/fragment*/
swifty.define('can/fragment',['can/util/can'], function (can) {
    var fragmentRE = /^\s*<(\w+)[^>]*>/, toString = {}.toString, fragment = function (html, name, doc) {
            if (name === undefined) {
                name = fragmentRE.test(html) && RegExp.$1;
            }
            if (html && toString.call(html.replace) === '[object Function]') {
                html = html.replace(/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, '<$1></$2>');
            }
            var container = doc.createElement('div'), temp = doc.createElement('div');
            if (name === 'tbody' || name === 'tfoot' || name === 'thead' || name === 'colgroup') {
                temp.innerHTML = '<table>' + html + '</table>';
                container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild;
            } else if (name === 'col') {
                temp.innerHTML = '<table><colgroup>' + html + '</colgroup></table>';
                container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild;
            } else if (name === 'tr') {
                temp.innerHTML = '<table><tbody>' + html + '</tbody></table>';
                container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild;
            } else if (name === 'td' || name === 'th') {
                temp.innerHTML = '<table><tbody><tr>' + html + '</tr></tbody></table>';
                container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild.firstChild;
            } else if (name === 'option') {
                temp.innerHTML = '<select>' + html + '</select>';
                container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild;
            } else {
                container.innerHTML = '' + html;
            }
            var tmp = {}, children = can.childNodes(container);
            tmp.length = children.length;
            for (var i = 0; i < children.length; i++) {
                tmp[i] = children[i];
            }
            return [].slice.call(tmp);
        };
    can.buildFragment = function (html, doc) {
        if (html && html.nodeType === 11) {
            return html;
        }
        if (!doc) {
            doc = document;
        } else if (doc.length) {
            doc = doc[0];
        }
        var parts = fragment(html, undefined, doc), frag = (doc || document).createDocumentFragment();
        for (var i = 0, length = parts.length; i < length; i++) {
            frag.appendChild(parts[i]);
        }
        return frag;
    };
    (function () {
        var text = '<-\n>', frag = can.buildFragment(text, document);
        if (text !== frag.firstChild.nodeValue) {
            var oldBuildFragment = can.buildFragment;
            can.buildFragment = function (html, nodes) {
                var res = oldBuildFragment(html, nodes);
                if (res.childNodes.length === 1 && res.childNodes[0].nodeType === 3) {
                    res.childNodes[0].nodeValue = html;
                }
                return res;
            };
        }
    }());
    return can;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#util/array/isArrayLike*/
swifty.define('can/util/isArrayLike',['can/util/can'], function (can) {
    can.isArrayLike = function (obj) {
        var length = obj && typeof obj !== 'boolean' && typeof obj !== 'number' && 'length' in obj && obj.length;
        return typeof arr !== 'function' && (length === 0 || typeof length === 'number' && length > 0 && length - 1 in obj);
    };
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#util/array/each*/
swifty.define('can/util/each',[
    'can/util/can',
    'can/util/isArrayLike'
], function (can) {
    can.each = function (elements, callback, context) {
        var i = 0, key, len, item;
        if (elements) {
            if (can.isArrayLike(elements)) {
                if (can.List && elements instanceof can.List) {
                    for (len = elements.attr('length'); i < len; i++) {
                        item = elements.attr(i);
                        if (callback.call(context || item, item, i, elements) === false) {
                            break;
                        }
                    }
                } else {
                    for (len = elements.length; i < len; i++) {
                        item = elements[i];
                        if (callback.call(context || item, item, i, elements) === false) {
                            break;
                        }
                    }
                }
            } else if (typeof elements === 'object') {
                if (can.Map && elements instanceof can.Map || elements === can.route) {
                    var keys = can.Map.keys(elements);
                    for (i = 0, len = keys.length; i < len; i++) {
                        key = keys[i];
                        item = elements.attr(key);
                        if (callback.call(context || item, item, key, elements) === false) {
                            break;
                        }
                    }
                } else {
                    for (key in elements) {
                        if (Object.prototype.hasOwnProperty.call(elements, key) && callback.call(context || elements[key], elements[key], key, elements) === false) {
                            break;
                        }
                    }
                }
            }
        }
        return elements;
    };
    return can;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#util/inserted/inserted*/
swifty.define('can/util/inserted',['can/util/can'], function (can) {
    can.inserted = function (elems, document) {
        if (!elems.length) {
            return;
        }
        elems = can.makeArray(elems);
        var doc = document || elems[0].ownerDocument || elems[0], inDocument = false, root = can.$(doc.contains ? doc : doc.body), children;
        for (var i = 0, elem; (elem = elems[i]) !== undefined; i++) {
            if (!inDocument) {
                if (elem.getElementsByTagName) {
                    if (can.has(root, elem).length) {
                        inDocument = true;
                    } else {
                        return;
                    }
                } else {
                    continue;
                }
            }
            if (inDocument && elem.getElementsByTagName) {
                children = can.makeArray(elem.getElementsByTagName('*'));
                can.trigger(elem, 'inserted', [], false);
                for (var j = 0, child; (child = children[j]) !== undefined; j++) {
                    can.trigger(child, 'inserted', [], false);
                }
            }
        }
    };
    can.appendChild = function (el, child, document) {
        var children;
        if (child.nodeType === 11) {
            children = can.makeArray(can.childNodes(child));
        } else {
            children = [child];
        }
        el.appendChild(child);
        can.inserted(children, document);
    };
    can.insertBefore = function (el, child, ref, document) {
        var children;
        if (child.nodeType === 11) {
            children = can.makeArray(can.childNodes(child));
        } else {
            children = [child];
        }
        el.insertBefore(child, ref);
        can.inserted(children, document);
    };
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#util/jquery/jquery*/
swifty.define('can/util/jquery',[
    'jquery',
    'can/util/can',
    'can/util/attr',
    'can/event',
    'can/fragment',
    'can/util/each',
    'can/util/inserted'
], function ($, can, attr, event) {
    var isBindableElement = function (node) {
        return node.nodeName && (node.nodeType === 1 || node.nodeType === 9) || node == window || node.addEventListener;
    };
    $ = $ || window.jQuery;
    $.extend(can, $, {
        trigger: function (obj, event, args, bubbles) {
            if (isBindableElement(obj)) {
                $.event.trigger(event, args, obj, !bubbles);
            } else if (obj.trigger) {
                obj.trigger(event, args);
            } else {
                if (typeof event === 'string') {
                    event = { type: event };
                }
                event.target = event.target || obj;
                if (args) {
                    if (args.length && typeof args === 'string') {
                        args = [args];
                    } else if (!args.length) {
                        args = [args];
                    }
                }
                if (!args) {
                    args = [];
                }
                can.dispatch.call(obj, event, args);
            }
        },
        event: can.event,
        addEvent: can.addEvent,
        removeEvent: can.removeEvent,
        buildFragment: can.buildFragment,
        $: $,
        each: can.each,
        bind: function (ev, cb) {
            if (this.bind && this.bind !== can.bind) {
                this.bind(ev, cb);
            } else if (isBindableElement(this)) {
                $.event.add(this, ev, cb);
            } else {
                can.addEvent.call(this, ev, cb);
            }
            return this;
        },
        unbind: function (ev, cb) {
            if (this.unbind && this.unbind !== can.unbind) {
                this.unbind(ev, cb);
            } else if (isBindableElement(this)) {
                $.event.remove(this, ev, cb);
            } else {
                can.removeEvent.call(this, ev, cb);
            }
            return this;
        },
        delegate: function (selector, ev, cb) {
            if (this.delegate) {
                this.delegate(selector, ev, cb);
            } else if (isBindableElement(this)) {
                $(this).delegate(selector, ev, cb);
            } else {
                can.bind.call(this, ev, cb);
            }
            return this;
        },
        undelegate: function (selector, ev, cb) {
            if (this.undelegate) {
                this.undelegate(selector, ev, cb);
            } else if (isBindableElement(this)) {
                $(this).undelegate(selector, ev, cb);
            } else {
                can.unbind.call(this, ev, cb);
            }
            return this;
        },
        proxy: can.proxy,
        attr: attr
    });
    can.on = can.bind;
    can.off = can.unbind;
    $.each([
        'append',
        'filter',
        'addClass',
        'remove',
        'data',
        'get',
        'has'
    ], function (i, name) {
        can[name] = function (wrapped) {
            return wrapped[name].apply(wrapped, can.makeArray(arguments).slice(1));
        };
    });
    var oldClean = $.cleanData;
    $.cleanData = function (elems) {
        $.each(elems, function (i, elem) {
            if (elem) {
                can.trigger(elem, 'removed', [], false);
            }
        });
        oldClean(elems);
    };
    var oldDomManip = $.fn.domManip, cbIndex;
    $.fn.domManip = function (args, cb1, cb2) {
        for (var i = 1; i < arguments.length; i++) {
            if (typeof arguments[i] === 'function') {
                cbIndex = i;
                break;
            }
        }
        return oldDomManip.apply(this, arguments);
    };
    $(document.createElement('div')).append(document.createElement('div'));
    var getChildNodes = function (node) {
        var childNodes = node.childNodes;
        if ('length' in childNodes) {
            return can.makeArray(childNodes);
        } else {
            var cur = node.firstChild;
            var nodes = [];
            while (cur) {
                nodes.push(cur);
                cur = cur.nextSibling;
            }
            return nodes;
        }
    };
    if (cbIndex === undefined) {
        $.fn.domManip = oldDomManip;
        can.each([
            'after',
            'prepend',
            'before',
            'append',
            'replaceWith'
        ], function (name) {
            var original = $.fn[name];
            $.fn[name] = function () {
                var elems = [], args = can.makeArray(arguments);
                if (args[0] != null) {
                    if (typeof args[0] === 'string') {
                        args[0] = can.buildFragment(args[0]);
                    }
                    if (args[0].nodeType === 11) {
                        elems = getChildNodes(args[0]);
                    } else if (can.isArrayLike(args[0])) {
                        elems = can.makeArray(args[0]);
                    } else {
                        elems = [args[0]];
                    }
                }
                var ret = original.apply(this, args);
                can.inserted(elems);
                return ret;
            };
        });
    } else {
        $.fn.domManip = cbIndex === 2 ? function (args, table, callback) {
            return oldDomManip.call(this, args, table, function (elem) {
                var elems;
                if (elem.nodeType === 11) {
                    elems = can.makeArray(can.childNodes(elem));
                }
                var ret = callback.apply(this, arguments);
                can.inserted(elems ? elems : [elem]);
                return ret;
            });
        } : function (args, callback) {
            return oldDomManip.call(this, args, function (elem) {
                var elems;
                if (elem.nodeType === 11) {
                    elems = can.makeArray(can.childNodes(elem));
                }
                var ret = callback.apply(this, arguments);
                can.inserted(elems ? elems : [elem]);
                return ret;
            });
        };
    }
    var oldAttr = $.attr;
    $.attr = function (el, attrName) {
        if (can.isDOM(el) && can.attr.MutationObserver) {
            return oldAttr.apply(this, arguments);
        } else {
            var oldValue, newValue;
            if (arguments.length >= 3) {
                oldValue = oldAttr.call(this, el, attrName);
            }
            var res = oldAttr.apply(this, arguments);
            if (arguments.length >= 3) {
                newValue = oldAttr.call(this, el, attrName);
            }
            if (newValue !== oldValue) {
                can.attr.trigger(el, attrName, oldValue);
            }
            return res;
        }
    };
    var oldRemove = $.removeAttr;
    $.removeAttr = function (el, attrName) {
        if (can.isDOM(el) && can.attr.MutationObserver) {
            return oldRemove.apply(this, arguments);
        } else {
            var oldValue = oldAttr.call(this, el, attrName), res = oldRemove.apply(this, arguments);
            if (oldValue != null) {
                can.attr.trigger(el, attrName, oldValue);
            }
            return res;
        }
    };
    $.event.special.attributes = {
        setup: function () {
            if (can.isDOM(this) && can.attr.MutationObserver) {
                var self = this;
                var observer = new can.attr.MutationObserver(function (mutations) {
                    mutations.forEach(function (mutation) {
                        var copy = can.simpleExtend({}, mutation);
                        can.trigger(self, copy, []);
                    });
                });
                observer.observe(this, {
                    attributes: true,
                    attributeOldValue: true
                });
                can.data(can.$(this), 'canAttributesObserver', observer);
            } else {
                can.data(can.$(this), 'canHasAttributesBindings', true);
            }
        },
        teardown: function () {
            if (can.isDOM(this) && can.attr.MutationObserver) {
                can.data(can.$(this), 'canAttributesObserver').disconnect();
                $.removeData(this, 'canAttributesObserver');
            } else {
                $.removeData(this, 'canHasAttributesBindings');
            }
        }
    };
    $.event.special.inserted = {};
    $.event.special.removed = {};
    return can;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#util/library*/
swifty.define('can/util/library',['can/util/jquery'], function (can) {
    return can;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#util/bind/bind*/
swifty.define('can/util/bind',['can/util/library'], function (can) {
    can.bindAndSetup = function () {
        can.addEvent.apply(this, arguments);
        if (!this.__inSetup) {
            if (!this._bindings) {
                this._bindings = 1;
                if (this._bindsetup) {
                    this._bindsetup();
                }
            } else {
                this._bindings++;
            }
        }
        return this;
    };
    can.unbindAndTeardown = function (event, handler) {
        if (!this.__bindEvents) {
            return this;
        }
        var handlers = this.__bindEvents[event] || [];
        var handlerCount = handlers.length;
        can.removeEvent.apply(this, arguments);
        if (this._bindings === null) {
            this._bindings = 0;
        } else {
            this._bindings = this._bindings - (handlerCount - handlers.length);
        }
        if (!this._bindings && this._bindteardown) {
            this._bindteardown();
        }
        return this;
    };
    return can;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#map/bubble*/
swifty.define('can/bubble',['can/util/library'], function (can) {
    var bubble = can.bubble = {
        bind: function (parent, eventName) {
            if (!parent.__inSetup) {
                var bubbleEvents = bubble.events(parent, eventName), len = bubbleEvents.length, bubbleEvent;
                if (!parent._bubbleBindings) {
                    parent._bubbleBindings = {};
                }
                for (var i = 0; i < len; i++) {
                    bubbleEvent = bubbleEvents[i];
                    if (!parent._bubbleBindings[bubbleEvent]) {
                        parent._bubbleBindings[bubbleEvent] = 1;
                        bubble.childrenOf(parent, bubbleEvent);
                    } else {
                        parent._bubbleBindings[bubbleEvent]++;
                    }
                }
            }
        },
        unbind: function (parent, eventName) {
            var bubbleEvents = bubble.events(parent, eventName), len = bubbleEvents.length, bubbleEvent;
            for (var i = 0; i < len; i++) {
                bubbleEvent = bubbleEvents[i];
                if (parent._bubbleBindings) {
                    parent._bubbleBindings[bubbleEvent]--;
                }
                if (parent._bubbleBindings && !parent._bubbleBindings[bubbleEvent]) {
                    delete parent._bubbleBindings[bubbleEvent];
                    bubble.teardownChildrenFrom(parent, bubbleEvent);
                    if (can.isEmptyObject(parent._bubbleBindings)) {
                        delete parent._bubbleBindings;
                    }
                }
            }
        },
        add: function (parent, child, prop) {
            if (child instanceof can.Map && parent._bubbleBindings) {
                for (var eventName in parent._bubbleBindings) {
                    if (parent._bubbleBindings[eventName]) {
                        bubble.teardownFromParent(parent, child, eventName);
                        bubble.toParent(child, parent, prop, eventName);
                    }
                }
            }
        },
        addMany: function (parent, children) {
            for (var i = 0, len = children.length; i < len; i++) {
                bubble.add(parent, children[i], i);
            }
        },
        remove: function (parent, child) {
            if (child instanceof can.Map && parent._bubbleBindings) {
                for (var eventName in parent._bubbleBindings) {
                    if (parent._bubbleBindings[eventName]) {
                        bubble.teardownFromParent(parent, child, eventName);
                    }
                }
            }
        },
        removeMany: function (parent, children) {
            for (var i = 0, len = children.length; i < len; i++) {
                bubble.remove(parent, children[i]);
            }
        },
        set: function (parent, prop, value, current) {
            if (can.isMapLike(value)) {
                bubble.add(parent, value, prop);
            }
            if (can.isMapLike(current)) {
                bubble.remove(parent, current);
            }
            return value;
        },
        events: function (map, boundEventName) {
            return map.constructor._bubbleRule(boundEventName, map);
        },
        toParent: function (child, parent, prop, eventName) {
            can.listenTo.call(parent, child, eventName, function () {
                var args = can.makeArray(arguments), ev = args.shift();
                args[0] = (can.List && parent instanceof can.List ? parent.indexOf(child) : prop) + (args[0] ? '.' + args[0] : '');
                ev.triggeredNS = ev.triggeredNS || {};
                if (ev.triggeredNS[parent._cid]) {
                    return;
                }
                ev.triggeredNS[parent._cid] = true;
                can.trigger(parent, ev, args);
                if (eventName === 'change') {
                    can.trigger(parent, args[0], [
                        args[2],
                        args[3]
                    ]);
                }
            });
        },
        childrenOf: function (parent, eventName) {
            parent._each(function (child, prop) {
                if (child && child.bind) {
                    bubble.toParent(child, parent, prop, eventName);
                }
            });
        },
        teardownFromParent: function (parent, child, eventName) {
            if (child && child.unbind) {
                can.stopListening.call(parent, child, eventName);
            }
        },
        teardownChildrenFrom: function (parent, eventName) {
            parent._each(function (child) {
                bubble.teardownFromParent(parent, child, eventName);
            });
        },
        isBubbling: function (parent, eventName) {
            return parent._bubbleBindings && parent._bubbleBindings[eventName];
        }
    };
    return bubble;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#util/object/isplain/isplain*/
swifty.define('can/util/object/isplain',['can/util/can'], function (can) {
    var core_hasOwn = Object.prototype.hasOwnProperty, isWindow = function (obj) {
            return obj !== null && obj == obj.window;
        }, isPlainObject = function (obj) {
            if (!obj || typeof obj !== 'object' || obj.nodeType || isWindow(obj)) {
                return false;
            }
            try {
                if (obj.constructor && !core_hasOwn.call(obj, 'constructor') && !core_hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')) {
                    return false;
                }
            } catch (e) {
                return false;
            }
            var key;
            for (key in obj) {
            }
            return key === undefined || core_hasOwn.call(obj, key);
        };
    can.isPlainObject = isPlainObject;
    return can;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#map/map_helpers*/
swifty.define('can/map_helpers',[
    'can/util/library',
    'can/util/object/isplain'
], function (can) {
    var mapHelpers = {
        attrParts: function (attr, keepKey) {
            if (keepKey) {
                return [attr];
            }
            return typeof attr === 'object' ? attr : ('' + attr).split('.');
        },
        canMakeObserve: function (obj) {
            return obj && !can.isDeferred(obj) && (can.isArray(obj) || can.isPlainObject(obj));
        },
        serialize: function () {
            var serializeMap = null;
            return function (map, how, where) {
                var cid = can.cid(map), firstSerialize = false;
                if (!serializeMap) {
                    firstSerialize = true;
                    serializeMap = {
                        attr: {},
                        serialize: {}
                    };
                }
                serializeMap[how][cid] = where;
                map.each(function (val, name) {
                    var result, isObservable = can.isMapLike(val), serialized = isObservable && serializeMap[how][can.cid(val)];
                    if (serialized) {
                        result = serialized;
                    } else {
                        if (map['___' + how]) {
                            result = map['___' + how](name, val);
                        } else {
                            result = mapHelpers.getValue(map, name, val, how);
                        }
                    }
                    if (result !== undefined) {
                        where[name] = result;
                    }
                });
                if (firstSerialize) {
                    serializeMap = null;
                }
                return where;
            };
        }(),
        getValue: function (map, name, val, how) {
            if (can.isMapLike(val)) {
                return val[how]();
            } else {
                return val;
            }
        },
        define: null,
        addComputedAttr: function (map, attrName, compute) {
            map._computedAttrs[attrName] = {
                compute: compute,
                count: 0,
                handler: function (ev, newVal, oldVal) {
                    map._triggerChange(attrName, 'set', newVal, oldVal, ev.batchNum);
                }
            };
        },
        addToMap: function addToMap(obj, instance) {
            var teardown;
            if (!madeMap) {
                teardown = teardownMap;
                madeMap = {};
            }
            var hasCid = obj._cid;
            var cid = can.cid(obj);
            if (!madeMap[cid]) {
                madeMap[cid] = {
                    obj: obj,
                    instance: instance,
                    added: !hasCid
                };
            }
            return teardown;
        },
        getMapFromObject: function (obj) {
            return madeMap && madeMap[obj._cid] && madeMap[obj._cid].instance;
        }
    };
    var madeMap = null;
    var teardownMap = function () {
        for (var cid in madeMap) {
            if (madeMap[cid].added) {
                delete madeMap[cid].obj._cid;
            }
        }
        madeMap = null;
    };
    return mapHelpers;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#util/string/string*/
swifty.define('can/util/string',['can/util/library'], function (can) {
    var strUndHash = /_|-/, strColons = /\=\=/, strWords = /([A-Z]+)([A-Z][a-z])/g, strLowUp = /([a-z\d])([A-Z])/g, strDash = /([a-z\d])([A-Z])/g, strReplacer = /\{([^\}]+)\}/g, strQuote = /"/g, strSingleQuote = /'/g, strHyphenMatch = /-+(.)?/g, strCamelMatch = /[a-z][A-Z]/g, getNext = function (obj, prop, add) {
            var result = obj[prop];
            if (result === undefined && add === true) {
                result = obj[prop] = {};
            }
            return result;
        }, isContainer = function (current) {
            return /^f|^o/.test(typeof current);
        }, convertBadValues = function (content) {
            var isInvalid = content === null || content === undefined || isNaN(content) && '' + content === 'NaN';
            return '' + (isInvalid ? '' : content);
        };
    can.extend(can, {
        esc: function (content) {
            return convertBadValues(content).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(strQuote, '&#34;').replace(strSingleQuote, '&#39;');
        },
        getObject: function (name, roots, add) {
            var parts = name ? name.split('.') : [], length = parts.length, current, r = 0, i, container, rootsLength;
            roots = can.isArray(roots) ? roots : [roots || window];
            rootsLength = roots.length;
            if (!length) {
                return roots[0];
            }
            for (r; r < rootsLength; r++) {
                current = roots[r];
                container = undefined;
                for (i = 0; i < length && isContainer(current); i++) {
                    container = current;
                    current = getNext(container, parts[i]);
                }
                if (container !== undefined && current !== undefined) {
                    break;
                }
            }
            if (add === false && current !== undefined) {
                delete container[parts[i - 1]];
            }
            if (add === true && current === undefined) {
                current = roots[0];
                for (i = 0; i < length && isContainer(current); i++) {
                    current = getNext(current, parts[i], true);
                }
            }
            return current;
        },
        capitalize: function (s, cache) {
            return s.charAt(0).toUpperCase() + s.slice(1);
        },
        camelize: function (str) {
            return convertBadValues(str).replace(strHyphenMatch, function (match, chr) {
                return chr ? chr.toUpperCase() : '';
            });
        },
        hyphenate: function (str) {
            return convertBadValues(str).replace(strCamelMatch, function (str, offset) {
                return str.charAt(0) + '-' + str.charAt(1).toLowerCase();
            });
        },
        underscore: function (s) {
            return s.replace(strColons, '/').replace(strWords, '$1_$2').replace(strLowUp, '$1_$2').replace(strDash, '_').toLowerCase();
        },
        sub: function (str, data, remove) {
            var obs = [];
            str = str || '';
            obs.push(str.replace(strReplacer, function (whole, inside) {
                var ob = can.getObject(inside, data, remove === true ? false : undefined);
                if (ob === undefined || ob === null) {
                    obs = null;
                    return '';
                }
                if (isContainer(ob) && obs) {
                    obs.push(ob);
                    return '';
                }
                return '' + ob;
            }));
            return obs === null ? obs : obs.length <= 1 ? obs[0] : obs;
        },
        replacer: strReplacer,
        undHash: strUndHash
    });
    return can;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#construct/construct*/
swifty.define('can/construct',['can/util/string'], function (can) {
    var initializing = 0;
    var canGetDescriptor;
    try {
        Object.getOwnPropertyDescriptor({});
        canGetDescriptor = true;
    } catch (e) {
        canGetDescriptor = false;
    }
    var getDescriptor = function (newProps, name) {
            var descriptor = Object.getOwnPropertyDescriptor(newProps, name);
            if (descriptor && (descriptor.get || descriptor.set)) {
                return descriptor;
            }
            return null;
        }, inheritGetterSetter = function (newProps, oldProps, addTo) {
            addTo = addTo || newProps;
            var descriptor;
            for (var name in newProps) {
                if (descriptor = getDescriptor(newProps, name)) {
                    this._defineProperty(addTo, oldProps, name, descriptor);
                } else {
                    can.Construct._overwrite(addTo, oldProps, name, newProps[name]);
                }
            }
        }, simpleInherit = function (newProps, oldProps, addTo) {
            addTo = addTo || newProps;
            for (var name in newProps) {
                can.Construct._overwrite(addTo, oldProps, name, newProps[name]);
            }
        };
    can.Construct = function () {
        if (arguments.length) {
            return can.Construct.extend.apply(can.Construct, arguments);
        }
    };
    can.extend(can.Construct, {
        constructorExtends: true,
        newInstance: function () {
            var inst = this.instance(), args;
            if (inst.setup) {
                inst.__inSetup = true;
                args = inst.setup.apply(inst, arguments);
                delete inst.__inSetup;
            }
            if (inst.init) {
                inst.init.apply(inst, args || arguments);
            }
            return inst;
        },
        _inherit: canGetDescriptor ? inheritGetterSetter : simpleInherit,
        _defineProperty: function (what, oldProps, propName, descriptor) {
            Object.defineProperty(what, propName, descriptor);
        },
        _overwrite: function (what, oldProps, propName, val) {
            what[propName] = val;
        },
        setup: function (base, fullName) {
            this.defaults = can.extend(true, {}, base.defaults, this.defaults);
        },
        instance: function () {
            initializing = 1;
            var inst = new this();
            initializing = 0;
            return inst;
        },
        extend: function (name, staticProperties, instanceProperties) {
            var fullName = name, klass = staticProperties, proto = instanceProperties;
            if (typeof fullName !== 'string') {
                proto = klass;
                klass = fullName;
                fullName = null;
            }
            if (!proto) {
                proto = klass;
                klass = null;
            }
            proto = proto || {};
            var _super_class = this, _super = this.prototype, Constructor, parts, current, _fullName, _shortName, propName, shortName, namespace, prototype;
            prototype = this.instance();
            can.Construct._inherit(proto, _super, prototype);
            if (fullName) {
                parts = fullName.split('.');
                shortName = parts.pop();
            } else if (klass && klass.shortName) {
                shortName = klass.shortName;
            } else if (this.shortName) {
                shortName = this.shortName;
            }
            if (typeof constructorName === 'undefined') {
                Constructor = function () {
                    return init.apply(this, arguments);
                };
            }
            function init() {
                if (!initializing) {
                    return this.constructor !== Constructor && arguments.length && Constructor.constructorExtends ? Constructor.extend.apply(Constructor, arguments) : Constructor.newInstance.apply(Constructor, arguments);
                }
            }
            for (propName in _super_class) {
                if (_super_class.hasOwnProperty(propName)) {
                    Constructor[propName] = _super_class[propName];
                }
            }
            can.Construct._inherit(klass, _super_class, Constructor);
            if (fullName) {
                current = can.getObject(parts.join('.'), window, true);
                namespace = current;
                _fullName = can.underscore(fullName.replace(/\./g, '_'));
                _shortName = can.underscore(shortName);
                current[shortName] = Constructor;
            }
            can.extend(Constructor, {
                constructor: Constructor,
                prototype: prototype,
                namespace: namespace,
                _shortName: _shortName,
                fullName: fullName,
                _fullName: _fullName
            });
            if (shortName !== undefined) {
                Constructor.shortName = shortName;
            }
            Constructor.prototype.constructor = Constructor;
            var t = [_super_class].concat(can.makeArray(arguments)), args = Constructor.setup.apply(Constructor, t);
            if (Constructor.init) {
                Constructor.init.apply(Constructor, args || t);
            }
            return Constructor;
        }
    });
    can.Construct.prototype.setup = function () {
    };
    can.Construct.prototype.init = function () {
    };
    return can.Construct;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#util/batch/batch*/
swifty.define('can/util/batch',['can/util/can'], function (can) {
    var batchNum = 1, transactions = 0, dispatchingBatch = null, collectingBatch = null, batches = [], dispatchingBatches = false;
    can.batch = {
        start: function (batchStopHandler) {
            transactions++;
            if (transactions === 1) {
                var batch = {
                    events: [],
                    callbacks: [],
                    number: batchNum++
                };
                batches.push(batch);
                if (batchStopHandler) {
                    batch.callbacks.push(batchStopHandler);
                }
                collectingBatch = batch;
            }
        },
        stop: function (force, callStart) {
            if (force) {
                transactions = 0;
            } else {
                transactions--;
            }
            if (transactions === 0) {
                collectingBatch = null;
                var batch;
                if (dispatchingBatches === false) {
                    dispatchingBatches = true;
                    var callbacks = [], i;
                    while (batch = batches.shift()) {
                        var events = batch.events;
                        callbacks.push.apply(callbacks, batch.callbacks);
                        dispatchingBatch = batch;
                        can.batch.batchNum = batch.number;
                        var len;
                        if (callStart) {
                            can.batch.start();
                        }
                        for (i = 0, len = events.length; i < len; i++) {
                            can.dispatch.apply(events[i][0], events[i][1]);
                        }
                        can.batch._onDispatchedEvents(batch.number);
                        dispatchingBatch = null;
                        can.batch.batchNum = undefined;
                    }
                    for (i = callbacks.length - 1; i >= 0; i--) {
                        callbacks[i]();
                    }
                    dispatchingBatches = false;
                }
            }
        },
        _onDispatchedEvents: function () {
        },
        trigger: function (item, event, args) {
            if (!item.__inSetup) {
                event = typeof event === 'string' ? { type: event } : event;
                if (collectingBatch) {
                    event.batchNum = collectingBatch.number;
                    collectingBatch.events.push([
                        item,
                        [
                            event,
                            args
                        ]
                    ]);
                } else if (event.batchNum) {
                    can.dispatch.call(item, event, args);
                } else if (batches.length) {
                    can.batch.start();
                    event.batchNum = collectingBatch.number;
                    collectingBatch.events.push([
                        item,
                        [
                            event,
                            args
                        ]
                    ]);
                    can.batch.stop();
                } else {
                    can.dispatch.call(item, event, args);
                }
            }
        },
        afterPreviousEvents: function (handler) {
            var batch = can.last(batches);
            if (batch) {
                var obj = {};
                can.bind.call(obj, 'ready', handler);
                batch.events.push([
                    obj,
                    [
                        { type: 'ready' },
                        []
                    ]
                ]);
            } else {
                handler({});
            }
        },
        after: function (handler) {
            var batch = collectingBatch || dispatchingBatch;
            if (batch) {
                batch.callbacks.push(handler);
            } else {
                handler({});
            }
        }
    };
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#compute/get_value_and_bind*/
swifty.define('can/get_value_and_bind',['can/util/library'], function (can) {
    function ObservedInfo(func, context, compute) {
        this.newObserved = {};
        this.oldObserved = null;
        this.func = func;
        this.context = context;
        this.compute = compute;
        this.onDependencyChange = can.proxy(this.onDependencyChange, this);
        this.depth = null;
        this.childDepths = {};
        this.ignore = 0;
        this.inBatch = false;
        this.ready = false;
        compute.observedInfo = this;
        this.setReady = can.proxy(this._setReady, this);
    }
    can.simpleExtend(ObservedInfo.prototype, {
        getPrimaryDepth: function () {
            return this.compute._primaryDepth;
        },
        _setReady: function () {
            this.ready = true;
        },
        getDepth: function () {
            if (this.depth !== null) {
                return this.depth;
            } else {
                return this.depth = this._getDepth();
            }
        },
        _getDepth: function () {
            var max = 0, childDepths = this.childDepths;
            for (var cid in childDepths) {
                if (childDepths[cid] > max) {
                    max = childDepths[cid];
                }
            }
            return max + 1;
        },
        addEdge: function (objEv) {
            objEv.obj.bind(objEv.event, this.onDependencyChange);
            if (objEv.obj.observedInfo) {
                this.childDepths[objEv.obj._cid] = objEv.obj.observedInfo.getDepth();
                this.depth = null;
            }
        },
        removeEdge: function (objEv) {
            objEv.obj.unbind(objEv.event, this.onDependencyChange);
            if (objEv.obj.observedInfo) {
                delete this.childDepths[objEv.obj._cid];
                this.depth = null;
            }
        },
        dependencyChange: function (ev) {
            if (this.bound && this.ready) {
                if (ev.batchNum !== undefined) {
                    if (ev.batchNum !== this.batchNum) {
                        ObservedInfo.registerUpdate(this);
                        this.batchNum = ev.batchNum;
                    }
                } else {
                    this.updateCompute(ev.batchNum);
                }
            }
        },
        onDependencyChange: function (ev, newVal, oldVal) {
            this.dependencyChange(ev, newVal, oldVal);
        },
        updateCompute: function (batchNum) {
            if (this.bound) {
                var oldValue = this.value;
                this.getValueAndBind();
                this.compute.updater(this.value, oldValue, batchNum);
            }
        },
        getValueAndBind: function () {
            this.bound = true;
            this.oldObserved = this.newObserved || {};
            this.ignore = 0;
            this.newObserved = {};
            this.ready = false;
            observedInfoStack.push(this);
            this.value = this.func.call(this.context);
            observedInfoStack.pop();
            this.updateBindings();
            can.batch.afterPreviousEvents(this.setReady);
        },
        updateBindings: function () {
            var newObserved = this.newObserved, oldObserved = this.oldObserved, name, obEv;
            for (name in newObserved) {
                obEv = newObserved[name];
                if (!oldObserved[name]) {
                    this.addEdge(obEv);
                } else {
                    oldObserved[name] = null;
                }
            }
            for (name in oldObserved) {
                obEv = oldObserved[name];
                if (obEv) {
                    this.removeEdge(obEv);
                }
            }
        },
        teardown: function () {
            this.bound = false;
            for (var name in this.newObserved) {
                var ob = this.newObserved[name];
                this.removeEdge(ob);
            }
            this.newObserved = {};
        }
    });
    var updateOrder = [], curPrimaryDepth = Infinity, maxPrimaryDepth = 0;
    ObservedInfo.registerUpdate = function (observeInfo, batchNum) {
        var depth = observeInfo.getDepth() - 1;
        var primaryDepth = observeInfo.getPrimaryDepth();
        curPrimaryDepth = Math.min(primaryDepth, curPrimaryDepth);
        maxPrimaryDepth = Math.max(primaryDepth, maxPrimaryDepth);
        var primary = updateOrder[primaryDepth] || (updateOrder[primaryDepth] = {
            observeInfos: [],
            current: Infinity,
            max: 0
        });
        var objs = primary.observeInfos[depth] || (primary.observeInfos[depth] = []);
        objs.push(observeInfo);
        primary.current = Math.min(depth, primary.current);
        primary.max = Math.max(depth, primary.max);
    };
    ObservedInfo.batchEnd = function (batchNum) {
        var cur;
        while (true) {
            if (curPrimaryDepth <= maxPrimaryDepth) {
                var primary = updateOrder[curPrimaryDepth];
                if (primary && primary.current <= primary.max) {
                    var last = primary.observeInfos[primary.current];
                    if (last && (cur = last.pop())) {
                        cur.updateCompute(batchNum);
                    } else {
                        primary.current++;
                    }
                } else {
                    curPrimaryDepth++;
                }
            } else {
                updateOrder = [];
                curPrimaryDepth = Infinity;
                maxPrimaryDepth = 0;
                return;
            }
        }
    };
    var observedInfoStack = [];
    can.__observe = function (obj, event) {
        var top = observedInfoStack[observedInfoStack.length - 1];
        if (top && !top.ignore) {
            var evStr = event + '', name = obj._cid + '|' + evStr;
            if (top.traps) {
                top.traps.push({
                    obj: obj,
                    event: evStr,
                    name: name
                });
            } else if (!top.newObserved[name]) {
                top.newObserved[name] = {
                    obj: obj,
                    event: evStr
                };
            }
        }
    };
    can.__reading = can.__observe;
    can.__trapObserves = function () {
        if (observedInfoStack.length) {
            var top = observedInfoStack[observedInfoStack.length - 1];
            var traps = top.traps = [];
            return function () {
                top.traps = null;
                return traps;
            };
        } else {
            return function () {
                return [];
            };
        }
    };
    can.__observes = function (observes) {
        var top = observedInfoStack[observedInfoStack.length - 1];
        if (top) {
            for (var i = 0, len = observes.length; i < len; i++) {
                var trap = observes[i], name = trap.name;
                if (!top.newObserved[name]) {
                    top.newObserved[name] = trap;
                }
            }
        }
    };
    can.__isRecordingObserves = function () {
        var len = observedInfoStack.length;
        return len && observedInfoStack[len - 1].ignore === 0;
    };
    can.__notObserve = function (fn) {
        return function () {
            if (observedInfoStack.length) {
                var top = observedInfoStack[observedInfoStack.length - 1];
                top.ignore++;
                var res = fn.apply(this, arguments);
                top.ignore--;
                return res;
            } else {
                return fn.apply(this, arguments);
            }
        };
    };
    can.batch._onDispatchedEvents = ObservedInfo.batchEnd;
    return ObservedInfo;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#map/map*/
swifty.define('can/map',[
    'can/util/library',
    'can/util/bind',
    'can/bubble',
    'can/map_helpers',
    'can/construct',
    'can/util/batch',
    'can/get_value_and_bind'
], function (can, bind, bubble, mapHelpers) {
    var unobservable = { 'constructor': true };
    var Map = can.Map = can.Construct.extend({
        setup: function () {
            can.Construct.setup.apply(this, arguments);
            this._computedPropertyNames = [];
            if (can.Map) {
                if (!this.defaults) {
                    this.defaults = {};
                }
                for (var prop in this.prototype) {
                    if (prop !== 'define' && prop !== 'constructor' && (typeof this.prototype[prop] !== 'function' || this.prototype[prop].prototype instanceof can.Construct)) {
                        this.defaults[prop] = this.prototype[prop];
                    } else if (this.prototype[prop].isComputed) {
                        this._computedPropertyNames.push(prop);
                    }
                }
                if (mapHelpers.define) {
                    mapHelpers.define(this);
                }
            }
            if (can.List && !(this.prototype instanceof can.List)) {
                this.List = Map.List.extend({ Map: this }, {});
            }
        },
        shortName: 'Map',
        _bubbleRule: function (eventName) {
            return eventName === 'change' || eventName.indexOf('.') >= 0 ? ['change'] : [];
        },
        bind: can.bindAndSetup,
        unbind: can.unbindAndTeardown,
        id: 'id',
        keys: function (map) {
            var keys = [];
            can.__observe(map, '__keys');
            for (var keyName in map._data) {
                keys.push(keyName);
            }
            return keys;
        }
    }, {
        setup: function (obj) {
            if (obj instanceof can.Map) {
                obj = obj.serialize();
            }
            this._data = {};
            can.cid(this, '.map');
            this._setupComputedProperties();
            var teardownMapping = obj && mapHelpers.addToMap(obj, this);
            var defaultValues = this._setupDefaults(obj);
            var data = can.extend(can.extend(true, {}, defaultValues), obj);
            this.attr(data);
            if (teardownMapping) {
                teardownMapping();
            }
        },
        _setupComputedProperties: function () {
            this._computedAttrs = {};
            var computes = this.constructor._computedPropertyNames;
            for (var i = 0, len = computes.length; i < len; i++) {
                var attrName = computes[i];
                mapHelpers.addComputedAttr(this, attrName, this[attrName].clone(this));
            }
        },
        _setupDefaults: function () {
            return this.constructor.defaults || {};
        },
        attr: function (attr, val) {
            var type = typeof attr;
            if (attr === undefined) {
                return this._getAttrs();
            } else if (type !== 'string' && type !== 'number') {
                return this._setAttrs(attr, val);
            } else if (arguments.length === 1) {
                return this._get(attr + '');
            } else {
                this._set(attr + '', val);
                return this;
            }
        },
        _get: function (attr) {
            var dotIndex = attr.indexOf('.');
            if (dotIndex >= 0) {
                var value = this.___get(attr);
                if (value !== undefined) {
                    can.__observe(this, attr);
                    return value;
                }
                var first = attr.substr(0, dotIndex), second = attr.substr(dotIndex + 1);
                var current = this.__get(first);
                return current && current._get ? current._get(second) : undefined;
            } else {
                return this.__get(attr);
            }
        },
        __get: function (attr) {
            if (!unobservable[attr] && !this._computedAttrs[attr]) {
                can.__observe(this, attr);
            }
            return this.___get(attr);
        },
        ___get: function (attr) {
            if (attr !== undefined) {
                var computedAttr = this._computedAttrs[attr];
                if (computedAttr && computedAttr.compute) {
                    return computedAttr.compute();
                } else {
                    return this._data.hasOwnProperty(attr) ? this._data[attr] : undefined;
                }
            } else {
                return this._data;
            }
        },
        _set: function (attr, value, keepKey) {
            var dotIndex = attr.indexOf('.'), current;
            if (dotIndex >= 0 && !keepKey) {
                var first = attr.substr(0, dotIndex), second = attr.substr(dotIndex + 1);
                current = this.__inSetup ? undefined : this.___get(first);
                if (can.isMapLike(current)) {
                    current._set(second, value);
                } else {
                    throw new Error('can.Map: Object does not exist');
                }
            } else {
                current = this.__inSetup ? undefined : this.___get(attr);
                if (this.__convert) {
                    value = this.__convert(attr, value);
                }
                this.__set(attr, this.__type(value, attr), current);
            }
        },
        __type: function (value, prop) {
            if (typeof value === 'object' && !(value instanceof can.Map) && mapHelpers.canMakeObserve(value)) {
                var cached = mapHelpers.getMapFromObject(value);
                if (cached) {
                    return cached;
                }
                if (can.isArray(value)) {
                    var List = can.List;
                    return new List(value);
                } else {
                    var Map = this.constructor.Map || can.Map;
                    return new Map(value);
                }
            }
            return value;
        },
        __set: function (prop, value, current) {
            if (value !== current) {
                var computedAttr = this._computedAttrs[prop];
                var changeType = computedAttr || current !== undefined || this.___get().hasOwnProperty(prop) ? 'set' : 'add';
                this.___set(prop, typeof value === 'object' ? bubble.set(this, prop, value, current) : value);
                if (!computedAttr || !computedAttr.count) {
                    this._triggerChange(prop, changeType, value, current);
                }
                if (typeof current === 'object') {
                    bubble.teardownFromParent(this, current);
                }
            }
        },
        ___set: function (prop, val) {
            var computedAttr = this._computedAttrs[prop];
            if (computedAttr) {
                computedAttr.compute(val);
            } else {
                this._data[prop] = val;
            }
            if (typeof this.constructor.prototype[prop] !== 'function' && !computedAttr) {
                this[prop] = val;
            }
        },
        removeAttr: function (attr) {
            return this._remove(attr);
        },
        _remove: function (attr) {
            var parts = mapHelpers.attrParts(attr), prop = parts.shift(), current = this.___get(prop);
            if (parts.length && current) {
                return current.removeAttr(parts);
            } else {
                if (typeof attr === 'string' && !!~attr.indexOf('.')) {
                    prop = attr;
                }
                this.__remove(prop, current);
                return current;
            }
        },
        __remove: function (prop, current) {
            if (prop in this._data) {
                this.___remove(prop);
                this._triggerChange(prop, 'remove', undefined, current);
            }
        },
        ___remove: function (prop) {
            delete this._data[prop];
            if (!(prop in this.constructor.prototype)) {
                delete this[prop];
            }
        },
        ___serialize: function (name, val) {
            return mapHelpers.getValue(this, name, val, 'serialize');
        },
        _getAttrs: function () {
            return mapHelpers.serialize(this, 'attr', {});
        },
        _setAttrs: function (props, remove) {
            props = can.simpleExtend({}, props);
            var prop, self = this, newVal;
            can.batch.start();
            this._each(function (curVal, prop) {
                if (prop === '_cid') {
                    return;
                }
                newVal = props[prop];
                if (newVal === undefined) {
                    if (remove) {
                        self.removeAttr(prop);
                    }
                    return;
                }
                if (self.__convert) {
                    newVal = self.__convert(prop, newVal);
                }
                if (can.isMapLike(curVal) && mapHelpers.canMakeObserve(newVal)) {
                    curVal.attr(newVal, remove);
                } else if (curVal !== newVal) {
                    self.__set(prop, self.__type(newVal, prop), curVal);
                }
                delete props[prop];
            });
            for (prop in props) {
                if (prop !== '_cid') {
                    newVal = props[prop];
                    this._set(prop, newVal, true);
                }
            }
            can.batch.stop();
            return this;
        },
        serialize: function () {
            return mapHelpers.serialize(this, 'serialize', {});
        },
        _triggerChange: function (attr, how, newVal, oldVal, batchNum) {
            if (bubble.isBubbling(this, 'change')) {
                can.batch.trigger(this, {
                    type: 'change',
                    target: this,
                    batchNum: batchNum
                }, [
                    attr,
                    how,
                    newVal,
                    oldVal
                ]);
            }
            can.batch.trigger(this, {
                type: attr,
                target: this,
                batchNum: batchNum
            }, [
                newVal,
                oldVal
            ]);
            if (how === 'remove' || how === 'add') {
                can.batch.trigger(this, {
                    type: '__keys',
                    target: this,
                    batchNum: batchNum
                });
            }
        },
        _bindsetup: function () {
        },
        _bindteardown: function () {
        },
        one: can.one,
        bind: function (eventName, handler) {
            var computedBinding = this._computedAttrs && this._computedAttrs[eventName];
            if (computedBinding && computedBinding.compute) {
                if (!computedBinding.count) {
                    computedBinding.count = 1;
                    computedBinding.compute.bind('change', computedBinding.handler);
                } else {
                    computedBinding.count++;
                }
            }
            bubble.bind(this, eventName);
            return can.bindAndSetup.apply(this, arguments);
        },
        unbind: function (eventName, handler) {
            var computedBinding = this._computedAttrs && this._computedAttrs[eventName];
            if (computedBinding) {
                if (computedBinding.count === 1) {
                    computedBinding.count = 0;
                    computedBinding.compute.unbind('change', computedBinding.handler);
                } else {
                    computedBinding.count--;
                }
            }
            bubble.unbind(this, eventName);
            return can.unbindAndTeardown.apply(this, arguments);
        },
        compute: function (prop) {
            if (can.isFunction(this.constructor.prototype[prop])) {
                return can.compute(this[prop], this);
            } else {
                var reads = can.compute.read.reads(prop), last = reads.length - 1;
                return can.compute(function (newVal) {
                    if (arguments.length) {
                        can.compute.read(this, reads.slice(0, last)).value.attr(reads[last].key, newVal);
                    } else {
                        return can.compute.read(this, reads, { args: [] }).value;
                    }
                }, this);
            }
        },
        each: function () {
            return can.each.apply(undefined, [this].concat(can.makeArray(arguments)));
        },
        _each: function (callback) {
            var data = this.___get();
            for (var prop in data) {
                if (data.hasOwnProperty(prop)) {
                    callback(data[prop], prop);
                }
            }
        },
        dispatch: can.dispatch
    });
    Map.prototype.on = Map.prototype.bind;
    Map.prototype.off = Map.prototype.unbind;
    Map.on = Map.bind;
    Map.off = Map.unbind;
    return Map;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#list/list*/
swifty.define('can/list',[
    'can/util/library',
    'can/map',
    'can/bubble',
    'can/map_helpers'
], function (can, Map, bubble, mapHelpers) {
    var splice = [].splice, spliceRemovesProps = function () {
            var obj = {
                0: 'a',
                length: 1
            };
            splice.call(obj, 0, 1);
            return !obj[0];
        }();
    var list = Map.extend({ Map: Map }, {
            setup: function (instances, options) {
                this.length = 0;
                can.cid(this, '.map');
                this._setupComputedProperties();
                instances = instances || [];
                var teardownMapping;
                if (can.isDeferred(instances)) {
                    this.replace(instances);
                } else {
                    teardownMapping = instances.length && mapHelpers.addToMap(instances, this);
                    this.push.apply(this, can.makeArray(instances || []));
                }
                if (teardownMapping) {
                    teardownMapping();
                }
                can.simpleExtend(this, options);
            },
            _triggerChange: function (attr, how, newVal, oldVal) {
                Map.prototype._triggerChange.apply(this, arguments);
                var index = +attr;
                if (!~('' + attr).indexOf('.') && !isNaN(index)) {
                    if (how === 'add') {
                        can.batch.trigger(this, how, [
                            newVal,
                            index
                        ]);
                        can.batch.trigger(this, 'length', [this.length]);
                    } else if (how === 'remove') {
                        can.batch.trigger(this, how, [
                            oldVal,
                            index
                        ]);
                        can.batch.trigger(this, 'length', [this.length]);
                    } else {
                        can.batch.trigger(this, how, [
                            newVal,
                            index
                        ]);
                    }
                }
            },
            ___get: function (attr) {
                if (attr) {
                    var computedAttr = this._computedAttrs[attr];
                    if (computedAttr && computedAttr.compute) {
                        return computedAttr.compute();
                    } else {
                        return this[attr];
                    }
                } else {
                    return this;
                }
            },
            __set: function (prop, value, current) {
                prop = isNaN(+prop) || prop % 1 ? prop : +prop;
                if (typeof prop === 'number' && prop > this.length - 1) {
                    var newArr = new Array(prop + 1 - this.length);
                    newArr[newArr.length - 1] = value;
                    this.push.apply(this, newArr);
                    return newArr;
                }
                return can.Map.prototype.__set.call(this, '' + prop, value, current);
            },
            ___set: function (attr, val) {
                this[attr] = val;
                if (+attr >= this.length) {
                    this.length = +attr + 1;
                }
            },
            __remove: function (prop, current) {
                if (isNaN(+prop)) {
                    delete this[prop];
                    this._triggerChange(prop, 'remove', undefined, current);
                } else {
                    this.splice(prop, 1);
                }
            },
            _each: function (callback) {
                var data = this.___get();
                for (var i = 0; i < data.length; i++) {
                    callback(data[i], i);
                }
            },
            serialize: function () {
                return mapHelpers.serialize(this, 'serialize', []);
            },
            splice: function (index, howMany) {
                var args = can.makeArray(arguments), added = [], i, len, listIndex, allSame = args.length > 2;
                index = index || 0;
                for (i = 0, len = args.length - 2; i < len; i++) {
                    listIndex = i + 2;
                    args[listIndex] = this.__type(args[listIndex], listIndex);
                    added.push(args[listIndex]);
                    if (this[i + index] !== args[listIndex]) {
                        allSame = false;
                    }
                }
                if (allSame && this.length <= added.length) {
                    return added;
                }
                if (howMany === undefined) {
                    howMany = args[1] = this.length - index;
                }
                var removed = splice.apply(this, args);
                if (!spliceRemovesProps) {
                    for (i = this.length; i < removed.length + this.length; i++) {
                        delete this[i];
                    }
                }
                can.batch.start();
                if (howMany > 0) {
                    bubble.removeMany(this, removed);
                    this._triggerChange('' + index, 'remove', undefined, removed);
                }
                if (args.length > 2) {
                    bubble.addMany(this, added);
                    this._triggerChange('' + index, 'add', added, removed);
                }
                can.batch.stop();
                return removed;
            },
            _getAttrs: function () {
                return mapHelpers.serialize(this, 'attr', []);
            },
            _setAttrs: function (items, remove) {
                items = can.makeArray(items);
                can.batch.start();
                this._updateAttrs(items, remove);
                can.batch.stop();
            },
            _updateAttrs: function (items, remove) {
                var len = Math.min(items.length, this.length);
                for (var prop = 0; prop < len; prop++) {
                    var curVal = this[prop], newVal = items[prop];
                    if (can.isMapLike(curVal) && mapHelpers.canMakeObserve(newVal)) {
                        curVal.attr(newVal, remove);
                    } else if (curVal !== newVal) {
                        this._set(prop + '', newVal);
                    } else {
                    }
                }
                if (items.length > this.length) {
                    this.push.apply(this, items.slice(this.length));
                } else if (items.length < this.length && remove) {
                    this.splice(items.length);
                }
            }
        }), getArgs = function (args) {
            return args[0] && can.isArray(args[0]) ? args[0] : can.makeArray(args);
        };
    can.each({
        push: 'length',
        unshift: 0
    }, function (where, name) {
        var orig = [][name];
        list.prototype[name] = function () {
            can.batch.start();
            var args = [], len = where ? this.length : 0, i = arguments.length, res, val;
            while (i--) {
                val = arguments[i];
                args[i] = bubble.set(this, i, this.__type(val, i));
            }
            res = orig.apply(this, args);
            if (!this.comparator || args.length) {
                this._triggerChange('' + len, 'add', args, undefined);
            }
            can.batch.stop();
            return res;
        };
    });
    can.each({
        pop: 'length',
        shift: 0
    }, function (where, name) {
        list.prototype[name] = function () {
            if (!this.length) {
                return undefined;
            }
            var args = getArgs(arguments), len = where && this.length ? this.length - 1 : 0;
            var res = [][name].apply(this, args);
            can.batch.start();
            this._triggerChange('' + len, 'remove', undefined, [res]);
            if (res && res.unbind) {
                bubble.remove(this, res);
            }
            can.batch.stop();
            return res;
        };
    });
    can.extend(list.prototype, {
        indexOf: function (item, fromIndex) {
            can.__observe(this, 'length');
            return can.inArray(item, this, fromIndex);
        },
        join: function () {
            can.__observe(this, 'length');
            return [].join.apply(this, arguments);
        },
        reverse: function () {
            var list = [].reverse.call(can.makeArray(this));
            return this.replace(list);
        },
        slice: function () {
            can.__observe(this, 'length');
            var temp = Array.prototype.slice.apply(this, arguments);
            return new this.constructor(temp);
        },
        concat: function () {
            var args = [];
            can.each(can.makeArray(arguments), function (arg, i) {
                args[i] = arg instanceof can.List ? arg.serialize() : arg;
            });
            return new this.constructor(Array.prototype.concat.apply(this.serialize(), args));
        },
        forEach: function (cb, thisarg) {
            return can.each(this, cb, thisarg || this);
        },
        replace: function (newList) {
            if (can.isDeferred(newList)) {
                if (this._promise) {
                    this._promise.__isCurrentPromise = false;
                }
                var promise = this._promise = newList;
                promise.__isCurrentPromise = true;
                var self = this;
                newList.then(function (newList) {
                    if (promise.__isCurrentPromise) {
                        self.replace(newList);
                    }
                });
            } else {
                this.splice.apply(this, [
                    0,
                    this.length
                ].concat(can.makeArray(newList || [])));
            }
            return this;
        },
        filter: function (callback, thisArg) {
            var filteredList = new this.constructor(), self = this, filtered;
            this.each(function (item, index, list) {
                filtered = callback.call(thisArg | self, item, index, self);
                if (filtered) {
                    filteredList.push(item);
                }
            });
            return filteredList;
        },
        map: function (callback, thisArg) {
            var filteredList = new can.List(), self = this;
            this.each(function (item, index, list) {
                var mapped = callback.call(thisArg | self, item, index, self);
                filteredList.push(mapped);
            });
            return filteredList;
        }
    });
    can.List = Map.List = list;
    return can.List;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#util/string/deparam/deparam*/
swifty.define('can/util/string/deparam',[
    'can/util/library',
    'can/util/string'
], function (can) {
    var digitTest = /^\d+$/, keyBreaker = /([^\[\]]+)|(\[\])/g, paramTest = /([^?#]*)(#.*)?$/, prep = function (str) {
            return decodeURIComponent(str.replace(/\+/g, ' '));
        };
    can.extend(can, {
        deparam: function (params) {
            var data = {}, pairs, lastPart;
            if (params && paramTest.test(params)) {
                pairs = params.split('&');
                can.each(pairs, function (pair) {
                    var parts = pair.split('='), key = prep(parts.shift()), value = prep(parts.join('=')), current = data;
                    if (key) {
                        parts = key.match(keyBreaker);
                        for (var j = 0, l = parts.length - 1; j < l; j++) {
                            if (!current[parts[j]]) {
                                current[parts[j]] = digitTest.test(parts[j + 1]) || parts[j + 1] === '[]' ? [] : {};
                            }
                            current = current[parts[j]];
                        }
                        lastPart = parts.pop();
                        if (lastPart === '[]') {
                            current.push(value);
                        } else {
                            current[lastPart] = value;
                        }
                    }
                });
            }
            return data;
        }
    });
    return can;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#route/route*/
swifty.define('can/route',[
    'can/util/library',
    'can/map',
    'can/list',
    'can/util/string/deparam'
], function (can) {
    var matcher = /\:([\w\.]+)/g, paramsMatcher = /^(?:&[^=]+=[^&]*)+/, makeProps = function (props) {
            var tags = [];
            can.each(props, function (val, name) {
                tags.push((name === 'className' ? 'class' : name) + '="' + (name === 'href' ? val : can.esc(val)) + '"');
            });
            return tags.join(' ');
        }, matchesData = function (route, data) {
            var count = 0, i = 0, defaults = {};
            for (var name in route.defaults) {
                if (route.defaults[name] === data[name]) {
                    defaults[name] = 1;
                    count++;
                }
            }
            for (; i < route.names.length; i++) {
                if (!data.hasOwnProperty(route.names[i])) {
                    return -1;
                }
                if (!defaults[route.names[i]]) {
                    count++;
                }
            }
            return count;
        }, location = window.location, wrapQuote = function (str) {
            return (str + '').replace(/([.?*+\^$\[\]\\(){}|\-])/g, '\\$1');
        }, each = can.each, extend = can.extend, stringify = function (obj) {
            if (obj && typeof obj === 'object') {
                if (obj instanceof can.Map) {
                    obj = obj;
                } else {
                    obj = can.isFunction(obj.slice) ? obj.slice() : can.extend({}, obj);
                }
                can.each(obj, function (val, prop) {
                    obj[prop] = stringify(val);
                });
            } else if (obj !== undefined && obj !== null && can.isFunction(obj.toString)) {
                obj = obj.toString();
            }
            return obj;
        }, removeBackslash = function (str) {
            return str.replace(/\\/g, '');
        }, timer, curParams, lastHash, changingData, changedAttrs = [], onRouteDataChange = function (ev, attr, how, newval) {
            changingData = 1;
            changedAttrs.push(attr);
            clearTimeout(timer);
            timer = setTimeout(function () {
                changingData = 0;
                var serialized = can.route.data.serialize(), path = can.route.param(serialized, true);
                can.route._call('setURL', path, changedAttrs);
                can.batch.trigger(eventsObject, '__url', [
                    path,
                    lastHash
                ]);
                lastHash = path;
                changedAttrs = [];
            }, 10);
        }, eventsObject = can.extend({}, can.event), stringCoercingMapDecorator = function (map) {
            var attrSuper = map.attr;
            map.attr = function (prop, val) {
                var serializable = this.define === undefined || this.define[prop] === undefined || !!this.define[prop].serialize, args;
                if (serializable) {
                    args = stringify(Array.apply(null, arguments));
                } else {
                    args = arguments;
                }
                return attrSuper.apply(this, args);
            };
            return map;
        };
    can.route = function (url, defaults) {
        var root = can.route._call('root');
        if (root.lastIndexOf('/') === root.length - 1 && url.indexOf('/') === 0) {
            url = url.substr(1);
        }
        defaults = defaults || {};
        var names = [], res, test = '', lastIndex = matcher.lastIndex = 0, next, querySeparator = can.route._call('querySeparator'), matchSlashes = can.route._call('matchSlashes');
        while (res = matcher.exec(url)) {
            names.push(res[1]);
            test += removeBackslash(url.substring(lastIndex, matcher.lastIndex - res[0].length));
            next = '\\' + (removeBackslash(url.substr(matcher.lastIndex, 1)) || querySeparator + (matchSlashes ? '' : '|/'));
            test += '([^' + next + ']' + (defaults[res[1]] ? '*' : '+') + ')';
            lastIndex = matcher.lastIndex;
        }
        test += url.substr(lastIndex).replace('\\', '');
        can.route.routes[url] = {
            test: new RegExp('^' + test + '($|' + wrapQuote(querySeparator) + ')'),
            route: url,
            names: names,
            defaults: defaults,
            length: url.split('/').length
        };
        return can.route;
    };
    extend(can.route, {
        param: function (data, _setRoute) {
            var route, matches = 0, matchCount, routeName = data.route, propCount = 0;
            delete data.route;
            each(data, function () {
                propCount++;
            });
            each(can.route.routes, function (temp, name) {
                matchCount = matchesData(temp, data);
                if (matchCount > matches) {
                    route = temp;
                    matches = matchCount;
                }
                if (matchCount >= propCount) {
                    return false;
                }
            });
            if (can.route.routes[routeName] && matchesData(can.route.routes[routeName], data) === matches) {
                route = can.route.routes[routeName];
            }
            if (route) {
                var cpy = extend({}, data), res = route.route.replace(matcher, function (whole, name) {
                        delete cpy[name];
                        return data[name] === route.defaults[name] ? '' : encodeURIComponent(data[name]);
                    }).replace('\\', ''), after;
                each(route.defaults, function (val, name) {
                    if (cpy[name] === val) {
                        delete cpy[name];
                    }
                });
                after = can.param(cpy);
                if (_setRoute) {
                    can.route.attr('route', route.route);
                }
                return res + (after ? can.route._call('querySeparator') + after : '');
            }
            return can.isEmptyObject(data) ? '' : can.route._call('querySeparator') + can.param(data);
        },
        deparam: function (url) {
            var root = can.route._call('root');
            if (root.lastIndexOf('/') === root.length - 1 && url.indexOf('/') === 0) {
                url = url.substr(1);
            }
            var route = { length: -1 }, querySeparator = can.route._call('querySeparator'), paramsMatcher = can.route._call('paramsMatcher');
            each(can.route.routes, function (temp, name) {
                if (temp.test.test(url) && temp.length > route.length) {
                    route = temp;
                }
            });
            if (route.length > -1) {
                var parts = url.match(route.test), start = parts.shift(), remainder = url.substr(start.length - (parts[parts.length - 1] === querySeparator ? 1 : 0)), obj = remainder && paramsMatcher.test(remainder) ? can.deparam(remainder.slice(1)) : {};
                obj = extend(true, {}, route.defaults, obj);
                each(parts, function (part, i) {
                    if (part && part !== querySeparator) {
                        obj[route.names[i]] = decodeURIComponent(part);
                    }
                });
                obj.route = route.route;
                return obj;
            }
            if (url.charAt(0) !== querySeparator) {
                url = querySeparator + url;
            }
            return paramsMatcher.test(url) ? can.deparam(url.slice(1)) : {};
        },
        data: stringCoercingMapDecorator(new can.Map({})),
        map: function (data) {
            var appState;
            if (data.prototype instanceof can.Map) {
                appState = new data();
            } else {
                appState = data;
            }
            can.route.data = stringCoercingMapDecorator(appState);
        },
        routes: {},
        ready: function (val) {
            if (val !== true) {
                can.route._setup();
                if (can.isBrowserWindow || can.isWebWorker) {
                    can.route.setState();
                }
            }
            return can.route;
        },
        url: function (options, merge) {
            if (merge) {
                can.__observe(eventsObject, '__url');
                options = can.extend({}, can.route.deparam(can.route._call('matchingPartOfURL')), options);
            }
            return can.route._call('root') + can.route.param(options);
        },
        link: function (name, options, props, merge) {
            return '<a ' + makeProps(extend({ href: can.route.url(options, merge) }, props)) + '>' + name + '</a>';
        },
        current: function (options) {
            can.__observe(eventsObject, '__url');
            return this._call('matchingPartOfURL') === can.route.param(options);
        },
        bindings: {
            hashchange: {
                paramsMatcher: paramsMatcher,
                querySeparator: '&',
                matchSlashes: false,
                bind: function () {
                    can.bind.call(window, 'hashchange', setState);
                },
                unbind: function () {
                    can.unbind.call(window, 'hashchange', setState);
                },
                matchingPartOfURL: function () {
                    var loc = can.route.location || location;
                    return loc.href.split(/#!?/)[1] || '';
                },
                setURL: function (path) {
                    if (location.hash !== '#' + path) {
                        location.hash = '!' + path;
                    }
                    return path;
                },
                root: '#!'
            }
        },
        defaultBinding: 'hashchange',
        currentBinding: null,
        _setup: function () {
            if (!can.route.currentBinding) {
                can.route._call('bind');
                can.route.bind('change', onRouteDataChange);
                can.route.currentBinding = can.route.defaultBinding;
            }
        },
        _teardown: function () {
            if (can.route.currentBinding) {
                can.route._call('unbind');
                can.route.unbind('change', onRouteDataChange);
                can.route.currentBinding = null;
            }
            clearTimeout(timer);
            changingData = 0;
        },
        _call: function () {
            var args = can.makeArray(arguments), prop = args.shift(), binding = can.route.bindings[can.route.currentBinding || can.route.defaultBinding], method = binding[prop];
            if (method.apply) {
                return method.apply(binding, args);
            } else {
                return method;
            }
        }
    });
    each([
        'bind',
        'unbind',
        'on',
        'off',
        'delegate',
        'undelegate',
        'removeAttr',
        'compute',
        '_get',
        '___get',
        'each'
    ], function (name) {
        can.route[name] = function () {
            if (!can.route.data[name]) {
                return;
            }
            return can.route.data[name].apply(can.route.data, arguments);
        };
    });
    can.route.attr = function () {
        return can.route.data.attr.apply(can.route.data, arguments);
    };
    can.route.batch = can.batch;
    var setState = can.route.setState = function () {
        var hash = can.route._call('matchingPartOfURL');
        var oldParams = curParams;
        curParams = can.route.deparam(hash);
        if (!changingData || hash !== lastHash) {
            can.route.batch.start();
            recursiveClean(oldParams, curParams, can.route.data);
            can.route.attr(curParams);
            can.route.batch.trigger(eventsObject, '__url', [
                hash,
                lastHash
            ]);
            can.route.batch.stop();
        }
    };
    var recursiveClean = function (old, cur, data) {
        for (var attr in old) {
            if (cur[attr] === undefined) {
                data.removeAttr(attr);
            } else if (Object.prototype.toString.call(old[attr]) === '[object Object]') {
                recursiveClean(old[attr], cur[attr], data.attr(attr));
            }
        }
    };
    return can.route;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#control/control*/
swifty.define('can/control',[
    'can/util/library',
    'can/construct'
], function (can) {
    var bind = function (el, ev, callback) {
            can.bind.call(el, ev, callback);
            return function () {
                can.unbind.call(el, ev, callback);
            };
        }, isFunction = can.isFunction, extend = can.extend, each = can.each, slice = [].slice, paramReplacer = /\{([^\}]+)\}/g, special = can.getObject('$.event.special', [can]) || {}, delegate = function (el, selector, ev, callback) {
            can.delegate.call(el, selector, ev, callback);
            return function () {
                can.undelegate.call(el, selector, ev, callback);
            };
        }, binder = function (el, ev, callback, selector) {
            return selector ? delegate(el, can.trim(selector), ev, callback) : bind(el, ev, callback);
        }, basicProcessor;
    var Control = can.Control = can.Construct({
        setup: function () {
            can.Construct.setup.apply(this, arguments);
            if (can.Control) {
                var control = this, funcName;
                control.actions = {};
                for (funcName in control.prototype) {
                    if (control._isAction(funcName)) {
                        control.actions[funcName] = control._action(funcName);
                    }
                }
            }
        },
        _shifter: function (context, name) {
            var method = typeof name === 'string' ? context[name] : name;
            if (!isFunction(method)) {
                method = context[method];
            }
            return function () {
                context.called = name;
                return method.apply(context, [this.nodeName ? can.$(this) : this].concat(slice.call(arguments, 0)));
            };
        },
        _isAction: function (methodName) {
            var val = this.prototype[methodName], type = typeof val;
            return methodName !== 'constructor' && (type === 'function' || type === 'string' && isFunction(this.prototype[val])) && !!(special[methodName] || processors[methodName] || /[^\w]/.test(methodName));
        },
        _action: function (methodName, options) {
            paramReplacer.lastIndex = 0;
            if (options || !paramReplacer.test(methodName)) {
                var convertedName = options ? can.sub(methodName, this._lookup(options)) : methodName;
                if (!convertedName) {
                    return null;
                }
                var arr = can.isArray(convertedName), name = arr ? convertedName[1] : convertedName, parts = name.split(/\s+/g), event = parts.pop();
                return {
                    processor: processors[event] || basicProcessor,
                    parts: [
                        name,
                        parts.join(' '),
                        event
                    ],
                    delegate: arr ? convertedName[0] : undefined
                };
            }
        },
        _lookup: function (options) {
            return [
                options,
                window
            ];
        },
        processors: {},
        defaults: {}
    }, {
        setup: function (element, options) {
            var cls = this.constructor, pluginname = cls.pluginName || cls._fullName, arr;
            this.element = can.$(element);
            if (pluginname && pluginname !== 'can_control') {
                this.element.addClass(pluginname);
            }
            arr = can.data(this.element, 'controls');
            if (!arr) {
                arr = [];
                can.data(this.element, 'controls', arr);
            }
            arr.push(this);
            this.options = extend({}, cls.defaults, options);
            this.on();
            return [
                this.element,
                this.options
            ];
        },
        on: function (el, selector, eventName, func) {
            if (!el) {
                this.off();
                var cls = this.constructor, bindings = this._bindings, actions = cls.actions, element = this.element, destroyCB = can.Control._shifter(this, 'destroy'), funcName, ready;
                for (funcName in actions) {
                    if (actions.hasOwnProperty(funcName)) {
                        ready = actions[funcName] || cls._action(funcName, this.options, this);
                        if (ready) {
                            bindings.control[funcName] = ready.processor(ready.delegate || element, ready.parts[2], ready.parts[1], funcName, this);
                        }
                    }
                }
                can.bind.call(element, 'removed', destroyCB);
                bindings.user.push(function (el) {
                    can.unbind.call(el, 'removed', destroyCB);
                });
                return bindings.user.length;
            }
            if (typeof el === 'string') {
                func = eventName;
                eventName = selector;
                selector = el;
                el = this.element;
            }
            if (func === undefined) {
                func = eventName;
                eventName = selector;
                selector = null;
            }
            if (typeof func === 'string') {
                func = can.Control._shifter(this, func);
            }
            this._bindings.user.push(binder(el, eventName, func, selector));
            return this._bindings.user.length;
        },
        off: function () {
            var el = this.element[0], bindings = this._bindings;
            if (bindings) {
                each(bindings.user || [], function (value) {
                    value(el);
                });
                each(bindings.control || {}, function (value) {
                    value(el);
                });
            }
            this._bindings = {
                user: [],
                control: {}
            };
        },
        destroy: function () {
            if (this.element === null) {
                return;
            }
            var Class = this.constructor, pluginName = Class.pluginName || Class._fullName, controls;
            this.off();
            if (pluginName && pluginName !== 'can_control') {
                this.element.removeClass(pluginName);
            }
            controls = can.data(this.element, 'controls');
            controls.splice(can.inArray(this, controls), 1);
            can.trigger(this, 'destroyed');
            this.element = null;
        }
    });
    var processors = can.Control.processors;
    basicProcessor = function (el, event, selector, methodName, control) {
        return binder(el, event, can.Control._shifter(control, methodName), selector);
    };
    each([
        'change',
        'click',
        'contextmenu',
        'dblclick',
        'keydown',
        'keyup',
        'keypress',
        'mousedown',
        'mousemove',
        'mouseout',
        'mouseover',
        'mouseup',
        'reset',
        'resize',
        'scroll',
        'select',
        'submit',
        'focusin',
        'focusout',
        'mouseenter',
        'mouseleave',
        'touchstart',
        'touchmove',
        'touchcancel',
        'touchend',
        'touchleave',
        'inserted',
        'removed',
        'dragstart',
        'dragenter',
        'dragover',
        'dragleave',
        'drag',
        'drop',
        'dragend'
    ], function (v) {
        processors[v] = basicProcessor;
    });
    return Control;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#control/route/route*/
swifty.define('can/control/route',[
    'can/util/library',
    'can/route',
    'can/control'
], function (can) {
    can.Control.processors.route = function (el, event, selector, funcName, controller) {
        selector = selector || '';
        if (!can.route.routes[selector]) {
            if (selector[0] === '/') {
                selector = selector.substring(1);
            }
            can.route(selector);
        }
        var batchNum, check = function (ev, attr, how) {
                if (can.route.attr('route') === selector && (ev.batchNum === undefined || ev.batchNum !== batchNum)) {
                    batchNum = ev.batchNum;
                    var d = can.route.attr();
                    delete d.route;
                    if (can.isFunction(controller[funcName])) {
                        controller[funcName](d);
                    } else {
                        controller[controller[funcName]](d);
                    }
                }
            };
        can.route.bind('change', check);
        return function () {
            can.route.unbind('change', check);
        };
    };
    return can;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#model/model*/
swifty.define('can/model',[
    'can/util/library',
    'can/map',
    'can/list'
], function (can) {
    var pipe = function (def, thisArg, func) {
            var d = new can.Deferred();
            def.then(function () {
                var args = can.makeArray(arguments), success = true;
                try {
                    args[0] = func.apply(thisArg, args);
                } catch (e) {
                    success = false;
                    d.rejectWith(d, [e].concat(args));
                }
                if (success) {
                    d.resolveWith(d, args);
                }
            }, function () {
                d.rejectWith(this, arguments);
            });
            if (typeof def.abort === 'function') {
                d.abort = function () {
                    return def.abort();
                };
            }
            return d;
        }, modelNum = 0, getId = function (inst) {
            can.__observe(inst, inst.constructor.id);
            return inst.___get(inst.constructor.id);
        }, ajax = function (ajaxOb, data, type, dataType, success, error) {
            var params = {};
            if (typeof ajaxOb === 'string') {
                var parts = ajaxOb.split(/\s+/);
                params.url = parts.pop();
                if (parts.length) {
                    params.type = parts.pop();
                }
            } else {
                can.extend(params, ajaxOb);
            }
            params.data = typeof data === 'object' && !can.isArray(data) ? can.extend(params.data || {}, data) : data;
            params.url = can.sub(params.url, params.data, true);
            return can.ajax(can.extend({
                type: type || 'post',
                dataType: dataType || 'json',
                success: success,
                error: error
            }, params));
        }, makeRequest = function (modelObj, type, success, error, method) {
            var args;
            if (can.isArray(modelObj)) {
                args = modelObj[1];
                modelObj = modelObj[0];
            } else {
                args = modelObj.serialize();
            }
            args = [args];
            var deferred, model = modelObj.constructor, jqXHR;
            if (type === 'update' || type === 'destroy') {
                args.unshift(getId(modelObj));
            }
            jqXHR = model[type].apply(model, args);
            deferred = pipe(jqXHR, modelObj, function (data) {
                modelObj[method || type + 'd'](data, jqXHR);
                return modelObj;
            });
            if (jqXHR.abort) {
                deferred.abort = function () {
                    jqXHR.abort();
                };
            }
            deferred.then(success, error);
            return deferred;
        }, converters = {
            models: function (instancesRawData, oldList, xhr) {
                can.Model._reqs++;
                if (!instancesRawData) {
                    return;
                }
                if (instancesRawData instanceof this.List) {
                    return instancesRawData;
                }
                var self = this, tmp = [], ListClass = self.List || ML, modelList = oldList instanceof can.List ? oldList : new ListClass(), rawDataIsList = instancesRawData instanceof ML, raw = rawDataIsList ? instancesRawData.serialize() : instancesRawData;
                raw = self.parseModels(raw, xhr);
                if (raw.data) {
                    instancesRawData = raw;
                    raw = raw.data;
                }
                if (typeof raw === 'undefined' || !can.isArray(raw)) {
                    throw new Error('Could not get any raw data while converting using .models');
                }
                if (modelList.length) {
                    modelList.splice(0);
                }
                can.each(raw, function (rawPart) {
                    tmp.push(self.model(rawPart, xhr));
                });
                modelList.push.apply(modelList, tmp);
                if (!can.isArray(instancesRawData)) {
                    can.each(instancesRawData, function (val, prop) {
                        if (prop !== 'data') {
                            modelList.attr(prop, val);
                        }
                    });
                }
                setTimeout(can.proxy(this._clean, this), 1);
                return modelList;
            },
            model: function (attributes, oldModel, xhr) {
                if (!attributes) {
                    return;
                }
                if (typeof attributes.serialize === 'function') {
                    attributes = attributes.serialize();
                } else {
                    attributes = this.parseModel(attributes, xhr);
                }
                var id = attributes[this.id];
                if ((id || id === 0) && this.store[id]) {
                    oldModel = this.store[id];
                }
                var model = oldModel && can.isFunction(oldModel.attr) ? oldModel.attr(attributes, this.removeAttr || false) : new this(attributes);
                return model;
            }
        }, makeParser = {
            parseModel: function (prop) {
                return function (attributes) {
                    return prop ? can.getObject(prop, attributes) : attributes;
                };
            },
            parseModels: function (prop) {
                return function (attributes) {
                    if (can.isArray(attributes)) {
                        return attributes;
                    }
                    prop = prop || 'data';
                    var result = can.getObject(prop, attributes);
                    if (!can.isArray(result)) {
                        throw new Error('Could not get any raw data while converting using .models');
                    }
                    return result;
                };
            }
        }, ajaxMethods = {
            create: {
                url: '_shortName',
                type: 'post'
            },
            update: {
                data: function (id, attrs) {
                    attrs = attrs || {};
                    var identity = this.id;
                    if (attrs[identity] && attrs[identity] !== id) {
                        attrs['new' + can.capitalize(id)] = attrs[identity];
                        delete attrs[identity];
                    }
                    attrs[identity] = id;
                    return attrs;
                },
                type: 'put'
            },
            destroy: {
                type: 'delete',
                data: function (id, attrs) {
                    attrs = attrs || {};
                    attrs.id = attrs[this.id] = id;
                    return attrs;
                }
            },
            findAll: { url: '_shortName' },
            findOne: {}
        }, ajaxMaker = function (ajaxMethod, str) {
            return function (data) {
                data = ajaxMethod.data ? ajaxMethod.data.apply(this, arguments) : data;
                return ajax(str || this[ajaxMethod.url || '_url'], data, ajaxMethod.type || 'get');
            };
        }, createURLFromResource = function (model, name) {
            if (!model.resource) {
                return;
            }
            var resource = model.resource.replace(/\/+$/, '');
            if (name === 'findAll' || name === 'create') {
                return resource;
            } else {
                return resource + '/{' + model.id + '}';
            }
        };
    can.Model = can.Map.extend({
        fullName: 'can.Model',
        _reqs: 0,
        setup: function (base, fullName, staticProps, protoProps) {
            if (typeof fullName !== 'string') {
                protoProps = staticProps;
                staticProps = fullName;
            }
            if (!protoProps) {
                protoProps = staticProps;
            }
            this.store = {};
            can.Map.setup.apply(this, arguments);
            if (!can.Model) {
                return;
            }
            if (staticProps && staticProps.List) {
                this.List = staticProps.List;
                this.List.Map = this;
            } else {
                this.List = base.List.extend({ Map: this }, {});
            }
            var self = this, clean = can.proxy(this._clean, self);
            can.each(ajaxMethods, function (method, name) {
                if (staticProps && staticProps[name] && (typeof staticProps[name] === 'string' || typeof staticProps[name] === 'object')) {
                    self[name] = ajaxMaker(method, staticProps[name]);
                } else if (staticProps && staticProps.resource && !can.isFunction(staticProps[name])) {
                    self[name] = ajaxMaker(method, createURLFromResource(self, name));
                }
                if (self['make' + can.capitalize(name)]) {
                    var newMethod = self['make' + can.capitalize(name)](self[name]);
                    can.Construct._overwrite(self, base, name, function () {
                        can.Model._reqs++;
                        var def = newMethod.apply(this, arguments);
                        var then = def.then(clean, clean);
                        then.abort = def.abort;
                        return then;
                    });
                }
            });
            var hasCustomConverter = {};
            can.each(converters, function (converter, name) {
                var parseName = 'parse' + can.capitalize(name), dataProperty = staticProps && staticProps[name] || self[name];
                if (typeof dataProperty === 'string') {
                    self[parseName] = dataProperty;
                    can.Construct._overwrite(self, base, name, converter);
                } else if (staticProps && staticProps[name]) {
                    hasCustomConverter[parseName] = true;
                }
            });
            can.each(makeParser, function (maker, parseName) {
                var prop = staticProps && staticProps[parseName] || self[parseName];
                if (typeof prop === 'string') {
                    can.Construct._overwrite(self, base, parseName, maker(prop));
                } else if ((!staticProps || !can.isFunction(staticProps[parseName])) && !self[parseName]) {
                    var madeParser = maker();
                    madeParser.useModelConverter = hasCustomConverter[parseName];
                    can.Construct._overwrite(self, base, parseName, madeParser);
                }
            });
            if (self.fullName === 'can.Model' || !self.fullName) {
                self.fullName = 'Model' + ++modelNum;
            }
            can.Model._reqs = 0;
            this._url = this._shortName + '/{' + this.id + '}';
        },
        _ajax: ajaxMaker,
        _makeRequest: makeRequest,
        _clean: function () {
            can.Model._reqs--;
            if (!can.Model._reqs) {
                for (var id in this.store) {
                    if (!this.store[id]._bindings) {
                        delete this.store[id];
                    }
                }
            }
            return arguments[0];
        },
        models: converters.models,
        model: converters.model
    }, {
        setup: function (attrs) {
            var id = attrs && attrs[this.constructor.id];
            if (can.Model._reqs && id != null) {
                this.constructor.store[id] = this;
            }
            can.Map.prototype.setup.apply(this, arguments);
        },
        isNew: function () {
            var id = getId(this);
            return !(id || id === 0);
        },
        save: function (success, error) {
            return makeRequest(this, this.isNew() ? 'create' : 'update', success, error);
        },
        destroy: function (success, error) {
            if (this.isNew()) {
                var self = this;
                var def = can.Deferred();
                def.then(success, error);
                return def.done(function (data) {
                    self.destroyed(data);
                }).resolve(self);
            }
            return makeRequest(this, 'destroy', success, error, 'destroyed');
        },
        _bindsetup: function () {
            var modelInstance = this.___get(this.constructor.id);
            if (modelInstance != null) {
                this.constructor.store[modelInstance] = this;
            }
            return can.Map.prototype._bindsetup.apply(this, arguments);
        },
        _bindteardown: function () {
            delete this.constructor.store[getId(this)];
            return can.Map.prototype._bindteardown.apply(this, arguments);
        },
        ___set: function (prop, val) {
            can.Map.prototype.___set.call(this, prop, val);
            if (prop === this.constructor.id && this._bindings) {
                this.constructor.store[getId(this)] = this;
            }
        }
    });
    var makeGetterHandler = function (name) {
            return function (data, readyState, xhr) {
                return this[name](data, null, xhr);
            };
        }, createUpdateDestroyHandler = function (data) {
            if (this.parseModel.useModelConverter) {
                return this.model(data);
            }
            return this.parseModel(data);
        };
    var responseHandlers = {
        makeFindAll: makeGetterHandler('models'),
        makeFindOne: makeGetterHandler('model'),
        makeCreate: createUpdateDestroyHandler,
        makeUpdate: createUpdateDestroyHandler,
        makeDestroy: createUpdateDestroyHandler
    };
    can.each(responseHandlers, function (method, name) {
        can.Model[name] = function (oldMethod) {
            return function () {
                var args = can.makeArray(arguments), oldArgs = can.isFunction(args[1]) ? args.splice(0, 1) : args.splice(0, 2), def = pipe(oldMethod.apply(this, oldArgs), this, method);
                def.then(args[0], args[1]);
                return def;
            };
        };
    });
    can.each([
        'created',
        'updated',
        'destroyed'
    ], function (funcName) {
        can.Model.prototype[funcName] = function (attrs) {
            var self = this, constructor = self.constructor;
            if (attrs && typeof attrs === 'object') {
                this.attr(can.isFunction(attrs.attr) ? attrs.attr() : attrs);
            }
            can.dispatch.call(this, {
                type: funcName,
                target: this
            }, []);
            can.dispatch.call(constructor, funcName, [this]);
        };
    });
    var ML = can.Model.List = can.List.extend({
        _bubbleRule: function (eventName, list) {
            var bubbleRules = can.List._bubbleRule(eventName, list);
            bubbleRules.push('destroyed');
            return bubbleRules;
        }
    }, {
        setup: function (params) {
            if (can.isPlainObject(params) && !can.isArray(params)) {
                can.List.prototype.setup.apply(this);
                this.replace(can.isDeferred(params) ? params : this.constructor.Map.findAll(params));
            } else {
                can.List.prototype.setup.apply(this, arguments);
            }
            this.bind('destroyed', can.proxy(this._destroyed, this));
        },
        _destroyed: function (ev, attr) {
            if (/\w+/.test(attr)) {
                var index;
                while ((index = this.indexOf(ev.target)) > -1) {
                    this.splice(index, 1);
                }
            }
        }
    });
    return can.Model;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#compute/read*/
swifty.define('can/read',['can/util/library'], function (can) {
    var read = function (parent, reads, options) {
        options = options || {};
        var state = { foundObservable: false };
        var cur = readValue(parent, 0, reads, options, state), type, prev, readLength = reads.length, i = 0;
        while (i < readLength) {
            prev = cur;
            for (var r = 0, readersLength = read.propertyReaders.length; r < readersLength; r++) {
                var reader = read.propertyReaders[r];
                if (reader.test(cur)) {
                    cur = reader.read(cur, reads[i], i, options, state);
                    break;
                }
            }
            i = i + 1;
            cur = readValue(cur, i, reads, options, state, prev);
            type = typeof cur;
            if (i < reads.length && (cur === null || type !== 'function' && type !== 'object')) {
                if (options.earlyExit) {
                    options.earlyExit(prev, i - 1, cur);
                }
                return {
                    value: undefined,
                    parent: prev
                };
            }
        }
        if (cur === undefined) {
            if (options.earlyExit) {
                options.earlyExit(prev, i - 1);
            }
        }
        return {
            value: cur,
            parent: prev
        };
    };
    var isAt = function (index, reads) {
        var prevRead = reads[index - 1];
        return prevRead && prevRead.at;
    };
    var readValue = function (value, index, reads, options, state, prev) {
        var usedValueReader;
        do {
            usedValueReader = false;
            for (var i = 0, len = read.valueReaders.length; i < len; i++) {
                if (read.valueReaders[i].test(value, index, reads, options)) {
                    value = read.valueReaders[i].read(value, index, reads, options, state, prev);
                }
            }
        } while (usedValueReader);
        return value;
    };
    read.valueReaders = [
        {
            name: 'compute',
            test: function (value, i, reads, options) {
                return value && value.isComputed && !isAt(i, reads);
            },
            read: function (value, i, reads, options, state) {
                if (options.readCompute === false && i === reads.length) {
                    return value;
                }
                if (!state.foundObservable && options.foundObservable) {
                    options.foundObservable(value, i);
                    state.foundObservable = true;
                }
                return value instanceof can.Compute ? value.get() : value();
            }
        },
        {
            name: 'function',
            test: function (value, i, reads, options) {
                var type = typeof value;
                return type === 'function' && !value.isComputed && !(can.Construct && value.prototype instanceof can.Construct) && !(can.route && value === can.route);
            },
            read: function (value, i, reads, options, state, prev) {
                if (isAt(i, reads)) {
                    return i === reads.length ? can.proxy(value, prev) : value;
                } else if (options.callMethodsOnObservables && can.isMapLike(prev)) {
                    return value.apply(prev, options.args || []);
                } else if (options.isArgument && i === reads.length) {
                    return options.proxyMethods !== false ? can.proxy(value, prev) : value;
                }
                return value.apply(prev, options.args || []);
            }
        }
    ];
    read.propertyReaders = [
        {
            name: 'map',
            test: can.isMapLike,
            read: function (value, prop, index, options, state) {
                if (!state.foundObservable && options.foundObservable) {
                    options.foundObservable(value, index);
                    state.foundObservable = true;
                }
                var res = value.attr(prop.key);
                if (res !== undefined) {
                    return res;
                } else {
                    return value[prop.key];
                }
            }
        },
        {
            name: 'promise',
            test: function (value) {
                return can.isPromise(value);
            },
            read: function (value, prop, index, options, state) {
                if (!state.foundObservable && options.foundObservable) {
                    options.foundObservable(value, index);
                    state.foundObservable = true;
                }
                var observeData = value.__observeData;
                if (!value.__observeData) {
                    observeData = value.__observeData = {
                        isPending: true,
                        state: 'pending',
                        isResolved: false,
                        isRejected: false,
                        value: undefined,
                        reason: undefined
                    };
                    can.cid(observeData);
                    can.simpleExtend(observeData, can.event);
                    value.then(function (value) {
                        observeData.isPending = false;
                        observeData.isResolved = true;
                        observeData.value = value;
                        observeData.state = 'resolved';
                        observeData.dispatch('state', [
                            'resolved',
                            'pending'
                        ]);
                    }, function (reason) {
                        observeData.isPending = false;
                        observeData.isRejected = true;
                        observeData.reason = reason;
                        observeData.state = 'rejected';
                        observeData.dispatch('state', [
                            'rejected',
                            'pending'
                        ]);
                    });
                }
                can.__observe(observeData, 'state');
                return prop.key in observeData ? observeData[prop.key] : value[prop.key];
            }
        },
        {
            name: 'object',
            test: function () {
                return true;
            },
            read: function (value, prop) {
                if (value == null) {
                    return undefined;
                } else {
                    if (prop.key in value) {
                        return value[prop.key];
                    } else if (prop.at && specialRead[prop.key] && '@' + prop.key in value) {
                        prop.at = false;
                        return value['@' + prop.key];
                    }
                }
            }
        }
    ];
    var specialRead = {
        index: true,
        key: true,
        event: true,
        element: true,
        viewModel: true
    };
    read.write = function (parent, key, value, options) {
        options = options || {};
        if (can.isMapLike(parent)) {
            if (!options.isArgument && parent._data && parent._data[key] && parent._data[key].isComputed) {
                return parent._data[key](value);
            } else {
                return parent.attr(key, value);
            }
        }
        if (parent[key] && parent[key].isComputed) {
            return parent[key](value);
        }
        if (typeof parent === 'object') {
            parent[key] = value;
        }
    };
    read.reads = function (key) {
        var keys = [];
        var last = 0;
        var at = false;
        if (key.charAt(0) === '@') {
            last = 1;
            at = true;
        }
        var keyToAdd = '';
        for (var i = last; i < key.length; i++) {
            var character = key.charAt(i);
            if (character === '.' || character === '@') {
                if (key.charAt(i - 1) !== '\\') {
                    keys.push({
                        key: keyToAdd,
                        at: at
                    });
                    at = character === '@';
                    keyToAdd = '';
                } else {
                    keyToAdd = keyToAdd.substr(0, keyToAdd.length - 1) + '.';
                }
            } else {
                keyToAdd += character;
            }
        }
        keys.push({
            key: keyToAdd,
            at: at
        });
        return keys;
    };
    return read;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#compute/proto_compute*/
swifty.define('can/proto_compute',[
    'can/util/library',
    'can/util/bind',
    'can/read',
    'can/get_value_and_bind',
    'can/util/batch'
], function (can, bind, read, ObservedInfo) {
    can.Compute = function (getterSetter, context, eventName, bindOnce) {
        can.cid(this, 'compute');
        var args = [];
        for (var i = 0, arglen = arguments.length; i < arglen; i++) {
            args[i] = arguments[i];
        }
        var contextType = typeof args[1];
        if (typeof args[0] === 'function') {
            this._setupGetterSetterFn(args[0], args[1], args[2], args[3]);
        } else if (args[1]) {
            if (contextType === 'string') {
                this._setupProperty(args[0], args[1], args[2]);
            } else if (contextType === 'function') {
                this._setupSetter(args[0], args[1], args[2]);
            } else {
                if (args[1] && args[1].fn) {
                    this._setupAsyncCompute(args[0], args[1]);
                } else {
                    this._setupSettings(args[0], args[1]);
                }
            }
        } else {
            this._setupSimpleValue(args[0]);
        }
        this._args = args;
        this._primaryDepth = 0;
        this.isComputed = true;
    };
    can.simpleExtend(can.Compute.prototype, {
        setPrimaryDepth: function (depth) {
            this._primaryDepth = depth;
        },
        _setupGetterSetterFn: function (getterSetter, context, eventName) {
            this._set = context ? can.proxy(getterSetter, context) : getterSetter;
            this._get = context ? can.proxy(getterSetter, context) : getterSetter;
            this._canObserve = eventName === false ? false : true;
            var handlers = setupComputeHandlers(this, getterSetter, context || this);
            can.simpleExtend(this, handlers);
        },
        _setupProperty: function (target, propertyName, eventName) {
            var isObserve = can.isMapLike(target), self = this, handler;
            if (isObserve) {
                handler = function (ev, newVal, oldVal) {
                    self.updater(newVal, oldVal, ev.batchNum);
                };
                this.hasDependencies = true;
                this._get = function () {
                    return target.attr(propertyName);
                };
                this._set = function (val) {
                    target.attr(propertyName, val);
                };
            } else {
                handler = function () {
                    self.updater(self._get(), self.value);
                };
                this._get = function () {
                    return can.getObject(propertyName, [target]);
                };
                this._set = function (value) {
                    var properties = propertyName.split('.'), leafPropertyName = properties.pop(), targetProperty = can.getObject(properties.join('.'), [target]);
                    targetProperty[leafPropertyName] = value;
                };
            }
            this._on = function (update) {
                can.bind.call(target, eventName || propertyName, handler);
                this.value = this._get();
            };
            this._off = function () {
                return can.unbind.call(target, eventName || propertyName, handler);
            };
        },
        _setupSetter: function (initialValue, setter, eventName) {
            this.value = initialValue;
            this._set = setter;
            can.simpleExtend(this, eventName);
        },
        _setupSettings: function (initialValue, settings) {
            this.value = initialValue;
            this._set = settings.set || this._set;
            this._get = settings.get || this._get;
            if (!settings.__selfUpdater) {
                var self = this, oldUpdater = this.updater;
                this.updater = function () {
                    oldUpdater.call(self, self._get(), self.value);
                };
            }
            this._on = settings.on ? settings.on : this._on;
            this._off = settings.off ? settings.off : this._off;
        },
        _setupAsyncCompute: function (initialValue, settings) {
            var self = this;
            this.value = initialValue;
            this._setUpdates = true;
            this.lastSetValue = new can.Compute(initialValue);
            this._set = function (newVal) {
                if (newVal === self.lastSetValue.get()) {
                    return this.value;
                }
                return self.lastSetValue.set(newVal);
            };
            this._get = function () {
                return getter.call(settings.context, self.lastSetValue.get());
            };
            var getter = settings.fn, bindings;
            if (getter.length === 0) {
                bindings = setupComputeHandlers(this, getter, settings.context);
            } else if (getter.length === 1) {
                bindings = setupComputeHandlers(this, function () {
                    return getter.call(settings.context, self.lastSetValue.get());
                }, settings);
            } else {
                var oldUpdater = this.updater, setValue = function (newVal) {
                        oldUpdater.call(self, newVal, self.value);
                    };
                this.updater = function (newVal) {
                    oldUpdater.call(self, newVal, self.value);
                };
                bindings = setupComputeHandlers(this, function () {
                    var res = getter.call(settings.context, self.lastSetValue.get(), setValue);
                    return res !== undefined ? res : this.value;
                }, this);
            }
            can.simpleExtend(this, bindings);
        },
        _setupSimpleValue: function (initialValue) {
            this.value = initialValue;
        },
        _bindsetup: can.__notObserve(function () {
            this.bound = true;
            this._on(this.updater);
        }),
        _bindteardown: function () {
            this._off(this.updater);
            this.bound = false;
        },
        bind: can.bindAndSetup,
        unbind: can.unbindAndTeardown,
        clone: function (context) {
            if (context && typeof this._args[0] === 'function') {
                this._args[1] = context;
            } else if (context) {
                this._args[2] = context;
            }
            return new can.Compute(this._args[0], this._args[1], this._args[2], this._args[3]);
        },
        _on: can.k,
        _off: can.k,
        get: function () {
            if (can.__isRecordingObserves() && this._canObserve !== false) {
                can.__observe(this, 'change');
                if (!this.bound) {
                    can.Compute.temporarilyBind(this);
                }
            }
            if (this.bound) {
                return this.value;
            } else {
                return this._get();
            }
        },
        _get: function () {
            return this.value;
        },
        set: function (newVal) {
            var old = this.value;
            var setVal = this._set(newVal, old);
            if (this._setUpdates) {
                return this.value;
            }
            if (this.hasDependencies) {
                return this._get();
            }
            if (setVal === undefined) {
                this.value = this._get();
            } else {
                this.value = setVal;
            }
            updateOnChange(this, this.value, old);
            return this.value;
        },
        _set: function (newVal) {
            return this.value = newVal;
        },
        updater: function (newVal, oldVal, batchNum) {
            this.value = newVal;
            updateOnChange(this, newVal, oldVal, batchNum);
        },
        toFunction: function () {
            return can.proxy(this._computeFn, this);
        },
        _computeFn: function (newVal) {
            if (arguments.length) {
                return this.set(newVal);
            }
            return this.get();
        }
    });
    var updateOnChange = function (compute, newValue, oldValue, batchNum) {
        var valueChanged = newValue !== oldValue && !(newValue !== newValue && oldValue !== oldValue);
        if (valueChanged) {
            can.batch.trigger(compute, {
                type: 'change',
                batchNum: batchNum
            }, [
                newValue,
                oldValue
            ]);
        }
    };
    var setupComputeHandlers = function (compute, func, context) {
        var readInfo = new ObservedInfo(func, context, compute);
        return {
            _on: function () {
                readInfo.getValueAndBind();
                compute.value = readInfo.value;
                compute.hasDependencies = !can.isEmptyObject(readInfo.newObserved);
            },
            _off: function () {
                readInfo.teardown();
            },
            getDepth: function () {
                return readInfo.getDepth();
            }
        };
    };
    can.Compute.temporarilyBind = function (compute) {
        var computeInstance = compute.computeInstance || compute;
        computeInstance.bind('change', can.k);
        if (!computes) {
            computes = [];
            setTimeout(unbindComputes, 10);
        }
        computes.push(computeInstance);
    };
    var computes, unbindComputes = function () {
            for (var i = 0, len = computes.length; i < len; i++) {
                computes[i].unbind('change', can.k);
            }
            computes = null;
        };
    can.Compute.async = function (initialValue, asyncComputer, context) {
        return new can.Compute(initialValue, {
            fn: asyncComputer,
            context: context
        });
    };
    can.Compute.truthy = function (compute) {
        return new can.Compute(function () {
            var res = compute.get();
            if (typeof res === 'function') {
                res = res.get();
            }
            return !!res;
        });
    };
    can.Compute.read = read;
    can.Compute.set = read.write;
    return can.Compute;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#compute/compute*/
swifty.define('can/compute',[
    'can/util/library',
    'can/util/bind',
    'can/util/batch',
    'can/proto_compute'
], function (can, bind) {
    can.compute = function (getterSetter, context, eventName, bindOnce) {
        var internalCompute = new can.Compute(getterSetter, context, eventName, bindOnce);
        var bind = internalCompute.bind;
        var unbind = internalCompute.unbind;
        var compute = function (val) {
            if (arguments.length) {
                return internalCompute.set(val);
            }
            return internalCompute.get();
        };
        var cid = can.cid(compute, 'compute');
        var handlerKey = '__handler' + cid;
        compute.bind = function (ev, handler) {
            var computeHandler = handler && handler[handlerKey];
            if (handler && !computeHandler) {
                computeHandler = handler[handlerKey] = function () {
                    handler.apply(compute, arguments);
                };
            }
            return bind.call(internalCompute, ev, computeHandler);
        };
        compute.unbind = function (ev, handler) {
            var computeHandler = handler && handler[handlerKey];
            if (computeHandler) {
                delete handler[handlerKey];
                return internalCompute.unbind(ev, computeHandler);
            }
            return unbind.apply(internalCompute, arguments);
        };
        compute.isComputed = internalCompute.isComputed;
        compute.clone = function (ctx) {
            if (typeof getterSetter === 'function') {
                context = ctx;
            }
            return can.compute(getterSetter, context, ctx, bindOnce);
        };
        compute.computeInstance = internalCompute;
        return compute;
    };
    can.compute.truthy = function (compute) {
        return can.compute(function () {
            var res = compute();
            if (typeof res === 'function') {
                res = res();
            }
            return !!res;
        });
    };
    can.compute.async = function (initialValue, asyncComputer, context) {
        return can.compute(initialValue, {
            fn: asyncComputer,
            context: context
        });
    };
    can.compute.read = can.Compute.read;
    can.compute.set = can.Compute.set;
    can.compute.temporarilyBind = can.Compute.temporarilyBind;
    return can.compute;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#map/define/define*/
swifty.define('can/map/define',[
    'can/util/library',
    'can/map_helpers',
    'can/map',
    'can/compute'
], function (can, mapHelpers) {
    if (can.define) {
        return;
    }
    var define = can.define = {};
    var getPropDefineBehavior = function (behavior, attr, define) {
        var prop, defaultProp;
        if (define) {
            prop = define[attr];
            defaultProp = define['*'];
            if (prop && prop[behavior] !== undefined) {
                return prop[behavior];
            } else if (defaultProp && defaultProp[behavior] !== undefined) {
                return defaultProp[behavior];
            }
        }
    };
    mapHelpers.define = function (Map) {
        var definitions = Map.prototype.define;
        Map.defaultGenerators = {};
        for (var prop in definitions) {
            var type = definitions[prop].type;
            if (typeof type === 'string') {
                if (typeof define.types[type] === 'object') {
                    delete definitions[prop].type;
                    can.extend(definitions[prop], define.types[type]);
                }
            }
            if ('value' in definitions[prop]) {
                if (typeof definitions[prop].value === 'function') {
                    Map.defaultGenerators[prop] = definitions[prop].value;
                } else {
                    Map.defaults[prop] = definitions[prop].value;
                }
            }
            if (typeof definitions[prop].Value === 'function') {
                (function (Constructor) {
                    Map.defaultGenerators[prop] = function () {
                        return new Constructor();
                    };
                }(definitions[prop].Value));
            }
        }
    };
    var oldSetupDefaults = can.Map.prototype._setupDefaults;
    can.Map.prototype._setupDefaults = function (obj) {
        var defaults = oldSetupDefaults.call(this), propsCommittedToAttr = {}, Map = this.constructor, originalGet = this._get;
        this._get = function (originalProp) {
            var prop = originalProp.indexOf('.') !== -1 ? originalProp.substr(0, originalProp.indexOf('.')) : originalProp;
            if (prop in defaults && !(prop in propsCommittedToAttr)) {
                this.attr(prop, defaults[prop]);
                propsCommittedToAttr[prop] = true;
            }
            return originalGet.apply(this, arguments);
        };
        for (var prop in Map.defaultGenerators) {
            if (!obj || !(prop in obj)) {
                defaults[prop] = Map.defaultGenerators[prop].call(this);
            }
        }
        delete this._get;
        return defaults;
    };
    var proto = can.Map.prototype, oldSet = proto.__set;
    proto.__set = function (prop, value, current, success, error) {
        var errorCallback = function (errors) {
                var stub = error && error.call(self, errors);
                if (stub !== false) {
                    can.trigger(self, 'error', [
                        prop,
                        errors
                    ], true);
                }
                return false;
            }, self = this, setter = getPropDefineBehavior('set', prop, this.define), getter = getPropDefineBehavior('get', prop, this.define);
        if (setter) {
            can.batch.start();
            var setterCalled = false, setValue = setter.call(this, value, function (value) {
                    if (getter) {
                        self[prop](value);
                    } else {
                        oldSet.call(self, prop, value, current, success, errorCallback);
                    }
                    setterCalled = true;
                }, errorCallback, getter ? this._computedAttrs[prop].compute.computeInstance.lastSetValue.get() : current);
            if (getter) {
                if (setValue !== undefined && !setterCalled && setter.length >= 1) {
                    this._computedAttrs[prop].compute(setValue);
                }
                can.batch.stop();
                return;
            } else if (setValue === undefined && !setterCalled && setter.length >= 1) {
                can.batch.stop();
                return;
            } else {
                if (!setterCalled) {
                    oldSet.call(self, prop, setter.length === 0 && setValue === undefined ? value : setValue, current, success, errorCallback);
                }
                can.batch.stop();
                return this;
            }
        } else {
            oldSet.call(self, prop, value, current, success, errorCallback);
        }
        return this;
    };
    define.types = {
        'date': function (str) {
            var type = typeof str;
            if (type === 'string') {
                str = Date.parse(str);
                return isNaN(str) ? null : new Date(str);
            } else if (type === 'number') {
                return new Date(str);
            } else {
                return str;
            }
        },
        'number': function (val) {
            if (val == null) {
                return val;
            }
            return +val;
        },
        'boolean': function (val) {
            if (val === 'false' || val === '0' || !val) {
                return false;
            }
            return true;
        },
        'htmlbool': function (val) {
            return typeof val === 'string' || !!val;
        },
        '*': function (val) {
            return val;
        },
        'string': function (val) {
            if (val == null) {
                return val;
            }
            return '' + val;
        },
        'compute': {
            set: function (newValue, setVal, setErr, oldValue) {
                if (newValue.isComputed) {
                    return newValue;
                }
                if (oldValue && oldValue.isComputed) {
                    oldValue(newValue);
                    return oldValue;
                }
                return newValue;
            },
            get: function (value) {
                return value && value.isComputed ? value() : value;
            }
        }
    };
    var oldType = proto.__type;
    proto.__type = function (value, prop) {
        var type = getPropDefineBehavior('type', prop, this.define), Type = getPropDefineBehavior('Type', prop, this.define), newValue = value;
        if (typeof type === 'string') {
            type = define.types[type];
        }
        if (type || Type) {
            if (type) {
                newValue = type.call(this, newValue, prop);
            }
            if (Type && !(newValue instanceof Type)) {
                newValue = new Type(newValue);
            }
            return newValue;
        } else if (can.isPlainObject(newValue) && newValue.define) {
            newValue = can.Map.extend(newValue);
            newValue = new newValue();
        }
        return oldType.call(this, newValue, prop);
    };
    var oldRemove = proto.__remove;
    proto.__remove = function (prop, current) {
        var remove = getPropDefineBehavior('remove', prop, this.define), res;
        if (remove) {
            can.batch.start();
            res = remove.call(this, current);
            if (res === false) {
                can.batch.stop();
                return;
            } else {
                res = oldRemove.call(this, prop, current);
                can.batch.stop();
                return res;
            }
        }
        return oldRemove.call(this, prop, current);
    };
    var oldSetupComputes = proto._setupComputedProperties;
    proto._setupComputedProperties = function () {
        oldSetupComputes.apply(this, arguments);
        for (var attr in this.define) {
            var def = this.define[attr], get = def.get;
            if (get) {
                mapHelpers.addComputedAttr(this, attr, can.compute.async(undefined, get, this));
            }
        }
    };
    var oldSingleSerialize = proto.___serialize;
    proto.___serialize = function (name, val) {
        return serializeProp(this, name, val);
    };
    var serializeProp = function (map, attr, val) {
        var serializer = attr === '*' ? false : getPropDefineBehavior('serialize', attr, map.define);
        if (serializer === undefined) {
            return oldSingleSerialize.call(map, attr, val);
        } else if (serializer !== false) {
            return typeof serializer === 'function' ? serializer.call(map, val, attr) : oldSingleSerialize.call(map, attr, val);
        }
    };
    var oldSerialize = proto.serialize;
    proto.serialize = function (property) {
        var serialized = oldSerialize.apply(this, arguments);
        if (property) {
            return serialized;
        }
        var serializer, val;
        for (var attr in this.define) {
            if (!(attr in serialized)) {
                serializer = this.define && this.define[attr] && this.define[attr].serialize;
                if (serializer) {
                    val = serializeProp(this, attr, this.attr(attr));
                    if (val !== undefined) {
                        serialized[attr] = val;
                    }
                }
            }
        }
        return serialized;
    };
    return can.define;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#view/scope/compute_data*/
swifty.define('can/view/compute_data',[
    'can/util/library',
    'can/compute',
    'can/get_value_and_bind'
], function (can, compute, ObservedInfo) {
    var isFastPath = function (computeData) {
        return computeData.reads && computeData.reads.length === 1 && computeData.root instanceof can.Map && !can.isFunction(computeData.root[computeData.reads[0].key]);
    };
    var scopeReader = function (scope, key, options, computeData, newVal) {
        if (arguments.length > 4) {
            var root = computeData.root || computeData.setRoot;
            if (root) {
                if (root.isComputed) {
                    root(newVal);
                } else if (computeData.reads.length) {
                    var last = computeData.reads.length - 1;
                    var obj = computeData.reads.length ? can.compute.read(root, computeData.reads.slice(0, last)).value : root;
                    can.compute.set(obj, computeData.reads[last].key, newVal, options);
                }
            } else {
            }
        } else {
            if (computeData.root) {
                return can.compute.read(computeData.root, computeData.reads, options).value;
            }
            var data = scope.read(key, options);
            computeData.scope = data.scope;
            computeData.initialValue = data.value;
            computeData.reads = data.reads;
            computeData.root = data.rootObserve;
            computeData.setRoot = data.setRoot;
            return data.value;
        }
    };
    return function (scope, key, options) {
        options = options || { args: [] };
        var computeData = {}, scopeRead = function (newVal) {
                if (arguments.length) {
                    return scopeReader(scope, key, options, computeData, newVal);
                } else {
                    return scopeReader(scope, key, options, computeData);
                }
            }, compute = can.compute(undefined, {
                on: function () {
                    readInfo.getValueAndBind();
                    if (isFastPath(computeData)) {
                        readInfo.dependencyChange = function (ev, newVal) {
                            if (typeof newVal !== 'function') {
                                this.newVal = newVal;
                            } else {
                                readInfo.dependencyChange = ObservedInfo.prototype.dependencyChange;
                                readInfo.getValueAndBind = ObservedInfo.prototype.getValueAndBind;
                            }
                            return ObservedInfo.prototype.dependencyChange.call(this, ev);
                        };
                        readInfo.getValueAndBind = function () {
                            this.value = this.newVal;
                        };
                    }
                    compute.computeInstance.value = readInfo.value;
                    compute.computeInstance.hasDependencies = !can.isEmptyObject(readInfo.newObserved);
                },
                off: function () {
                    readInfo.dependencyChange = ObservedInfo.prototype.dependencyChange;
                    readInfo.getValueAndBind = ObservedInfo.prototype.getValueAndBind;
                    readInfo.teardown();
                },
                set: scopeRead,
                get: scopeRead,
                __selfUpdater: true
            }), readInfo = new ObservedInfo(scopeRead, null, compute.computeInstance);
        computeData.compute = compute;
        return computeData;
    };
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#view/view*/
swifty.define('can/view',['can/util/library'], function (can) {
    var isFunction = can.isFunction, makeArray = can.makeArray, hookupId = 1;
    var makeRenderer = function (textRenderer) {
        var renderer = function () {
            return $view.frag(textRenderer.apply(this, arguments));
        };
        renderer.render = function () {
            return textRenderer.apply(textRenderer, arguments);
        };
        return renderer;
    };
    var checkText = function (text, url) {
        if (!text.length) {
            throw new Error('can.view: No template or empty template:' + url);
        }
    };
    var getRenderer = function (obj, async) {
        if (isFunction(obj)) {
            var def = can.Deferred();
            return def.resolve(obj);
        }
        var url = typeof obj === 'string' ? obj : obj.url, suffix = obj.engine && '.' + obj.engine || url.match(/\.[\w\d]+$/), type, el, id;
        if (url.match(/^#/)) {
            url = url.substr(1);
        }
        if (el = document.getElementById(url)) {
            suffix = '.' + el.type.match(/\/(x\-)?(.+)/)[2];
        }
        if (!suffix && !$view.cached[url]) {
            url += suffix = $view.ext;
        }
        if (can.isArray(suffix)) {
            suffix = suffix[0];
        }
        id = $view.toId(url);
        if (url.match(/^\/\//)) {
            url = url.substr(2);
            url = !window.steal ? url : steal.config().root.mapJoin('' + steal.id(url));
        }
        if (window.require) {
            if (require.toUrl) {
                url = require.toUrl(url);
            }
        }
        type = $view.types[suffix];
        if ($view.cached[id]) {
            return $view.cached[id];
        } else if (el) {
            return $view.registerView(id, el.innerHTML, type);
        } else {
            var d = new can.Deferred();
            can.ajax({
                async: async,
                url: url,
                dataType: 'text',
                error: function (jqXHR) {
                    checkText('', url);
                    d.reject(jqXHR);
                },
                success: function (text) {
                    checkText(text, url);
                    $view.registerView(id, text, type, d);
                }
            });
            return d;
        }
    };
    var getDeferreds = function (data) {
        var deferreds = [];
        if (can.isDeferred(data)) {
            return [data];
        } else {
            for (var prop in data) {
                if (can.isDeferred(data[prop])) {
                    deferreds.push(data[prop]);
                }
            }
        }
        return deferreds;
    };
    var usefulPart = function (resolved) {
        return can.isArray(resolved) && resolved[1] === 'success' ? resolved[0] : resolved;
    };
    var $view = can.view = can.template = function (view, data, helpers, callback) {
        if (isFunction(helpers)) {
            callback = helpers;
            helpers = undefined;
        }
        return $view.renderAs('fragment', view, data, helpers, callback);
    };
    can.extend($view, {
        frag: function (result, parentNode) {
            return $view.hookup($view.fragment(result), parentNode);
        },
        fragment: function (result) {
            return can.frag(result, document);
        },
        toId: function (src) {
            return can.map(src.toString().split(/\/|\./g), function (part) {
                if (part) {
                    return part;
                }
            }).join('_');
        },
        toStr: function (txt) {
            return txt == null ? '' : '' + txt;
        },
        hookup: function (fragment, parentNode) {
            var hookupEls = [], id, func;
            can.each(fragment.childNodes ? can.makeArray(fragment.childNodes) : fragment, function (node) {
                if (node.nodeType === 1) {
                    hookupEls.push(node);
                    hookupEls.push.apply(hookupEls, can.makeArray(node.getElementsByTagName('*')));
                }
            });
            can.each(hookupEls, function (el) {
                if (el.getAttribute && (id = el.getAttribute('data-view-id')) && (func = $view.hookups[id])) {
                    func(el, parentNode, id);
                    delete $view.hookups[id];
                    el.removeAttribute('data-view-id');
                }
            });
            return fragment;
        },
        hookups: {},
        hook: function (cb) {
            $view.hookups[++hookupId] = cb;
            return ' data-view-id=\'' + hookupId + '\'';
        },
        cached: {},
        cachedRenderers: {},
        cache: true,
        register: function (info) {
            this.types['.' + info.suffix] = info;
            can[info.suffix] = $view[info.suffix] = function (id, text) {
                var renderer, renderFunc;
                if (!text) {
                    renderFunc = function () {
                        if (!renderer) {
                            if (info.fragRenderer) {
                                renderer = info.fragRenderer(null, id);
                            } else {
                                renderer = makeRenderer(info.renderer(null, id));
                            }
                        }
                        return renderer.apply(this, arguments);
                    };
                    renderFunc.render = function () {
                        var textRenderer = info.renderer(null, id);
                        return textRenderer.apply(textRenderer, arguments);
                    };
                    return renderFunc;
                }
                var registeredRenderer = function () {
                    if (!renderer) {
                        if (info.fragRenderer) {
                            renderer = info.fragRenderer(id, text);
                        } else {
                            renderer = info.renderer(id, text);
                        }
                    }
                    return renderer.apply(this, arguments);
                };
                if (info.fragRenderer) {
                    return $view.preload(id, registeredRenderer);
                } else {
                    return $view.preloadStringRenderer(id, registeredRenderer);
                }
            };
        },
        types: {},
        ext: '.ejs',
        registerScript: function (type, id, src) {
            return 'can.view.preloadStringRenderer(\'' + id + '\',' + $view.types['.' + type].script(id, src) + ');';
        },
        preload: function (id, renderer) {
            var def = $view.cached[id] = new can.Deferred().resolve(function (data, helpers) {
                return renderer.call(data, data, helpers);
            });
            def.__view_id = id;
            $view.cachedRenderers[id] = renderer;
            return renderer;
        },
        preloadStringRenderer: function (id, stringRenderer) {
            return this.preload(id, makeRenderer(stringRenderer));
        },
        render: function (view, data, helpers, callback, nodelist) {
            return can.view.renderAs('string', view, data, helpers, callback, nodelist);
        },
        renderTo: function (format, renderer, data, helpers, nodelist) {
            return (format === 'string' && renderer.render ? renderer.render : renderer)(data, helpers, nodelist);
        },
        renderAs: function (format, view, data, helpers, callback, nodelist) {
            if (callback !== undefined && typeof callback.expression === 'string') {
                nodelist = callback;
                callback = undefined;
            }
            if (isFunction(helpers)) {
                callback = helpers;
                helpers = undefined;
            }
            var deferreds = getDeferreds(data);
            var deferred, dataCopy, async, response;
            if (deferreds.length) {
                deferred = new can.Deferred();
                dataCopy = can.extend({}, data);
                deferreds.push(getRenderer(view, true));
                can.when.apply(can, deferreds).then(function (resolved) {
                    var objs = makeArray(arguments), renderer = objs.pop(), result;
                    if (can.isDeferred(data)) {
                        dataCopy = usefulPart(resolved);
                    } else {
                        for (var prop in data) {
                            if (can.isDeferred(data[prop])) {
                                dataCopy[prop] = usefulPart(objs.shift());
                            }
                        }
                    }
                    result = can.view.renderTo(format, renderer, dataCopy, helpers, nodelist);
                    deferred.resolve(result, dataCopy);
                    if (callback) {
                        callback(result, dataCopy);
                    }
                }, function () {
                    deferred.reject.apply(deferred, arguments);
                });
                return deferred;
            } else {
                async = isFunction(callback);
                deferred = can.__notObserve(getRenderer)(view, async);
                if (async) {
                    response = deferred;
                    deferred.then(function (renderer) {
                        callback(data ? can.view.renderTo(format, renderer, data, helpers, nodelist) : renderer);
                    });
                } else {
                    if (deferred.state() === 'resolved' && deferred.__view_id) {
                        var currentRenderer = $view.cachedRenderers[deferred.__view_id];
                        return data ? can.view.renderTo(format, currentRenderer, data, helpers, nodelist) : currentRenderer;
                    } else {
                        deferred.then(function (renderer) {
                            response = data ? can.view.renderTo(format, renderer, data, helpers, nodelist) : renderer;
                        });
                    }
                }
                return response;
            }
        },
        registerView: function (id, text, type, def) {
            var info = typeof type === 'object' ? type : $view.types[type || $view.ext], renderer;
            if (info.fragRenderer) {
                renderer = info.fragRenderer(id, text);
            } else {
                renderer = makeRenderer(info.renderer(id, text));
            }
            def = def || new can.Deferred();
            if ($view.cache) {
                $view.cached[id] = def;
                def.__view_id = id;
                $view.cachedRenderers[id] = renderer;
            }
            return def.resolve(renderer);
        },
        simpleHelper: function (fn) {
            return function () {
                var realArgs = [];
                can.each(arguments, function (val, i) {
                    if (i <= arguments.length) {
                        while (val && val.isComputed) {
                            val = val();
                        }
                        realArgs.push(val);
                    }
                });
                return fn.apply(this, realArgs);
            };
        }
    });
    return can;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#view/scope/scope*/
swifty.define('can/view/scope',[
    'can/util/library',
    'can/view/compute_data',
    'can/construct',
    'can/map',
    'can/list',
    'can/view',
    'can/compute'
], function (can, makeComputeData) {
    function Scope(context, parent, meta) {
        this._context = context;
        this._parent = parent;
        this._meta = meta || {};
        this.__cache = {};
    }
    can.simpleExtend(Scope, {
        read: can.compute.read,
        Refs: can.Map.extend({ shortName: 'ReferenceMap' }, {}),
        refsScope: function () {
            return new can.view.Scope(new this.Refs());
        }
    });
    can.simpleExtend(Scope.prototype, {
        add: function (context, meta) {
            if (context !== this._context) {
                return new this.constructor(context, this, meta);
            } else {
                return this;
            }
        },
        read: function (attr, options) {
            if (attr === '%root') {
                return { value: this.getRoot() };
            }
            var isInCurrentContext = attr.substr(0, 2) === './', isInParentContext = attr.substr(0, 3) === '../', isCurrentContext = attr === '.' || attr === 'this', isParentContext = attr === '..', isContextBased = isInCurrentContext || isInParentContext || isCurrentContext || isParentContext;
            if (isContextBased && this._meta.notContext) {
                return this._parent.read(attr, options);
            }
            var currentScopeOnly;
            if (isInCurrentContext) {
                currentScopeOnly = true;
                attr = attr.substr(2);
            } else if (isInParentContext) {
                var parent = this._parent;
                while (parent._meta.notContext) {
                    parent = parent._parent;
                }
                return parent.read(attr.substr(3) || '.', options);
            } else if (isCurrentContext) {
                return { value: this._context };
            } else if (isParentContext) {
                return { value: this._parent._context };
            }
            var keyReads = can.compute.read.reads(attr);
            if (keyReads[0].key.charAt(0) === '*') {
                return this.getRefs()._read(keyReads, options, true);
            } else {
                return this._read(keyReads, options, currentScopeOnly);
            }
        },
        _read: function (keyReads, options, currentScopeOnly) {
            var currentScope = this, currentContext, undefinedObserves = [], currentObserve, currentReads, setObserveDepth = -1, currentSetReads, currentSetObserve, readOptions = can.simpleExtend({
                    foundObservable: function (observe, nameIndex) {
                        currentObserve = observe;
                        currentReads = keyReads.slice(nameIndex);
                    },
                    earlyExit: function (parentValue, nameIndex) {
                        if (nameIndex > setObserveDepth) {
                            currentSetObserve = currentObserve;
                            currentSetReads = currentReads;
                            setObserveDepth = nameIndex;
                        }
                    }
                }, options);
            while (currentScope) {
                currentContext = currentScope._context;
                if (currentContext !== null && (typeof currentContext === 'object' || typeof currentContext === 'function')) {
                    var getObserves = can.__trapObserves();
                    var data = can.compute.read(currentContext, keyReads, readOptions);
                    var observes = getObserves();
                    if (data.value !== undefined) {
                        can.__observes(observes);
                        return {
                            scope: currentScope,
                            rootObserve: currentObserve,
                            value: data.value,
                            reads: currentReads
                        };
                    } else {
                        undefinedObserves.push.apply(undefinedObserves, observes);
                    }
                }
                if (currentScopeOnly) {
                    currentScope = null;
                } else {
                    currentScope = currentScope._parent;
                }
            }
            can.__observes(undefinedObserves);
            return {
                setRoot: currentSetObserve,
                reads: currentSetReads,
                value: undefined
            };
        },
        get: can.__notObserve(function (key, options) {
            options = can.simpleExtend({ isArgument: true }, options);
            var res = this.read(key, options);
            return res.value;
        }),
        getScope: function (tester) {
            var scope = this;
            while (scope) {
                if (tester(scope)) {
                    return scope;
                }
                scope = scope._parent;
            }
        },
        getContext: function (tester) {
            var res = this.getScope(tester);
            return res && res._context;
        },
        getRefs: function () {
            return this.getScope(function (scope) {
                return scope._context instanceof Scope.Refs;
            });
        },
        getRoot: function () {
            var cur = this, child = this;
            while (cur._parent) {
                child = cur;
                cur = cur._parent;
            }
            if (cur._context instanceof Scope.Refs) {
                cur = child;
            }
            return cur._context;
        },
        set: function (key, value, options) {
            var dotIndex = key.lastIndexOf('.'), slashIndex = key.lastIndexOf('/'), contextPath, propName;
            if (slashIndex > dotIndex) {
                contextPath = key.substring(0, slashIndex);
                propName = key.substring(slashIndex + 1, key.length);
            } else {
                if (dotIndex !== -1) {
                    contextPath = key.substring(0, dotIndex);
                    propName = key.substring(dotIndex + 1, key.length);
                } else {
                    contextPath = '.';
                    propName = key;
                }
            }
            if (key.charAt(0) === '*') {
                can.compute.set(this.getRefs()._context, key, value, options);
            } else {
                var context = this.read(contextPath, options).value;
                can.compute.set(context, propName, value, options);
            }
        },
        attr: can.__notObserve(function (key, value, options) {
            options = can.simpleExtend({ isArgument: true }, options);
            if (arguments.length === 2) {
                return this.set(key, value, options);
            } else {
                return this.get(key, options);
            }
        }),
        computeData: function (key, options) {
            return makeComputeData(this, key, options);
        },
        compute: function (key, options) {
            return this.computeData(key, options).compute;
        },
        cloneFromRef: function () {
            var contexts = [];
            var scope = this, context, parent;
            while (scope) {
                context = scope._context;
                if (context instanceof Scope.Refs) {
                    parent = scope._parent;
                    break;
                }
                contexts.unshift(context);
                scope = scope._parent;
            }
            if (parent) {
                can.each(contexts, function (context) {
                    parent = parent.add(context);
                });
                return parent;
            } else {
                return this;
            }
        }
    });
    can.view.Scope = Scope;
    function Options(data, parent, meta) {
        if (!data.helpers && !data.partials && !data.tags) {
            data = { helpers: data };
        }
        Scope.call(this, data, parent, meta);
    }
    Options.prototype = new Scope();
    Options.prototype.constructor = Options;
    can.view.Options = Options;
    return Scope;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#view/elements*/
swifty.define('can/elements',[
    'can/util/library',
    'can/view'
], function (can) {
    var doc = typeof document !== 'undefined' ? document : null;
    var selectsCommentNodes = doc && function () {
        return can.$(document.createComment('~')).length === 1;
    }();
    var elements = {
        tagToContentPropMap: {
            option: doc && 'textContent' in document.createElement('option') ? 'textContent' : 'innerText',
            textarea: 'value'
        },
        attrMap: can.attr.map,
        attrReg: /([^\s=]+)[\s]*=[\s]*/,
        defaultValue: can.attr.defaultValue,
        tagMap: {
            '': 'span',
            colgroup: 'col',
            table: 'tbody',
            tr: 'td',
            ol: 'li',
            ul: 'li',
            tbody: 'tr',
            thead: 'tr',
            tfoot: 'tr',
            select: 'option',
            optgroup: 'option'
        },
        reverseTagMap: {
            col: 'colgroup',
            tr: 'tbody',
            option: 'select',
            td: 'tr',
            th: 'tr',
            li: 'ul'
        },
        selfClosingTags: { col: true },
        getParentNode: function (el, defaultParentNode) {
            return defaultParentNode && el.parentNode.nodeType === 11 ? defaultParentNode : el.parentNode;
        },
        setAttr: can.attr.set,
        getAttr: can.attr.get,
        removeAttr: can.attr.remove,
        contentText: function (text) {
            if (typeof text === 'string') {
                return text;
            }
            if (!text && text !== 0) {
                return '';
            }
            return '' + text;
        },
        after: function (oldElements, newFrag) {
            var last = oldElements[oldElements.length - 1];
            if (last.nextSibling) {
                can.insertBefore(last.parentNode, newFrag, last.nextSibling, can.document);
            } else {
                can.appendChild(last.parentNode, newFrag, can.document);
            }
        },
        replace: function (oldElements, newFrag) {
            var selectedValue, parentNode = oldElements[0].parentNode;
            if (parentNode.nodeName.toUpperCase() === 'SELECT' && parentNode.selectedIndex >= 0) {
                selectedValue = parentNode.value;
            }
            elements.after(oldElements, newFrag);
            if (can.remove(can.$(oldElements)).length < oldElements.length && !selectsCommentNodes) {
                can.each(oldElements, function (el) {
                    if (el.nodeType === 8) {
                        el.parentNode.removeChild(el);
                    }
                });
            }
            if (selectedValue !== undefined) {
                parentNode.value = selectedValue;
            }
        }
    };
    can.view.elements = elements;
    return elements;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#view/callbacks/callbacks*/
swifty.define('can/view/callbacks',[
    'can/util/library',
    'can/view'
], function (can) {
    var attr = can.view.attr = function (attributeName, attrHandler) {
        if (attrHandler) {
            if (typeof attributeName === 'string') {
                attributes[attributeName] = attrHandler;
            } else {
                regExpAttributes.push({
                    match: attributeName,
                    handler: attrHandler
                });
            }
        } else {
            var cb = attributes[attributeName];
            if (!cb) {
                for (var i = 0, len = regExpAttributes.length; i < len; i++) {
                    var attrMatcher = regExpAttributes[i];
                    if (attrMatcher.match.test(attributeName)) {
                        cb = attrMatcher.handler;
                        break;
                    }
                }
            }
            return cb;
        }
    };
    var attributes = {}, regExpAttributes = [], automaticCustomElementCharacters = /[-\:]/;
    var tag = can.view.tag = function (tagName, tagHandler) {
        if (tagHandler) {
            if (can.global.html5) {
                can.global.html5.elements += ' ' + tagName;
                can.global.html5.shivDocument();
            }
            tags[tagName.toLowerCase()] = tagHandler;
        } else {
            var cb = tags[tagName.toLowerCase()];
            if (!cb && automaticCustomElementCharacters.test(tagName)) {
                cb = function () {
                };
            }
            return cb;
        }
    };
    var tags = {};
    can.view.callbacks = {
        _tags: tags,
        _attributes: attributes,
        _regExpAttributes: regExpAttributes,
        tag: tag,
        attr: attr,
        tagHandler: function (el, tagName, tagData) {
            var helperTagCallback = tagData.options.get('tags.' + tagName, { proxyMethods: false }), tagCallback = helperTagCallback || tags[tagName];
            var scope = tagData.scope, res;
            if (tagCallback) {
                res = can.__notObserve(tagCallback)(el, tagData);
            } else {
                res = scope;
            }
            if (res && tagData.subtemplate) {
                if (scope !== res) {
                    scope = scope.add(res);
                }
                var result = tagData.subtemplate(scope, tagData.options);
                var frag = typeof result === 'string' ? can.view.frag(result) : result;
                can.appendChild(el, frag);
            }
        }
    };
    return can.view.callbacks;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#view/scanner*/
swifty.define('can/scanner',[
    'can/view',
    'can/elements',
    'can/view/callbacks'
], function (can, elements, viewCallbacks) {
    var newLine = /(\r|\n)+/g, notEndTag = /\//, clean = function (content) {
            return content.split('\\').join('\\\\').split('\n').join('\\n').split('"').join('\\"').split('\t').join('\\t');
        }, getTag = function (tagName, tokens, i) {
            if (tagName) {
                return tagName;
            } else {
                while (i < tokens.length) {
                    if (tokens[i] === '<' && !notEndTag.test(tokens[i + 1])) {
                        return elements.reverseTagMap[tokens[i + 1]] || 'span';
                    }
                    i++;
                }
            }
            return '';
        }, bracketNum = function (content) {
            return --content.split('{').length - --content.split('}').length;
        }, myEval = function (script) {
            eval(script);
        }, attrReg = /([^\s]+)[\s]*=[\s]*$/, startTxt = 'var ___v1ew = [];', finishTxt = 'return ___v1ew.join(\'\')', put_cmd = '___v1ew.push(\n', insert_cmd = put_cmd, htmlTag = null, quote = null, beforeQuote = null, rescan = null, getAttrName = function () {
            var matches = beforeQuote.match(attrReg);
            return matches && matches[1];
        }, status = function () {
            return quote ? '\'' + getAttrName() + '\'' : htmlTag ? 1 : 0;
        }, top = function (stack) {
            return stack[stack.length - 1];
        }, Scanner;
    can.view.Scanner = Scanner = function (options) {
        can.extend(this, {
            text: {},
            tokens: []
        }, options);
        this.text.options = this.text.options || '';
        this.tokenReg = [];
        this.tokenSimple = {
            '<': '<',
            '>': '>',
            '"': '"',
            '\'': '\''
        };
        this.tokenComplex = [];
        this.tokenMap = {};
        for (var i = 0, token; token = this.tokens[i]; i++) {
            if (token[2]) {
                this.tokenReg.push(token[2]);
                this.tokenComplex.push({
                    abbr: token[1],
                    re: new RegExp(token[2]),
                    rescan: token[3]
                });
            } else {
                this.tokenReg.push(token[1]);
                this.tokenSimple[token[1]] = token[0];
            }
            this.tokenMap[token[0]] = token[1];
        }
        this.tokenReg = new RegExp('(' + this.tokenReg.slice(0).concat([
            '<',
            '>',
            '"',
            '\''
        ]).join('|') + ')', 'g');
    };
    Scanner.prototype = {
        helpers: [],
        scan: function (source, name) {
            var tokens = [], last = 0, simple = this.tokenSimple, complex = this.tokenComplex;
            source = source.replace(newLine, '\n');
            if (this.transform) {
                source = this.transform(source);
            }
            source.replace(this.tokenReg, function (whole, part) {
                var offset = arguments[arguments.length - 2];
                if (offset > last) {
                    tokens.push(source.substring(last, offset));
                }
                if (simple[whole]) {
                    tokens.push(whole);
                } else {
                    for (var i = 0, token; token = complex[i]; i++) {
                        if (token.re.test(whole)) {
                            tokens.push(token.abbr);
                            if (token.rescan) {
                                tokens.push(token.rescan(part));
                            }
                            break;
                        }
                    }
                }
                last = offset + part.length;
            });
            if (last < source.length) {
                tokens.push(source.substr(last));
            }
            var content = '', buff = [startTxt + (this.text.start || '')], put = function (content, bonus) {
                    buff.push(put_cmd, '"', clean(content), '"' + (bonus || '') + ');');
                }, endStack = [], lastToken, startTag = null, magicInTag = false, specialStates = {
                    attributeHookups: [],
                    tagHookups: [],
                    lastTagHookup: ''
                }, popTagHookup = function () {
                    specialStates.lastTagHookup = specialStates.tagHookups.pop() + specialStates.tagHookups.length;
                }, tagName = '', tagNames = [], popTagName = false, bracketCount, specialAttribute = false, i = 0, token, tmap = this.tokenMap, attrName;
            htmlTag = quote = beforeQuote = null;
            for (; (token = tokens[i++]) !== undefined;) {
                if (startTag === null) {
                    switch (token) {
                    case tmap.left:
                    case tmap.escapeLeft:
                    case tmap.returnLeft:
                        magicInTag = htmlTag && 1;
                    case tmap.commentLeft:
                        startTag = token;
                        if (content.length) {
                            put(content);
                        }
                        content = '';
                        break;
                    case tmap.escapeFull:
                        magicInTag = htmlTag && 1;
                        rescan = 1;
                        startTag = tmap.escapeLeft;
                        if (content.length) {
                            put(content);
                        }
                        rescan = tokens[i++];
                        content = rescan.content || rescan;
                        if (rescan.before) {
                            put(rescan.before);
                        }
                        tokens.splice(i, 0, tmap.right);
                        break;
                    case tmap.commentFull:
                        break;
                    case tmap.templateLeft:
                        content += tmap.left;
                        break;
                    case '<':
                        if (tokens[i].indexOf('!--') !== 0) {
                            htmlTag = 1;
                            magicInTag = 0;
                        }
                        content += token;
                        break;
                    case '>':
                        htmlTag = 0;
                        var emptyElement = content.substr(content.length - 1) === '/' || content.substr(content.length - 2) === '--', attrs = '';
                        if (specialStates.attributeHookups.length) {
                            attrs = 'attrs: [\'' + specialStates.attributeHookups.join('\',\'') + '\'], ';
                            specialStates.attributeHookups = [];
                        }
                        if (tagName + specialStates.tagHookups.length !== specialStates.lastTagHookup && tagName === top(specialStates.tagHookups)) {
                            if (emptyElement) {
                                content = content.substr(0, content.length - 1);
                            }
                            buff.push(put_cmd, '"', clean(content), '"', ',can.view.pending({tagName:\'' + tagName + '\',' + attrs + 'scope: ' + (this.text.scope || 'this') + this.text.options);
                            if (emptyElement) {
                                buff.push('}));');
                                content = '/>';
                                popTagHookup();
                            } else if (tokens[i] === '<' && tokens[i + 1] === '/' + tagName) {
                                buff.push('}));');
                                content = token;
                                popTagHookup();
                            } else {
                                buff.push(',subtemplate: function(' + this.text.argNames + '){\n' + startTxt + (this.text.start || ''));
                                content = '';
                            }
                        } else if (magicInTag || !popTagName && elements.tagToContentPropMap[tagNames[tagNames.length - 1]] || attrs) {
                            var pendingPart = ',can.view.pending({' + attrs + 'scope: ' + (this.text.scope || 'this') + this.text.options + '}),"';
                            if (emptyElement) {
                                put(content.substr(0, content.length - 1), pendingPart + '/>"');
                            } else {
                                put(content, pendingPart + '>"');
                            }
                            content = '';
                            magicInTag = 0;
                        } else {
                            content += token;
                        }
                        if (emptyElement || popTagName) {
                            tagNames.pop();
                            tagName = tagNames[tagNames.length - 1];
                            popTagName = false;
                        }
                        specialStates.attributeHookups = [];
                        break;
                    case '\'':
                    case '"':
                        if (htmlTag) {
                            if (quote && quote === token) {
                                quote = null;
                                var attr = getAttrName();
                                if (viewCallbacks.attr(attr)) {
                                    specialStates.attributeHookups.push(attr);
                                }
                                if (specialAttribute) {
                                    content += token;
                                    put(content);
                                    buff.push(finishTxt, '}));\n');
                                    content = '';
                                    specialAttribute = false;
                                    break;
                                }
                            } else if (quote === null) {
                                quote = token;
                                beforeQuote = lastToken;
                                attrName = getAttrName();
                                if (tagName === 'img' && attrName === 'src' || attrName === 'style') {
                                    put(content.replace(attrReg, ''));
                                    content = '';
                                    specialAttribute = true;
                                    buff.push(insert_cmd, 'can.view.txt(2,\'' + getTag(tagName, tokens, i) + '\',' + status() + ',this,function(){', startTxt);
                                    put(attrName + '=' + token);
                                    break;
                                }
                            }
                        }
                    default:
                        if (lastToken === '<') {
                            tagName = token.substr(0, 3) === '!--' ? '!--' : token.split(/\s/)[0];
                            var isClosingTag = false, cleanedTagName;
                            if (tagName.indexOf('/') === 0) {
                                isClosingTag = true;
                                cleanedTagName = tagName.substr(1);
                            }
                            if (isClosingTag) {
                                if (top(tagNames) === cleanedTagName) {
                                    tagName = cleanedTagName;
                                    popTagName = true;
                                }
                                if (top(specialStates.tagHookups) === cleanedTagName) {
                                    put(content.substr(0, content.length - 1));
                                    buff.push(finishTxt + '}}) );');
                                    content = '><';
                                    popTagHookup();
                                }
                            } else {
                                if (tagName.lastIndexOf('/') === tagName.length - 1) {
                                    tagName = tagName.substr(0, tagName.length - 1);
                                }
                                if (tagName !== '!--' && viewCallbacks.tag(tagName)) {
                                    if (tagName === 'content' && elements.tagMap[top(tagNames)]) {
                                        token = token.replace('content', elements.tagMap[top(tagNames)]);
                                    }
                                    specialStates.tagHookups.push(tagName);
                                }
                                tagNames.push(tagName);
                            }
                        }
                        content += token;
                        break;
                    }
                } else {
                    switch (token) {
                    case tmap.right:
                    case tmap.returnRight:
                        switch (startTag) {
                        case tmap.left:
                            bracketCount = bracketNum(content);
                            if (bracketCount === 1) {
                                buff.push(insert_cmd, 'can.view.txt(0,\'' + getTag(tagName, tokens, i) + '\',' + status() + ',this,function(){', startTxt, content);
                                endStack.push({
                                    before: '',
                                    after: finishTxt + '}));\n'
                                });
                            } else {
                                last = endStack.length && bracketCount === -1 ? endStack.pop() : { after: ';' };
                                if (last.before) {
                                    buff.push(last.before);
                                }
                                buff.push(content, ';', last.after);
                            }
                            break;
                        case tmap.escapeLeft:
                        case tmap.returnLeft:
                            bracketCount = bracketNum(content);
                            if (bracketCount) {
                                endStack.push({
                                    before: finishTxt,
                                    after: '}));\n'
                                });
                            }
                            var escaped = startTag === tmap.escapeLeft ? 1 : 0, commands = {
                                    insert: insert_cmd,
                                    tagName: getTag(tagName, tokens, i),
                                    status: status(),
                                    specialAttribute: specialAttribute
                                };
                            for (var ii = 0; ii < this.helpers.length; ii++) {
                                var helper = this.helpers[ii];
                                if (helper.name.test(content)) {
                                    content = helper.fn(content, commands);
                                    if (helper.name.source === /^>[\s]*\w*/.source) {
                                        escaped = 0;
                                    }
                                    break;
                                }
                            }
                            if (typeof content === 'object') {
                                if (content.startTxt && content.end && specialAttribute) {
                                    buff.push(insert_cmd, 'can.view.toStr( ', content.content, '() ) );');
                                } else {
                                    if (content.startTxt) {
                                        buff.push(insert_cmd, 'can.view.txt(\n' + (typeof status() === 'string' || (content.escaped != null ? content.escaped : escaped)) + ',\n\'' + tagName + '\',\n' + status() + ',\nthis,\n');
                                    } else if (content.startOnlyTxt) {
                                        buff.push(insert_cmd, 'can.view.onlytxt(this,\n');
                                    }
                                    buff.push(content.content);
                                    if (content.end) {
                                        buff.push('));');
                                    }
                                }
                            } else if (specialAttribute) {
                                buff.push(insert_cmd, content, ');');
                            } else {
                                buff.push(insert_cmd, 'can.view.txt(\n' + (typeof status() === 'string' || escaped) + ',\n\'' + tagName + '\',\n' + status() + ',\nthis,\nfunction(){ ' + (this.text.escape || '') + 'return ', content, bracketCount ? startTxt : '}));\n');
                            }
                            if (rescan && rescan.after && rescan.after.length) {
                                put(rescan.after.length);
                                rescan = null;
                            }
                            break;
                        }
                        startTag = null;
                        content = '';
                        break;
                    case tmap.templateLeft:
                        content += tmap.left;
                        break;
                    default:
                        content += token;
                        break;
                    }
                }
                lastToken = token;
            }
            if (content.length) {
                put(content);
            }
            buff.push(';');
            var template = buff.join(''), out = { out: (this.text.outStart || '') + template + ' ' + finishTxt + (this.text.outEnd || '') };
            myEval.call(out, 'this.fn = (function(' + this.text.argNames + '){' + out.out + '});\r\n//# sourceURL=' + name + '.js');
            return out;
        }
    };
    can.view.pending = function (viewData) {
        var hooks = can.view.getHooks();
        return can.view.hook(function (el) {
            can.each(hooks, function (fn) {
                fn(el);
            });
            viewData.templateType = 'legacy';
            if (viewData.tagName) {
                viewCallbacks.tagHandler(el, viewData.tagName, viewData);
            }
            can.each(viewData && viewData.attrs || [], function (attributeName) {
                viewData.attributeName = attributeName;
                var callback = viewCallbacks.attr(attributeName);
                if (callback) {
                    callback(el, viewData);
                }
            });
        });
    };
    can.view.tag('content', function (el, tagData) {
        return tagData.scope;
    });
    can.view.Scanner = Scanner;
    return Scanner;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#view/node_lists/node_lists*/
swifty.define('can/view/node_lists',[
    'can/util/library',
    'can/elements'
], function (can) {
    var canExpando = true;
    try {
        document.createTextNode('')._ = 0;
    } catch (ex) {
        canExpando = false;
    }
    var nodeMap = {}, textNodeMap = {}, expando = 'ejs_' + Math.random(), _id = 0, id = function (node, localMap) {
            var _textNodeMap = localMap || textNodeMap;
            var id = readId(node, _textNodeMap);
            if (id) {
                return id;
            } else {
                if (canExpando || node.nodeType !== 3) {
                    ++_id;
                    return node[expando] = (node.nodeName ? 'element_' : 'obj_') + _id;
                } else {
                    ++_id;
                    _textNodeMap['text_' + _id] = node;
                    return 'text_' + _id;
                }
            }
        }, readId = function (node, textNodeMap) {
            if (canExpando || node.nodeType !== 3) {
                return node[expando];
            } else {
                for (var textNodeID in textNodeMap) {
                    if (textNodeMap[textNodeID] === node) {
                        return textNodeID;
                    }
                }
            }
        }, splice = [].splice, push = [].push, itemsInChildListTree = function (list) {
            var count = 0;
            for (var i = 0, len = list.length; i < len; i++) {
                var item = list[i];
                if (item.nodeType) {
                    count++;
                } else {
                    count += itemsInChildListTree(item);
                }
            }
            return count;
        }, replacementMap = function (replacements, idMap) {
            var map = {};
            for (var i = 0, len = replacements.length; i < len; i++) {
                var node = nodeLists.first(replacements[i]);
                map[id(node, idMap)] = replacements[i];
            }
            return map;
        }, addUnfoundAsDeepChildren = function (list, rMap, foundIds) {
            for (var repId in rMap) {
                if (!foundIds[repId]) {
                    list.newDeepChildren.push(rMap[repId]);
                }
            }
        };
    var nodeLists = {
        id: id,
        update: function (nodeList, newNodes) {
            var oldNodes = nodeLists.unregisterChildren(nodeList);
            newNodes = can.makeArray(newNodes);
            var oldListLength = nodeList.length;
            splice.apply(nodeList, [
                0,
                oldListLength
            ].concat(newNodes));
            if (nodeList.replacements) {
                nodeLists.nestReplacements(nodeList);
                nodeList.deepChildren = nodeList.newDeepChildren;
                nodeList.newDeepChildren = [];
            } else {
                nodeLists.nestList(nodeList);
            }
            return oldNodes;
        },
        nestReplacements: function (list) {
            var index = 0, idMap = {}, rMap = replacementMap(list.replacements, idMap), rCount = list.replacements.length, foundIds = {};
            while (index < list.length && rCount) {
                var node = list[index], nodeId = readId(node, idMap), replacement = rMap[nodeId];
                if (replacement) {
                    list.splice(index, itemsInChildListTree(replacement), replacement);
                    foundIds[nodeId] = true;
                    rCount--;
                }
                index++;
            }
            if (rCount) {
                addUnfoundAsDeepChildren(list, rMap, foundIds);
            }
            list.replacements = [];
        },
        nestList: function (list) {
            var index = 0;
            while (index < list.length) {
                var node = list[index], childNodeList = nodeMap[id(node)];
                if (childNodeList) {
                    if (childNodeList !== list) {
                        list.splice(index, itemsInChildListTree(childNodeList), childNodeList);
                    }
                } else {
                    nodeMap[id(node)] = list;
                }
                index++;
            }
        },
        last: function (nodeList) {
            var last = nodeList[nodeList.length - 1];
            if (last.nodeType) {
                return last;
            } else {
                return nodeLists.last(last);
            }
        },
        first: function (nodeList) {
            var first = nodeList[0];
            if (first.nodeType) {
                return first;
            } else {
                return nodeLists.first(first);
            }
        },
        flatten: function (nodeList) {
            var items = [];
            for (var i = 0; i < nodeList.length; i++) {
                var item = nodeList[i];
                if (item.nodeType) {
                    items.push(item);
                } else {
                    items.push.apply(items, nodeLists.flatten(item));
                }
            }
            return items;
        },
        register: function (nodeList, unregistered, parent, directlyNested) {
            can.cid(nodeList);
            nodeList.unregistered = unregistered;
            nodeList.parentList = parent;
            nodeList.nesting = parent && typeof parent.nesting !== 'undefined' ? parent.nesting + 1 : 0;
            if (parent) {
                nodeList.deepChildren = [];
                nodeList.newDeepChildren = [];
                nodeList.replacements = [];
                if (parent !== true) {
                    if (directlyNested) {
                        parent.replacements.push(nodeList);
                    } else {
                        parent.newDeepChildren.push(nodeList);
                    }
                }
            } else {
                nodeLists.nestList(nodeList);
            }
            return nodeList;
        },
        unregisterChildren: function (nodeList) {
            var nodes = [];
            can.each(nodeList, function (node) {
                if (node.nodeType) {
                    if (!nodeList.replacements) {
                        delete nodeMap[id(node)];
                    }
                    nodes.push(node);
                } else {
                    push.apply(nodes, nodeLists.unregister(node, true));
                }
            });
            can.each(nodeList.deepChildren, function (nodeList) {
                nodeLists.unregister(nodeList, true);
            });
            return nodes;
        },
        unregister: function (nodeList, isChild) {
            var nodes = nodeLists.unregisterChildren(nodeList, true);
            if (nodeList.unregistered) {
                var unregisteredCallback = nodeList.unregistered;
                nodeList.replacements = nodeList.unregistered = null;
                if (!isChild) {
                    var deepChildren = nodeList.parentList && nodeList.parentList.deepChildren;
                    if (deepChildren) {
                        var index = deepChildren.indexOf(nodeList);
                        if (index !== -1) {
                            deepChildren.splice(index, 1);
                        }
                    }
                }
                unregisteredCallback();
            }
            return nodes;
        },
        nodeMap: nodeMap
    };
    can.view.nodeLists = nodeLists;
    return nodeLists;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#view/parser/parser*/
swifty.define('can/view/parser',[], function () {
    function each(items, callback) {
        for (var i = 0; i < items.length; i++) {
            callback(items[i], i);
        }
    }
    function makeMap(str) {
        var obj = {}, items = str.split(',');
        each(items, function (name) {
            obj[name] = true;
        });
        return obj;
    }
    function handleIntermediate(intermediate, handler) {
        for (var i = 0, len = intermediate.length; i < len; i++) {
            var item = intermediate[i];
            handler[item.tokenType].apply(handler, item.args);
        }
        return intermediate;
    }
    var alphaNumeric = 'A-Za-z0-9', alphaNumericHU = '-:_' + alphaNumeric, attributeNames = '[^=>\\s\\/]+', spaceEQspace = '\\s*=\\s*', singleCurly = '\\{[^\\}\\{]\\}', doubleCurly = '\\{\\{[^\\}]\\}\\}\\}?', attributeEqAndValue = '(?:' + spaceEQspace + '(?:' + '(?:' + doubleCurly + ')|(?:' + singleCurly + ')|(?:"[^"]*")|(?:\'[^\']*\')|[^>\\s]+))?', matchStash = '\\{\\{[^\\}]*\\}\\}\\}?', stash = '\\{\\{([^\\}]*)\\}\\}\\}?', startTag = new RegExp('^<([' + alphaNumeric + '][' + alphaNumericHU + ']*)' + '(' + '(?:\\s*' + '(?:(?:' + '(?:' + attributeNames + ')?' + attributeEqAndValue + ')|' + '(?:' + matchStash + ')+)' + ')*' + ')\\s*(\\/?)>'), endTag = new RegExp('^<\\/([' + alphaNumericHU + ']+)[^>]*>'), mustache = new RegExp(stash, 'g'), txtBreak = /<|\{\{/, space = /\s/;
    var empty = makeMap('area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed');
    var block = makeMap('a,address,article,applet,aside,audio,blockquote,button,canvas,center,dd,del,dir,div,dl,dt,fieldset,figcaption,figure,footer,form,frameset,h1,h2,h3,h4,h5,h6,header,hgroup,hr,iframe,ins,isindex,li,map,menu,noframes,noscript,object,ol,output,p,pre,section,script,table,tbody,td,tfoot,th,thead,tr,ul,video');
    var inline = makeMap('a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,script,select,small,span,strike,strong,sub,sup,textarea,tt,u,var');
    var closeSelf = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr');
    var special = makeMap('script');
    var tokenTypes = 'start,end,close,attrStart,attrEnd,attrValue,chars,comment,special,done'.split(',');
    var fn = function () {
    };
    var HTMLParser = function (html, handler, returnIntermediate) {
        if (typeof html === 'object') {
            return handleIntermediate(html, handler);
        }
        var intermediate = [];
        handler = handler || {};
        if (returnIntermediate) {
            each(tokenTypes, function (name) {
                var callback = handler[name] || fn;
                handler[name] = function () {
                    if (callback.apply(this, arguments) !== false) {
                        intermediate.push({
                            tokenType: name,
                            args: [].slice.call(arguments, 0)
                        });
                    }
                };
            });
        }
        function parseStartTag(tag, tagName, rest, unary) {
            tagName = tagName.toLowerCase();
            if (block[tagName] && !inline[tagName]) {
                var last = stack.last();
                while (last && inline[last] && !block[last]) {
                    parseEndTag('', last);
                    last = stack.last();
                }
            }
            if (closeSelf[tagName] && stack.last() === tagName) {
                parseEndTag('', tagName);
            }
            unary = empty[tagName] || !!unary;
            handler.start(tagName, unary);
            if (!unary) {
                stack.push(tagName);
            }
            HTMLParser.parseAttrs(rest, handler);
            handler.end(tagName, unary);
        }
        function parseEndTag(tag, tagName) {
            var pos;
            if (!tagName) {
                pos = 0;
            } else {
                tagName = tagName.toLowerCase();
                for (pos = stack.length - 1; pos >= 0; pos--) {
                    if (stack[pos] === tagName) {
                        break;
                    }
                }
            }
            if (pos >= 0) {
                for (var i = stack.length - 1; i >= pos; i--) {
                    if (handler.close) {
                        handler.close(stack[i]);
                    }
                }
                stack.length = pos;
            }
        }
        function parseMustache(mustache, inside) {
            if (handler.special) {
                handler.special(inside);
            }
        }
        var callChars = function () {
            if (charsText) {
                if (handler.chars) {
                    handler.chars(charsText);
                }
            }
            charsText = '';
        };
        var index, chars, match, stack = [], last = html, charsText = '';
        stack.last = function () {
            return this[this.length - 1];
        };
        while (html) {
            chars = true;
            if (!stack.last() || !special[stack.last()]) {
                if (html.indexOf('<!--') === 0) {
                    index = html.indexOf('-->');
                    if (index >= 0) {
                        callChars();
                        if (handler.comment) {
                            handler.comment(html.substring(4, index));
                        }
                        html = html.substring(index + 3);
                        chars = false;
                    }
                } else if (html.indexOf('</') === 0) {
                    match = html.match(endTag);
                    if (match) {
                        callChars();
                        html = html.substring(match[0].length);
                        match[0].replace(endTag, parseEndTag);
                        chars = false;
                    }
                } else if (html.indexOf('<') === 0) {
                    match = html.match(startTag);
                    if (match) {
                        callChars();
                        html = html.substring(match[0].length);
                        match[0].replace(startTag, parseStartTag);
                        chars = false;
                    }
                } else if (html.indexOf('{{') === 0) {
                    match = html.match(mustache);
                    if (match) {
                        callChars();
                        html = html.substring(match[0].length);
                        match[0].replace(mustache, parseMustache);
                    }
                }
                if (chars) {
                    index = html.search(txtBreak);
                    if (index === 0 && html === last) {
                        charsText += html.charAt(0);
                        html = html.substr(1);
                        index = html.search(txtBreak);
                    }
                    var text = index < 0 ? html : html.substring(0, index);
                    html = index < 0 ? '' : html.substring(index);
                    if (text) {
                        charsText += text;
                    }
                }
            } else {
                html = html.replace(new RegExp('([\\s\\S]*?)</' + stack.last() + '[^>]*>'), function (all, text) {
                    text = text.replace(/<!--([\s\S]*?)-->|<!\[CDATA\[([\s\S]*?)]]>/g, '$1$2');
                    if (handler.chars) {
                        handler.chars(text);
                    }
                    return '';
                });
                parseEndTag('', stack.last());
            }
            if (html === last) {
                throw new Error('Parse Error: ' + html);
            }
            last = html;
        }
        callChars();
        parseEndTag();
        handler.done();
        return intermediate;
    };
    var callAttrStart = function (state, curIndex, handler, rest) {
        state.attrStart = rest.substring(typeof state.nameStart === 'number' ? state.nameStart : curIndex, curIndex);
        handler.attrStart(state.attrStart);
        state.inName = false;
    };
    var callAttrEnd = function (state, curIndex, handler, rest) {
        if (state.valueStart !== undefined && state.valueStart < curIndex) {
            handler.attrValue(rest.substring(state.valueStart, curIndex));
        } else if (!state.inValue) {
        }
        handler.attrEnd(state.attrStart);
        state.attrStart = undefined;
        state.valueStart = undefined;
        state.inValue = false;
        state.inName = false;
        state.lookingForEq = false;
        state.inQuote = false;
        state.lookingForName = true;
    };
    HTMLParser.parseAttrs = function (rest, handler) {
        if (!rest) {
            return;
        }
        var i = 0;
        var curIndex;
        var state = {
            inDoubleCurly: false,
            inName: false,
            nameStart: undefined,
            inValue: false,
            valueStart: undefined,
            inQuote: false,
            attrStart: undefined,
            lookingForName: true,
            lookingForValue: false,
            lookingForEq: false
        };
        while (i < rest.length) {
            curIndex = i;
            var cur = rest.charAt(i);
            var next = rest.charAt(i + 1);
            var nextNext = rest.charAt(i + 2);
            i++;
            if (cur === '{' && next === '{') {
                if (state.inValue && curIndex > state.valueStart) {
                    handler.attrValue(rest.substring(state.valueStart, curIndex));
                } else if (state.inName && state.nameStart < curIndex) {
                    callAttrStart(state, curIndex, handler, rest);
                    callAttrEnd(state, curIndex, handler, rest);
                } else if (state.lookingForValue) {
                    state.inValue = true;
                } else if (state.lookingForEq && state.attrStart) {
                    callAttrEnd(state, curIndex, handler, rest);
                }
                state.inDoubleCurly = true;
                state.doubleCurlyStart = curIndex + 2;
                i++;
            } else if (state.inDoubleCurly) {
                if (cur === '}' && next === '}') {
                    var isTriple = nextNext === '}' ? 1 : 0;
                    handler.special(rest.substring(state.doubleCurlyStart, curIndex));
                    state.inDoubleCurly = false;
                    if (state.inValue) {
                        state.valueStart = curIndex + 2 + isTriple;
                    }
                    i += 1 + isTriple;
                }
            } else if (state.inValue) {
                if (state.inQuote) {
                    if (cur === state.inQuote) {
                        callAttrEnd(state, curIndex, handler, rest);
                    }
                } else if (space.test(cur)) {
                    callAttrEnd(state, curIndex, handler, rest);
                }
            } else if (cur === '=' && (state.lookingForEq || state.lookingForName || state.inName)) {
                if (!state.attrStart) {
                    callAttrStart(state, curIndex, handler, rest);
                }
                state.lookingForValue = true;
                state.lookingForEq = false;
                state.lookingForName = false;
            } else if (state.inName) {
                if (space.test(cur)) {
                    callAttrStart(state, curIndex, handler, rest);
                    state.lookingForEq = true;
                }
            } else if (state.lookingForName) {
                if (!space.test(cur)) {
                    if (state.attrStart) {
                        callAttrEnd(state, curIndex, handler, rest);
                    }
                    state.nameStart = curIndex;
                    state.inName = true;
                }
            } else if (state.lookingForValue) {
                if (!space.test(cur)) {
                    state.lookingForValue = false;
                    state.inValue = true;
                    if (cur === '\'' || cur === '"') {
                        state.inQuote = cur;
                        state.valueStart = curIndex + 1;
                    } else {
                        state.valueStart = curIndex;
                    }
                }
            }
        }
        if (state.inName) {
            callAttrStart(state, curIndex + 1, handler, rest);
            callAttrEnd(state, curIndex + 1, handler, rest);
        } else if (state.lookingForEq) {
            callAttrEnd(state, curIndex + 1, handler, rest);
        } else if (state.inValue) {
            callAttrEnd(state, curIndex + 1, handler, rest);
        }
    };
    return HTMLParser;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#util/array/diff*/
swifty.define('can/util/diff',[], function () {
    var slice = [].slice;
    return function (oldList, newList) {
        var oldIndex = 0, newIndex = 0, oldLength = oldList.length, newLength = newList.length, patches = [];
        while (oldIndex < oldLength && newIndex < newLength) {
            var oldItem = oldList[oldIndex], newItem = newList[newIndex];
            if (oldItem === newItem) {
                oldIndex++;
                newIndex++;
                continue;
            }
            if (newIndex + 1 < newLength && newList[newIndex + 1] === oldItem) {
                patches.push({
                    index: newIndex,
                    deleteCount: 0,
                    insert: [newList[newIndex]]
                });
                oldIndex++;
                newIndex += 2;
                continue;
            } else if (oldIndex + 1 < oldLength && oldList[oldIndex + 1] === newItem) {
                patches.push({
                    index: newIndex,
                    deleteCount: 1,
                    insert: []
                });
                oldIndex += 2;
                newIndex++;
                continue;
            } else {
                patches.push({
                    index: newIndex,
                    deleteCount: oldLength - oldIndex,
                    insert: slice.call(newList, newIndex)
                });
                return patches;
            }
        }
        if (newIndex === newLength && oldIndex === oldLength) {
            return patches;
        }
        patches.push({
            index: newIndex,
            deleteCount: oldLength - oldIndex,
            insert: slice.call(newList, newIndex)
        });
        return patches;
    };
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#view/live/live*/
swifty.define('can/view/live',[
    'can/util/library',
    'can/elements',
    'can/view',
    'can/view/node_lists',
    'can/view/parser',
    'can/util/diff'
], function (can, elements, view, nodeLists, parser, diff) {
    elements = elements || can.view.elements;
    nodeLists = nodeLists || can.view.NodeLists;
    parser = parser || can.view.parser;
    var setup = function (el, bind, unbind) {
            var tornDown = false, teardown = function () {
                    if (!tornDown) {
                        tornDown = true;
                        unbind(data);
                        can.unbind.call(el, 'removed', teardown);
                    }
                    return true;
                }, data = {
                    teardownCheck: function (parent) {
                        return parent ? false : teardown();
                    }
                };
            can.bind.call(el, 'removed', teardown);
            bind(data);
            return data;
        }, getChildNodes = function (node) {
            var childNodes = node.childNodes;
            if ('length' in childNodes) {
                return childNodes;
            } else {
                var cur = node.firstChild;
                var nodes = [];
                while (cur) {
                    nodes.push(cur);
                    cur = cur.nextSibling;
                }
                return nodes;
            }
        }, listen = function (el, compute, change) {
            return setup(el, function () {
                compute.computeInstance.bind('change', change);
            }, function (data) {
                compute.computeInstance.unbind('change', change);
                if (data.nodeList) {
                    nodeLists.unregister(data.nodeList);
                }
            });
        }, getAttributeParts = function (newVal) {
            var attrs = {}, attr;
            parser.parseAttrs(newVal, {
                attrStart: function (name) {
                    attrs[name] = '';
                    attr = name;
                },
                attrValue: function (value) {
                    attrs[attr] += value;
                },
                attrEnd: function () {
                }
            });
            return attrs;
        }, splice = [].splice, isNode = function (obj) {
            return obj && obj.nodeType;
        }, addTextNodeIfNoChildren = function (frag) {
            if (!frag.firstChild) {
                frag.appendChild(frag.ownerDocument.createTextNode(''));
            }
        }, getLiveFragment = function (itemHTML) {
            var gotText = typeof itemHTML === 'string', itemFrag = can.frag(itemHTML);
            return gotText ? can.view.hookup(itemFrag) : itemFrag;
        }, renderAndAddToNodeLists = function (newNodeLists, parentNodeList, render, context, args) {
            var itemNodeList = [];
            if (parentNodeList) {
                nodeLists.register(itemNodeList, null, true, true);
                itemNodeList.parentList = parentNodeList;
                itemNodeList.expression = '#each SUBEXPRESSION';
            }
            var itemHTML = render.apply(context, args.concat([itemNodeList])), itemFrag = getLiveFragment(itemHTML);
            var childNodes = can.makeArray(getChildNodes(itemFrag));
            if (parentNodeList) {
                nodeLists.update(itemNodeList, childNodes);
                newNodeLists.push(itemNodeList);
            } else {
                newNodeLists.push(nodeLists.register(childNodes));
            }
            return itemFrag;
        }, removeFromNodeList = function (masterNodeList, index, length) {
            var removedMappings = masterNodeList.splice(index + 1, length), itemsToRemove = [];
            can.each(removedMappings, function (nodeList) {
                var nodesToRemove = nodeLists.unregister(nodeList);
                [].push.apply(itemsToRemove, nodesToRemove);
            });
            return itemsToRemove;
        }, addFalseyIfEmpty = function (list, falseyRender, masterNodeList, nodeList) {
            if (falseyRender && list.length === 0) {
                var falseyNodeLists = [];
                var falseyFrag = renderAndAddToNodeLists(falseyNodeLists, nodeList, falseyRender, list, [list]);
                elements.after([masterNodeList[0]], falseyFrag);
                masterNodeList.push(falseyNodeLists[0]);
            }
        }, childMutationCallbacks = {};
    var live = {
        registerChildMutationCallback: function (tag, callback) {
            if (callback) {
                childMutationCallbacks[tag] = callback;
            } else {
                return childMutationCallbacks[tag];
            }
        },
        callChildMutationCallback: function (el) {
            var callback = el && childMutationCallbacks[el.nodeName.toLowerCase()];
            if (callback) {
                callback(el);
            }
        },
        list: function (el, compute, render, context, parentNode, nodeList, falseyRender) {
            var masterNodeList = nodeList || [el], indexMap = [], afterPreviousEvents = false, isTornDown = false, add = function (ev, items, index) {
                    if (!afterPreviousEvents) {
                        return;
                    }
                    var frag = text.ownerDocument.createDocumentFragment(), newNodeLists = [], newIndicies = [];
                    can.each(items, function (item, key) {
                        var itemIndex = can.compute(key + index), itemFrag = renderAndAddToNodeLists(newNodeLists, nodeList, render, context, [
                                item,
                                itemIndex
                            ]);
                        frag.appendChild(itemFrag);
                        newIndicies.push(itemIndex);
                    });
                    var masterListIndex = index + 1;
                    if (!indexMap.length) {
                        var falseyItemsToRemove = removeFromNodeList(masterNodeList, 0, masterNodeList.length - 1);
                        can.remove(can.$(falseyItemsToRemove));
                    }
                    if (!masterNodeList[masterListIndex]) {
                        elements.after(masterListIndex === 1 ? [text] : [nodeLists.last(masterNodeList[masterListIndex - 1])], frag);
                    } else {
                        var el = nodeLists.first(masterNodeList[masterListIndex]);
                        can.insertBefore(el.parentNode, frag, el);
                    }
                    splice.apply(masterNodeList, [
                        masterListIndex,
                        0
                    ].concat(newNodeLists));
                    splice.apply(indexMap, [
                        index,
                        0
                    ].concat(newIndicies));
                    for (var i = index + newIndicies.length, len = indexMap.length; i < len; i++) {
                        indexMap[i](i);
                    }
                    if (ev.callChildMutationCallback !== false) {
                        live.callChildMutationCallback(text.parentNode);
                    }
                }, set = function (ev, newVal, index) {
                    remove({}, { length: 1 }, index, true);
                    add({}, [newVal], index);
                }, remove = function (ev, items, index, duringTeardown, fullTeardown) {
                    if (!afterPreviousEvents) {
                        return;
                    }
                    if (!duringTeardown && data.teardownCheck(text.parentNode)) {
                        return;
                    }
                    if (index < 0) {
                        index = indexMap.length + index;
                    }
                    var itemsToRemove = removeFromNodeList(masterNodeList, index, items.length);
                    indexMap.splice(index, items.length);
                    for (var i = index, len = indexMap.length; i < len; i++) {
                        indexMap[i](i);
                    }
                    if (!fullTeardown) {
                        addFalseyIfEmpty(list, falseyRender, masterNodeList, nodeList);
                        can.remove(can.$(itemsToRemove));
                        if (ev.callChildMutationCallback !== false) {
                            live.callChildMutationCallback(text.parentNode);
                        }
                    } else {
                        nodeLists.unregister(masterNodeList);
                    }
                }, move = function (ev, item, newIndex, currentIndex) {
                    if (!afterPreviousEvents) {
                        return;
                    }
                    newIndex = newIndex + 1;
                    currentIndex = currentIndex + 1;
                    var referenceNodeList = masterNodeList[newIndex];
                    var movedElements = can.frag(nodeLists.flatten(masterNodeList[currentIndex]));
                    var referenceElement;
                    if (currentIndex < newIndex) {
                        referenceElement = nodeLists.last(referenceNodeList).nextSibling;
                    } else {
                        referenceElement = nodeLists.first(referenceNodeList);
                    }
                    var parentNode = masterNodeList[0].parentNode;
                    parentNode.insertBefore(movedElements, referenceElement);
                    var temp = masterNodeList[currentIndex];
                    [].splice.apply(masterNodeList, [
                        currentIndex,
                        1
                    ]);
                    [].splice.apply(masterNodeList, [
                        newIndex,
                        0,
                        temp
                    ]);
                    newIndex = newIndex - 1;
                    currentIndex = currentIndex - 1;
                    var indexCompute = indexMap[currentIndex];
                    [].splice.apply(indexMap, [
                        currentIndex,
                        1
                    ]);
                    [].splice.apply(indexMap, [
                        newIndex,
                        0,
                        indexCompute
                    ]);
                    var i = Math.min(currentIndex, newIndex);
                    var len = indexMap.length;
                    for (i, len; i < len; i++) {
                        indexMap[i](i);
                    }
                    if (ev.callChildMutationCallback !== false) {
                        live.callChildMutationCallback(text.parentNode);
                    }
                }, text = el.ownerDocument.createTextNode(''), list, teardownList = function (fullTeardown) {
                    if (list && list.unbind) {
                        list.unbind('add', add).unbind('set', set).unbind('remove', remove).unbind('move', move);
                    }
                    remove({ callChildMutationCallback: !!fullTeardown }, { length: masterNodeList.length - 1 }, 0, true, fullTeardown);
                }, updateList = function (ev, newList, oldList) {
                    if (isTornDown) {
                        return;
                    }
                    afterPreviousEvents = true;
                    if (newList && oldList) {
                        list = newList || [];
                        var patches = diff(oldList, newList);
                        if (oldList.unbind) {
                            oldList.unbind('add', add).unbind('set', set).unbind('remove', remove).unbind('move', move);
                        }
                        for (var i = 0, patchLen = patches.length; i < patchLen; i++) {
                            var patch = patches[i];
                            if (patch.deleteCount) {
                                remove({ callChildMutationCallback: false }, { length: patch.deleteCount }, patch.index, true);
                            }
                            if (patch.insert.length) {
                                add({ callChildMutationCallback: false }, patch.insert, patch.index);
                            }
                        }
                    } else {
                        if (oldList) {
                            teardownList();
                        }
                        list = newList || [];
                        add({ callChildMutationCallback: false }, list, 0);
                        addFalseyIfEmpty(list, falseyRender, masterNodeList, nodeList);
                    }
                    live.callChildMutationCallback(text.parentNode);
                    afterPreviousEvents = false;
                    if (list.bind) {
                        list.bind('add', add).bind('set', set).bind('remove', remove).bind('move', move);
                    }
                    can.batch.afterPreviousEvents(function () {
                        afterPreviousEvents = true;
                    });
                };
            parentNode = elements.getParentNode(el, parentNode);
            var data = setup(parentNode, function () {
                if (can.isFunction(compute)) {
                    compute.bind('change', updateList);
                }
            }, function () {
                if (can.isFunction(compute)) {
                    compute.unbind('change', updateList);
                }
                teardownList(true);
            });
            if (!nodeList) {
                live.replace(masterNodeList, text, data.teardownCheck);
            } else {
                elements.replace(masterNodeList, text);
                nodeLists.update(masterNodeList, [text]);
                nodeList.unregistered = function () {
                    data.teardownCheck();
                    isTornDown = true;
                };
            }
            updateList({}, can.isFunction(compute) ? compute() : compute);
        },
        html: function (el, compute, parentNode, nodeList) {
            var data;
            parentNode = elements.getParentNode(el, parentNode);
            data = listen(parentNode, compute, function (ev, newVal, oldVal) {
                var attached = nodeLists.first(nodes).parentNode;
                if (attached) {
                    makeAndPut(newVal);
                }
                var pn = nodeLists.first(nodes).parentNode;
                data.teardownCheck(pn);
                live.callChildMutationCallback(pn);
            });
            var nodes = nodeList || [el], makeAndPut = function (val) {
                    var isFunction = typeof val === 'function', aNode = isNode(val), frag = can.frag(isFunction ? '' : val), oldNodes = can.makeArray(nodes);
                    addTextNodeIfNoChildren(frag);
                    if (!aNode && !isFunction) {
                        frag = can.view.hookup(frag, parentNode);
                    }
                    oldNodes = nodeLists.update(nodes, getChildNodes(frag));
                    if (isFunction) {
                        val(frag.firstChild);
                    }
                    elements.replace(oldNodes, frag);
                };
            data.nodeList = nodes;
            if (!nodeList) {
                nodeLists.register(nodes, data.teardownCheck);
            } else {
                nodeList.unregistered = data.teardownCheck;
            }
            makeAndPut(compute());
        },
        replace: function (nodes, val, teardown) {
            var oldNodes = nodes.slice(0), frag = can.frag(val);
            nodeLists.register(nodes, teardown);
            if (typeof val === 'string') {
                frag = can.view.hookup(frag, nodes[0].parentNode);
            }
            nodeLists.update(nodes, getChildNodes(frag));
            elements.replace(oldNodes, frag);
            return nodes;
        },
        text: function (el, compute, parentNode, nodeList) {
            var parent = elements.getParentNode(el, parentNode);
            var data = listen(parent, compute, function (ev, newVal, oldVal) {
                if (typeof node.nodeValue !== 'unknown') {
                    node.nodeValue = can.view.toStr(newVal);
                }
                data.teardownCheck(node.parentNode);
            });
            var node = el.ownerDocument.createTextNode(can.view.toStr(compute()));
            if (nodeList) {
                nodeList.unregistered = data.teardownCheck;
                data.nodeList = nodeList;
                nodeLists.update(nodeList, [node]);
                elements.replace([el], node);
            } else {
                data.nodeList = live.replace([el], node, data.teardownCheck);
            }
        },
        setAttributes: function (el, newVal) {
            var attrs = getAttributeParts(newVal);
            for (var name in attrs) {
                can.attr.set(el, name, attrs[name]);
            }
        },
        attributes: function (el, compute, currentValue) {
            var oldAttrs = {};
            var setAttrs = function (newVal) {
                var newAttrs = getAttributeParts(newVal), name;
                for (name in newAttrs) {
                    var newValue = newAttrs[name], oldValue = oldAttrs[name];
                    if (newValue !== oldValue) {
                        can.attr.set(el, name, newValue);
                    }
                    delete oldAttrs[name];
                }
                for (name in oldAttrs) {
                    elements.removeAttr(el, name);
                }
                oldAttrs = newAttrs;
            };
            listen(el, compute, function (ev, newVal) {
                setAttrs(newVal);
            });
            if (arguments.length >= 3) {
                oldAttrs = getAttributeParts(currentValue);
            } else {
                setAttrs(compute());
            }
        },
        attributePlaceholder: '__!!__',
        attributeReplace: /__!!__/g,
        attribute: function (el, attributeName, compute) {
            listen(el, compute, function (ev, newVal) {
                elements.setAttr(el, attributeName, hook.render());
            });
            var wrapped = can.$(el), hooks;
            hooks = can.data(wrapped, 'hooks');
            if (!hooks) {
                can.data(wrapped, 'hooks', hooks = {});
            }
            var attr = String(elements.getAttr(el, attributeName)), parts = attr.split(live.attributePlaceholder), goodParts = [], hook;
            goodParts.push(parts.shift(), parts.join(live.attributePlaceholder));
            if (hooks[attributeName]) {
                hooks[attributeName].computes.push(compute);
            } else {
                hooks[attributeName] = {
                    render: function () {
                        var i = 0, newAttr = attr ? attr.replace(live.attributeReplace, function () {
                                return elements.contentText(hook.computes[i++]());
                            }) : elements.contentText(hook.computes[i++]());
                        return newAttr;
                    },
                    computes: [compute],
                    batchNum: undefined
                };
            }
            hook = hooks[attributeName];
            goodParts.splice(1, 0, compute());
            elements.setAttr(el, attributeName, goodParts.join(''));
        },
        specialAttribute: function (el, attributeName, compute) {
            listen(el, compute, function (ev, newVal) {
                elements.setAttr(el, attributeName, getValue(newVal));
            });
            elements.setAttr(el, attributeName, getValue(compute()));
        },
        simpleAttribute: function (el, attributeName, compute) {
            listen(el, compute, function (ev, newVal) {
                elements.setAttr(el, attributeName, newVal);
            });
            elements.setAttr(el, attributeName, compute());
        }
    };
    live.attr = live.simpleAttribute;
    live.attrs = live.attributes;
    live.getAttributeParts = getAttributeParts;
    var newLine = /(\r|\n)+/g;
    var getValue = function (val) {
        var regexp = /^["'].*["']$/;
        val = val.replace(elements.attrReg, '').replace(newLine, '');
        return regexp.test(val) ? val.substr(1, val.length - 2) : val;
    };
    can.view.live = live;
    return live;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#view/render*/
swifty.define('can/render',[
    'can/view',
    'can/elements',
    'can/view/live',
    'can/util/string'
], function (can, elements, live) {
    var pendingHookups = [], tagChildren = function (tagName) {
            var newTag = elements.tagMap[tagName] || 'span';
            if (newTag === 'span') {
                return '@@!!@@';
            }
            return '<' + newTag + '>' + tagChildren(newTag) + '</' + newTag + '>';
        }, contentText = function (input, tag) {
            if (typeof input === 'string') {
                return input;
            }
            if (!input && input !== 0) {
                return '';
            }
            var hook = input.hookup && function (el, id) {
                input.hookup.call(input, el, id);
            } || typeof input === 'function' && input;
            if (hook) {
                if (tag) {
                    return '<' + tag + ' ' + can.view.hook(hook) + '></' + tag + '>';
                } else {
                    pendingHookups.push(hook);
                }
                return '';
            }
            return '' + input;
        }, contentEscape = function (txt, tag) {
            return typeof txt === 'string' || typeof txt === 'number' ? can.esc(txt) : contentText(txt, tag);
        }, withinTemplatedSectionWithinAnElement = false, emptyHandler = function () {
        };
    var lastHookups;
    can.extend(can.view, {
        live: live,
        setupLists: function () {
            var old = can.view.lists, data;
            can.view.lists = function (list, renderer) {
                data = {
                    list: list,
                    renderer: renderer
                };
                return Math.random();
            };
            return function () {
                can.view.lists = old;
                return data;
            };
        },
        getHooks: function () {
            var hooks = pendingHookups.slice(0);
            lastHookups = hooks;
            pendingHookups = [];
            return hooks;
        },
        onlytxt: function (self, func) {
            return contentEscape(func.call(self));
        },
        txt: function (escape, tagName, status, self, func) {
            var tag = elements.tagMap[tagName] || 'span', setupLiveBinding = false, value, listData, compute, unbind = emptyHandler, attributeName;
            if (withinTemplatedSectionWithinAnElement) {
                value = func.call(self);
            } else {
                if (typeof status === 'string' || status === 1) {
                    withinTemplatedSectionWithinAnElement = true;
                }
                var listTeardown = can.view.setupLists();
                unbind = function () {
                    compute.unbind('change', emptyHandler);
                };
                compute = can.compute(func, self, false);
                compute.bind('change', emptyHandler);
                listData = listTeardown();
                value = compute();
                withinTemplatedSectionWithinAnElement = false;
                setupLiveBinding = compute.computeInstance.hasDependencies;
            }
            if (listData) {
                unbind();
                return '<' + tag + can.view.hook(function (el, parentNode) {
                    live.list(el, listData.list, listData.renderer, self, parentNode);
                }) + '></' + tag + '>';
            }
            if (!setupLiveBinding || typeof value === 'function') {
                unbind();
                return (withinTemplatedSectionWithinAnElement || escape === 2 || !escape ? contentText : contentEscape)(value, status === 0 && tag);
            }
            var contentProp = elements.tagToContentPropMap[tagName];
            if (status === 0 && !contentProp) {
                var selfClosing = !!elements.selfClosingTags[tag];
                return '<' + tag + can.view.hook(escape && typeof value !== 'object' ? function (el, parentNode) {
                    live.text(el, compute, parentNode);
                    unbind();
                } : function (el, parentNode) {
                    live.html(el, compute, parentNode);
                    unbind();
                }) + (selfClosing ? '/>' : '>' + tagChildren(tag) + '</' + tag + '>');
            } else if (status === 1) {
                pendingHookups.push(function (el) {
                    live.attributes(el, compute, compute());
                    unbind();
                });
                return compute();
            } else if (escape === 2) {
                attributeName = status;
                pendingHookups.push(function (el) {
                    live.specialAttribute(el, attributeName, compute);
                    unbind();
                });
                return compute();
            } else {
                attributeName = status === 0 ? contentProp : status;
                (status === 0 ? lastHookups : pendingHookups).push(function (el) {
                    live.attribute(el, attributeName, compute);
                    unbind();
                });
                return live.attributePlaceholder;
            }
        }
    });
    return can;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#view/stache/utils*/
swifty.define('can/view/utils',[
    'can/util/library',
    'can/view/scope'
], function (can) {
    var Options = can.view.Options;
    return {
        isArrayLike: function (obj) {
            return obj && obj.splice && typeof obj.length === 'number';
        },
        isObserveLike: function (obj) {
            return obj instanceof can.Map || obj && !!obj._get;
        },
        emptyHandler: function () {
        },
        jsonParse: function (str) {
            if (str[0] === '\'') {
                return str.substr(1, str.length - 2);
            } else if (str === 'undefined') {
                return undefined;
            } else if (can.global.JSON) {
                return JSON.parse(str);
            } else {
                return eval('(' + str + ')');
            }
        },
        mixins: {
            last: function () {
                return this.stack[this.stack.length - 1];
            },
            add: function (chars) {
                this.last().add(chars);
            },
            subSectionDepth: function () {
                return this.stack.length - 1;
            }
        },
        convertToScopes: function (helperOptions, scope, options, nodeList, truthyRenderer, falseyRenderer) {
            if (truthyRenderer) {
                helperOptions.fn = this.makeRendererConvertScopes(truthyRenderer, scope, options, nodeList);
            }
            if (falseyRenderer) {
                helperOptions.inverse = this.makeRendererConvertScopes(falseyRenderer, scope, options, nodeList);
            }
        },
        makeRendererConvertScopes: function (renderer, parentScope, parentOptions, nodeList) {
            var rendererWithScope = function (ctx, opts, parentNodeList) {
                return renderer(ctx || parentScope, opts, parentNodeList);
            };
            return can.__notObserve(function (newScope, newOptions, parentNodeList) {
                if (newScope !== undefined && !(newScope instanceof can.view.Scope)) {
                    newScope = parentScope.add(newScope);
                }
                if (newOptions !== undefined && !(newOptions instanceof Options)) {
                    newOptions = parentOptions.add(newOptions);
                }
                var result = rendererWithScope(newScope, newOptions || parentOptions, parentNodeList || nodeList);
                return result;
            });
        },
        Options: Options
    };
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#view/stache/mustache_helpers*/
swifty.define('can/view/mustache_helpers',[
    'can/util/library',
    'can/view/utils',
    'can/view/live'
], function (can, utils, live) {
    live = live || can.view.live;
    var resolve = function (value) {
        if (utils.isObserveLike(value) && utils.isArrayLike(value) && value.attr('length')) {
            return value;
        } else if (can.isFunction(value)) {
            return value();
        } else {
            return value;
        }
    };
    var resolveHash = function (hash) {
        var params = {};
        for (var prop in hash) {
            var value = hash[prop];
            if (value && value.isComputed) {
                params[prop] = value();
            } else {
                params[prop] = value;
            }
        }
        return params;
    };
    var looksLikeOptions = function (options) {
        return options && typeof options.fn === 'function' && typeof options.inverse === 'function';
    };
    var helpers = {
        'each': function (items, options) {
            var resolved = resolve(items), result = [], keys, key, i;
            if (resolved instanceof can.List) {
                return function (el) {
                    var nodeList = [el];
                    nodeList.expression = 'live.list';
                    can.view.nodeLists.register(nodeList, null, options.nodeList, true);
                    can.view.nodeLists.update(options.nodeList, [el]);
                    var cb = function (item, index, parentNodeList) {
                        return options.fn(options.scope.add({
                            '%index': index,
                            '@index': index
                        }, { notContext: true }).add(item), options.options, parentNodeList);
                    };
                    live.list(el, items, cb, options.context, el.parentNode, nodeList, function (list, parentNodeList) {
                        return options.inverse(options.scope.add(list), options.options, parentNodeList);
                    });
                };
            }
            var expr = resolved;
            if (!!expr && utils.isArrayLike(expr)) {
                for (i = 0; i < expr.length; i++) {
                    result.push(options.fn(options.scope.add({
                        '%index': i,
                        '@index': i
                    }, { notContext: true }).add(expr[i])));
                }
            } else if (utils.isObserveLike(expr)) {
                keys = can.Map.keys(expr);
                for (i = 0; i < keys.length; i++) {
                    key = keys[i];
                    result.push(options.fn(options.scope.add({
                        '%key': key,
                        '@key': key
                    }, { notContext: true }).add(expr[key])));
                }
            } else if (expr instanceof Object) {
                for (key in expr) {
                    result.push(options.fn(options.scope.add({
                        '%key': key,
                        '@key': key
                    }, { notContext: true }).add(expr[key])));
                }
            }
            return result;
        },
        '@index': function (offset, options) {
            if (!options) {
                options = offset;
                offset = 0;
            }
            var index = options.scope.attr('@index');
            return '' + ((can.isFunction(index) ? index() : index) + offset);
        },
        'if': function (expr, options) {
            var value;
            if (can.isFunction(expr)) {
                value = can.compute.truthy(expr)();
            } else {
                value = !!resolve(expr);
            }
            if (value) {
                return options.fn(options.scope || this);
            } else {
                return options.inverse(options.scope || this);
            }
        },
        'is': function () {
            var lastValue, curValue, options = arguments[arguments.length - 1];
            if (arguments.length - 2 <= 0) {
                return options.inverse();
            }
            var args = arguments;
            var callFn = can.compute(function () {
                for (var i = 0; i < args.length - 1; i++) {
                    curValue = resolve(args[i]);
                    curValue = can.isFunction(curValue) ? curValue() : curValue;
                    if (i > 0) {
                        if (curValue !== lastValue) {
                            return false;
                        }
                    }
                    lastValue = curValue;
                }
                return true;
            });
            return callFn() ? options.fn() : options.inverse();
        },
        'eq': function () {
            return helpers.is.apply(this, arguments);
        },
        'unless': function (expr, options) {
            return helpers['if'].apply(this, [
                expr,
                can.extend({}, options, {
                    fn: options.inverse,
                    inverse: options.fn
                })
            ]);
        },
        'with': function (expr, options) {
            var ctx = expr;
            expr = resolve(expr);
            if (!!expr) {
                return options.fn(ctx);
            }
        },
        'log': function (expr, options) {
            if (typeof console !== 'undefined' && console.log) {
                if (!options) {
                    console.log(expr.context);
                } else {
                    console.log(expr, options.context);
                }
            }
        },
        'data': function (attr) {
            var data = arguments.length === 2 ? this : arguments[1];
            return function (el) {
                can.data(can.$(el), attr, data || this.context);
            };
        },
        'switch': function (expression, options) {
            resolve(expression);
            var found = false;
            var newOptions = options.helpers.add({
                'case': function (value, options) {
                    if (!found && resolve(expression) === resolve(value)) {
                        found = true;
                        return options.fn(options.scope || this);
                    }
                },
                'default': function (options) {
                    if (!found) {
                        return options.fn(options.scope || this);
                    }
                }
            });
            return options.fn(options.scope, newOptions);
        },
        'joinBase': function (firstExpr) {
            var args = [].slice.call(arguments);
            var options = args.pop();
            var moduleReference = can.map(args, function (expr) {
                var value = resolve(expr);
                return can.isFunction(value) ? value() : value;
            }).join('');
            var templateModule = options.helpers.attr('helpers.module');
            var parentAddress = templateModule ? templateModule.uri : undefined;
            var isRelative = moduleReference[0] === '.';
            if (isRelative && parentAddress) {
                return can.joinURIs(parentAddress, moduleReference);
            } else {
                var baseURL = can.baseURL || typeof System !== 'undefined' && (System.renderingLoader && System.renderingLoader.baseURL || System.baseURL) || location.pathname;
                if (moduleReference[0] !== '/' && baseURL[baseURL.length - 1] !== '/') {
                    baseURL += '/';
                }
                return can.joinURIs(baseURL, moduleReference);
            }
        },
        routeUrl: function (params, merge) {
            if (!params) {
                params = {};
            }
            if (typeof params.fn === 'function' && typeof params.inverse === 'function') {
                params = resolveHash(params.hash);
            }
            return can.route.url(params, typeof merge === 'boolean' ? merge : undefined);
        },
        routeCurrent: function (params) {
            var last = can.last(arguments), isOptions = last && looksLikeOptions(last);
            if (last && isOptions && !(last.exprData instanceof can.expression.Call)) {
                if (can.route.current(resolveHash(params.hash || {}))) {
                    return params.fn();
                } else {
                    return params.inverse();
                }
            } else {
                return can.route.current(looksLikeOptions(params) ? {} : params || {});
            }
        }
    };
    helpers.routeCurrent.callAsMethod = true;
    helpers.eachOf = helpers.each;
    var registerHelper = function (name, callback) {
        helpers[name] = callback;
    };
    return {
        registerHelper: registerHelper,
        registerSimpleHelper: function (name, callback) {
            registerHelper(name, can.view.simpleHelper(callback));
        },
        getHelper: function (name, options) {
            var helper = options && options.get('helpers.' + name, { proxyMethods: false });
            if (!helper) {
                helper = helpers[name];
            }
            if (helper) {
                return { fn: helper };
            }
        }
    };
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#view/stache/expression*/
swifty.define('can/view/expression',[
    'can/util/library',
    'can/view/utils',
    'can/view/mustache_helpers',
    'can/view/scope'
], function (can, utils, mustacheHelpers, Scope) {
    var getKeyComputeData = function (key, scope, readOptions) {
            var data = scope.computeData(key, readOptions);
            can.compute.temporarilyBind(data.compute);
            return data;
        }, lookupValue = function (key, scope, helperOptions, readOptions) {
            var computeData = getKeyComputeData(key, scope, readOptions);
            if (!computeData.compute.computeInstance.hasDependencies) {
                return {
                    value: computeData.initialValue,
                    computeData: computeData
                };
            } else {
                return {
                    value: computeData.compute,
                    computeData: computeData
                };
            }
        }, lookupValueOrHelper = function (key, scope, helperOptions, readOptions) {
            var res = lookupValue(key, scope, helperOptions, readOptions);
            if (res.computeData.initialValue === undefined) {
                if (key.charAt(0) === '@' && key !== '@index') {
                    key = key.substr(1);
                }
                var helper = mustacheHelpers.getHelper(key, helperOptions);
                res.helper = helper && helper.fn;
            }
            return res;
        }, convertToArgExpression = function (expr) {
            if (!(expr instanceof Arg) && !(expr instanceof Literal) && !(expr instanceof Hashes)) {
                return new Arg(expr);
            } else {
                return expr;
            }
        };
    var Literal = function (value) {
        this._value = value;
    };
    Literal.prototype.value = function () {
        return this._value;
    };
    var Lookup = function (key, root) {
        this.key = key;
        this.rootExpr = root;
    };
    Lookup.prototype.value = function (scope, helperOptions) {
        var result = lookupValueOrHelper(this.key, scope, helperOptions);
        this.isHelper = result.helper && !result.helper.callAsMethod;
        return result.helper || result.value;
    };
    var ScopeLookup = function (key, root) {
        Lookup.apply(this, arguments);
    };
    ScopeLookup.prototype.value = function (scope, helperOptions) {
        return lookupValue(this.key, scope, helperOptions).value;
    };
    var Arg = function (expression, modifiers) {
        this.expr = expression;
        this.modifiers = modifiers || {};
        this.isCompute = false;
    };
    Arg.prototype.value = function () {
        return this.expr.value.apply(this.expr, arguments);
    };
    var Hashes = function (hashExpressions) {
        this.hashExprs = hashExpressions;
    };
    Hashes.prototype.value = function () {
        var hash = {};
        for (var prop in this.hashExprs) {
            var val = this.hashExprs[prop], value = val.value.apply(val, arguments);
            hash[prop] = {
                call: value && value.isComputed && (!val.modifiers || !val.modifiers.compute),
                value: value
            };
        }
        return can.compute(function () {
            var finalHash = {};
            for (var prop in hash) {
                finalHash[prop] = hash[prop].call ? hash[prop].value() : hash[prop].value;
            }
            return finalHash;
        });
    };
    var Call = function (methodExpression, argExpressions, hashes) {
        if (hashes && !can.isEmptyObject(hashes)) {
            argExpressions.push(new Hashes(hashes));
        }
        this.methodExpr = methodExpression;
        this.argExprs = can.map(argExpressions, convertToArgExpression);
    };
    Call.prototype.args = function (scope, helperOptions) {
        var args = [];
        for (var i = 0, len = this.argExprs.length; i < len; i++) {
            var arg = this.argExprs[i];
            var value = arg.value.apply(arg, arguments);
            args.push({
                call: value && value.isComputed && (!arg.modifiers || !arg.modifiers.compute),
                value: value
            });
        }
        return function () {
            var finalArgs = [];
            for (var i = 0, len = args.length; i < len; i++) {
                finalArgs[i] = args[i].call ? args[i].value() : args[i].value;
            }
            return finalArgs;
        };
    };
    Call.prototype.value = function (scope, helperScope, helperOptions) {
        var method = this.methodExpr.value(scope, helperScope);
        this.isHelper = this.methodExpr.isHelper;
        var getArgs = this.args(scope, helperScope);
        return can.compute(function (newVal) {
            var func = method;
            if (func && func.isComputed) {
                func = func();
            }
            if (typeof func === 'function') {
                var args = getArgs();
                if (helperOptions) {
                    args.push(helperOptions);
                }
                if (arguments.length) {
                    args.unshift(new expression.SetIdentifier(newVal));
                }
                return func.apply(null, args);
            }
        });
    };
    var HelperLookup = function () {
        Lookup.apply(this, arguments);
    };
    HelperLookup.prototype.value = function (scope, helperOptions) {
        var result = lookupValueOrHelper(this.key, scope, helperOptions, {
            isArgument: true,
            args: [
                scope.attr('.'),
                scope
            ]
        });
        return result.helper || result.value;
    };
    var HelperScopeLookup = function () {
        Lookup.apply(this, arguments);
    };
    HelperScopeLookup.prototype.value = function (scope, helperOptions) {
        return lookupValue(this.key, scope, helperOptions, {
            callMethodsOnObservables: true,
            isArgument: true,
            args: [
                scope.attr('.'),
                scope
            ]
        }).value;
    };
    var Helper = function (methodExpression, argExpressions, hashExpressions) {
        this.methodExpr = methodExpression;
        this.argExprs = argExpressions;
        this.hashExprs = hashExpressions;
        this.mode = null;
    };
    Helper.prototype.args = function (scope, helperOptions) {
        var args = [];
        for (var i = 0, len = this.argExprs.length; i < len; i++) {
            var arg = this.argExprs[i];
            args.push(arg.value.apply(arg, arguments));
        }
        return args;
    };
    Helper.prototype.hash = function (scope, helperOptions) {
        var hash = {};
        for (var prop in this.hashExprs) {
            var val = this.hashExprs[prop];
            hash[prop] = val.value.apply(val, arguments);
        }
        return hash;
    };
    Helper.prototype.helperAndValue = function (scope, helperOptions) {
        var looksLikeAHelper = this.argExprs.length || !can.isEmptyObject(this.hashExprs), helper, value, methodKey = this.methodExpr instanceof Literal ? '' + this.methodExpr._value : this.methodExpr.key, initialValue, args;
        if (looksLikeAHelper) {
            helper = mustacheHelpers.getHelper(methodKey, helperOptions);
            var context = scope.attr('.');
            if (!helper && typeof context[methodKey] === 'function') {
                helper = { fn: context[methodKey] };
            }
        }
        if (!helper) {
            args = this.args(scope, helperOptions);
            var computeData = getKeyComputeData(methodKey, scope, {
                    isArgument: false,
                    args: args && args.length ? args : [
                        scope.attr('.'),
                        scope
                    ]
                }), compute = computeData.compute;
            initialValue = computeData.initialValue;
            if (computeData.compute.computeInstance.hasDependencies) {
                value = compute;
            } else {
                value = initialValue;
            }
            if (!looksLikeAHelper && initialValue === undefined) {
                helper = mustacheHelpers.getHelper(methodKey, helperOptions);
            }
        }
        return {
            value: value,
            args: args,
            helper: helper && helper.fn
        };
    };
    Helper.prototype.evaluator = function (helper, scope, helperOptions, readOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly) {
        var helperOptionArg = {
                fn: function () {
                },
                inverse: function () {
                }
            }, context = scope.attr('.'), args = this.args(scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly), hash = this.hash(scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
        utils.convertToScopes(helperOptionArg, scope, helperOptions, nodeList, truthyRenderer, falseyRenderer);
        can.simpleExtend(helperOptionArg, {
            context: context,
            scope: scope,
            contexts: scope,
            hash: hash,
            nodeList: nodeList,
            exprData: this,
            helperOptions: helperOptions,
            helpers: helperOptions
        });
        args.push(helperOptionArg);
        return function () {
            return helper.apply(context, args);
        };
    };
    Helper.prototype.value = function (scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly) {
        var helperAndValue = this.helperAndValue(scope, helperOptions);
        var helper = helperAndValue.helper;
        if (!helper) {
            return helperAndValue.value;
        }
        var fn = this.evaluator(helper, scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
        var compute = can.compute(fn);
        can.compute.temporarilyBind(compute);
        if (!compute.computeInstance.hasDependencies) {
            return compute();
        } else {
            return compute;
        }
    };
    var keyRegExp = /[\w\.\\\-_@\/\&%]+/, tokensRegExp = /('.*?'|".*?"|=|[\w\.\\\-_@\/*%\$]+|[\(\)]|,|\~)/g, literalRegExp = /^('.*?'|".*?"|[0-9]+\.?[0-9]*|true|false|null|undefined)$/;
    var isTokenKey = function (token) {
        return keyRegExp.test(token);
    };
    var testDot = /^[\.@]\w/;
    var isAddingToExpression = function (token) {
        return isTokenKey(token) && testDot.test(token);
    };
    var ensureChildren = function (type) {
        if (!type.children) {
            type.children = [];
        }
        return type;
    };
    var Stack = function () {
        this.root = {
            children: [],
            type: 'Root'
        };
        this.current = this.root;
        this.stack = [this.root];
    };
    can.simpleExtend(Stack.prototype, {
        top: function () {
            return can.last(this.stack);
        },
        isRootTop: function () {
            return this.top() === this.root;
        },
        popTo: function (types) {
            this.popUntil(types);
            if (!this.isRootTop()) {
                this.stack.pop();
            }
        },
        firstParent: function (types) {
            var curIndex = this.stack.length - 2;
            while (curIndex > 0 && can.inArray(this.stack[curIndex].type, types) === -1) {
                curIndex--;
            }
            return this.stack[curIndex];
        },
        popUntil: function (types) {
            while (can.inArray(this.top().type, types) === -1 && !this.isRootTop()) {
                this.stack.pop();
            }
            return this.top();
        },
        addTo: function (types, type) {
            var cur = this.popUntil(types);
            ensureChildren(cur).children.push(type);
        },
        addToAndPush: function (types, type) {
            this.addTo(types, type);
            this.stack.push(type);
        },
        topLastChild: function () {
            return can.last(this.top().children);
        },
        replaceTopLastChild: function (type) {
            var children = ensureChildren(this.top()).children;
            children.pop();
            children.push(type);
            return type;
        },
        replaceTopLastChildAndPush: function (type) {
            this.replaceTopLastChild(type);
            this.stack.push(type);
        },
        replaceTopAndPush: function (type) {
            var children;
            if (this.top() === this.root) {
                children = ensureChildren(this.top()).children;
            } else {
                this.stack.pop();
                children = ensureChildren(this.top()).children;
            }
            children.pop();
            children.push(type);
            this.stack.push(type);
            return type;
        }
    });
    var convertKeyToLookup = function (key) {
        var lastPath = key.lastIndexOf('./');
        var lastDot = key.lastIndexOf('.');
        if (lastDot > lastPath) {
            return key.substr(0, lastDot) + '@' + key.substr(lastDot + 1);
        }
        var firstNonPathCharIndex = lastPath === -1 ? 0 : lastPath + 2;
        var firstNonPathChar = key.charAt(firstNonPathCharIndex);
        if (firstNonPathChar === '.' || firstNonPathChar === '@') {
            return key.substr(0, firstNonPathCharIndex) + '@' + key.substr(firstNonPathCharIndex + 1);
        } else {
            return key.substr(0, firstNonPathCharIndex) + '@' + key.substr(firstNonPathCharIndex);
        }
    };
    var convertToAtLookup = function (ast) {
        if (ast.type === 'Lookup') {
            ast.key = convertKeyToLookup(ast.key);
        }
        return ast;
    };
    var convertToHelperIfTopIsLookup = function (stack) {
        var top = stack.top();
        if (top && top.type === 'Lookup') {
            var base = stack.stack[stack.stack.length - 2];
            if (base.type !== 'Helper' && base) {
                stack.replaceTopAndPush({
                    type: 'Helper',
                    method: top
                });
            }
        }
    };
    var expression = {
        convertKeyToLookup: convertKeyToLookup,
        Literal: Literal,
        Lookup: Lookup,
        ScopeLookup: ScopeLookup,
        Arg: Arg,
        Hashes: Hashes,
        Call: Call,
        Helper: Helper,
        HelperLookup: HelperLookup,
        HelperScopeLookup: HelperScopeLookup,
        SetIdentifier: function (value) {
            this.value = value;
        },
        tokenize: function (expression) {
            var tokens = [];
            (can.trim(expression) + ' ').replace(tokensRegExp, function (whole, arg) {
                tokens.push(arg);
            });
            return tokens;
        },
        lookupRules: {
            'default': function (ast, methodType, isArg) {
                var name = (methodType === 'Helper' && !ast.root ? 'Helper' : '') + (isArg ? 'Scope' : '') + 'Lookup';
                return expression[name];
            },
            'method': function (ast, methodType, isArg) {
                return ScopeLookup;
            }
        },
        methodRules: {
            'default': function (ast) {
                return ast.type === 'Call' ? Call : Helper;
            },
            'call': function (ast) {
                return Call;
            }
        },
        parse: function (expressionString, options) {
            options = options || {};
            var ast = this.ast(expressionString);
            if (!options.lookupRule) {
                options.lookupRule = 'default';
            }
            if (typeof options.lookupRule === 'string') {
                options.lookupRule = expression.lookupRules[options.lookupRule];
            }
            if (!options.methodRule) {
                options.methodRule = 'default';
            }
            if (typeof options.methodRule === 'string') {
                options.methodRule = expression.methodRules[options.methodRule];
            }
            var expr = this.hydrateAst(ast, options, options.baseMethodType || 'Helper');
            return expr;
        },
        hydrateAst: function (ast, options, methodType, isArg) {
            var hashes, self = this;
            if (ast.type === 'Lookup') {
                return new (options.lookupRule(ast, methodType, isArg))(ast.key, ast.root && this.hydrateAst(ast.root, options, methodType));
            } else if (ast.type === 'Literal') {
                return new Literal(ast.value);
            } else if (ast.type === 'Arg') {
                return new Arg(this.hydrateAst(ast.children[0], options, methodType, isArg), { compute: true });
            } else if (ast.type === 'Hashes') {
                hashes = {};
                can.each(ast.children, function (child) {
                    hashes[child.prop] = self.hydrateAst(child.children[0], options, ast.type, true);
                });
                return new Hashes(hashes);
            } else if (ast.type === 'Hash') {
                throw new Error('');
            } else if (ast.type === 'Call' || ast.type === 'Helper') {
                var args = [];
                hashes = {};
                can.each(ast.children, function (child) {
                    if (child.type === 'Hash') {
                        hashes[child.prop] = self.hydrateAst(child.children[0], options, ast.type, true);
                    } else {
                        args.push(self.hydrateAst(child, options, ast.type, true));
                    }
                });
                return new (options.methodRule(ast))(this.hydrateAst(ast.method, options, ast.type), args, hashes);
            }
        },
        ast: function (expression) {
            var tokens = this.tokenize(expression);
            return this.parseAst(tokens, { index: 0 });
        },
        parseAst: function (tokens, cursor) {
            var stack = new Stack(), top;
            while (cursor.index < tokens.length) {
                var token = tokens[cursor.index], nextToken = tokens[cursor.index + 1];
                cursor.index++;
                if (literalRegExp.test(token)) {
                    convertToHelperIfTopIsLookup(stack);
                    stack.addTo([
                        'Helper',
                        'Call',
                        'Hash'
                    ], {
                        type: 'Literal',
                        value: utils.jsonParse(token)
                    });
                } else if (nextToken === '=') {
                    top = stack.top();
                    if (top && top.type === 'Lookup') {
                        var firstParent = stack.firstParent([
                            'Call',
                            'Helper',
                            'Hash'
                        ]);
                        if (firstParent.type === 'Call' || firstParent.type === 'Root') {
                            stack.popUntil(['Call']);
                            top = stack.top();
                            stack.replaceTopAndPush({
                                type: 'Helper',
                                method: top.type === 'Root' ? can.last(top.children) : top
                            });
                        }
                    }
                    top = stack.popUntil([
                        'Helper',
                        'Call',
                        'Hashes'
                    ]);
                    if (top.type === 'Call') {
                        stack.addToAndPush(['Call'], { type: 'Hashes' });
                    }
                    stack.addToAndPush([
                        'Helper',
                        'Hashes'
                    ], {
                        type: 'Hash',
                        prop: token
                    });
                    cursor.index++;
                } else if (keyRegExp.test(token)) {
                    var last = stack.topLastChild();
                    if (last && last.type === 'Call' && isAddingToExpression(token)) {
                        stack.replaceTopLastChildAndPush({
                            type: 'Lookup',
                            root: last,
                            key: token
                        });
                    } else {
                        convertToHelperIfTopIsLookup(stack);
                        stack.addToAndPush([
                            'Helper',
                            'Call',
                            'Hash',
                            'Arg'
                        ], {
                            type: 'Lookup',
                            key: token
                        });
                    }
                } else if (token === '~') {
                    convertToHelperIfTopIsLookup(stack);
                    stack.addToAndPush([
                        'Helper',
                        'Call',
                        'Hash'
                    ], {
                        type: 'Arg',
                        key: token
                    });
                } else if (token === '(') {
                    top = stack.top();
                    if (top.type === 'Lookup') {
                        stack.replaceTopAndPush({
                            type: 'Call',
                            method: convertToAtLookup(top)
                        });
                    } else {
                        throw new Error('Unable to understand expression ' + tokens.join(''));
                    }
                } else if (token === ')') {
                    stack.popTo(['Call']);
                } else if (token === ',') {
                    stack.popUntil(['Call']);
                }
            }
            return stack.root.children[0];
        }
    };
    can.expression = expression;
    return expression;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#view/href/href*/
swifty.define('can/view/href',[
    'can/util/library',
    'can/view/expression',
    'can/view/callbacks',
    'can/view/scope'
], function (can, expression) {
    var removeCurly = function (value) {
        if (value[0] === '{' && value[value.length - 1] === '}') {
            return value.substr(1, value.length - 2);
        }
        return value;
    };
    can.view.attr('can-href', function (el, attrData) {
        var attrInfo = expression.parse('tmp(' + removeCurly(el.getAttribute('can-href')) + ')', { baseMethodType: 'Call' });
        var getHash = attrInfo.argExprs[0].value(attrData.scope, null);
        var routeHref = can.compute(function () {
            return can.route.url(getHash());
        });
        el.setAttribute('href', routeHref());
        var handler = function (ev, newVal) {
            el.setAttribute('href', newVal);
        };
        routeHref.bind('change', handler);
        can.bind.call(el, 'removed', function () {
            routeHref.unbind('change', handler);
        });
    });
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#view/bindings/bindings*/
swifty.define('can/view/bindings',[
    'can/util/library',
    'can/view/expression',
    'can/view/callbacks',
    'can/view/live',
    'can/view/scope',
    'can/view/href'
], function (can, expression, viewCallbacks, live) {
    var behaviors = {
        viewModel: function (el, tagData, makeViewModel, initialViewModelData) {
            initialViewModelData = initialViewModelData || {};
            var bindingsSemaphore = {}, viewModel, onCompleteBindings = [], onTeardowns = {}, bindingInfos = {}, attributeViewModelBindings = can.extend({}, initialViewModelData);
            can.each(can.makeArray(el.attributes), function (node) {
                var dataBinding = makeDataBinding(node, el, {
                    templateType: tagData.templateType,
                    scope: tagData.scope,
                    semaphore: bindingsSemaphore,
                    getViewModel: function () {
                        return viewModel;
                    },
                    attributeViewModelBindings: attributeViewModelBindings,
                    alreadyUpdatedChild: true,
                    nodeList: tagData.parentNodeList
                });
                if (dataBinding) {
                    if (dataBinding.onCompleteBinding) {
                        if (dataBinding.bindingInfo.parentToChild && dataBinding.value !== undefined) {
                            initialViewModelData[cleanVMName(dataBinding.bindingInfo.childName)] = dataBinding.value;
                        }
                        onCompleteBindings.push(dataBinding.onCompleteBinding);
                    }
                    onTeardowns[node.name] = dataBinding.onTeardown;
                }
            });
            viewModel = makeViewModel(initialViewModelData);
            for (var i = 0, len = onCompleteBindings.length; i < len; i++) {
                onCompleteBindings[i]();
            }
            can.bind.call(el, 'attributes', function (ev) {
                var attrName = ev.attributeName, value = el.getAttribute(attrName);
                if (onTeardowns[attrName]) {
                    onTeardowns[attrName]();
                }
                var parentBindingWasAttribute = bindingInfos[attrName] && bindingInfos[attrName].parent === 'attribute';
                if (value !== null || parentBindingWasAttribute) {
                    var dataBinding = makeDataBinding({
                        name: attrName,
                        value: value
                    }, el, {
                        templateType: tagData.templateType,
                        scope: tagData.scope,
                        semaphore: {},
                        getViewModel: function () {
                            return viewModel;
                        },
                        attributeViewModelBindings: attributeViewModelBindings,
                        initializeValues: true,
                        nodeList: tagData.parentNodeList
                    });
                    if (dataBinding) {
                        if (dataBinding.onCompleteBinding) {
                            dataBinding.onCompleteBinding();
                        }
                        bindingInfos[attrName] = dataBinding.bindingInfo;
                        onTeardowns[attrName] = dataBinding.onTeardown;
                    }
                }
            });
            return function () {
                for (var attrName in onTeardowns) {
                    onTeardowns[attrName]();
                }
            };
        },
        data: function (el, attrData) {
            if (can.data(can.$(el), 'preventDataBindings')) {
                return;
            }
            var viewModel = can.viewModel(el), semaphore = {}, teardown;
            var dataBinding = makeDataBinding({
                name: attrData.attributeName,
                value: el.getAttribute(attrData.attributeName),
                nodeList: attrData.nodeList
            }, el, {
                templateType: attrData.templateType,
                scope: attrData.scope,
                semaphore: semaphore,
                getViewModel: function () {
                    return viewModel;
                }
            });
            if (dataBinding.onCompleteBinding) {
                dataBinding.onCompleteBinding();
            }
            teardown = dataBinding.onTeardown;
            can.one.call(el, 'removed', function () {
                teardown();
            });
            can.bind.call(el, 'attributes', function (ev) {
                var attrName = ev.attributeName, value = el.getAttribute(attrName);
                if (attrName === attrData.attributeName) {
                    if (teardown) {
                        teardown();
                    }
                    if (value !== null) {
                        var dataBinding = makeDataBinding({
                            name: attrName,
                            value: value
                        }, el, {
                            templateType: attrData.templateType,
                            scope: attrData.scope,
                            semaphore: semaphore,
                            getViewModel: function () {
                                return viewModel;
                            },
                            initializeValues: true,
                            nodeList: attrData.nodeList
                        });
                        if (dataBinding) {
                            if (dataBinding.onCompleteBinding) {
                                dataBinding.onCompleteBinding();
                            }
                            teardown = dataBinding.onTeardown;
                        }
                    }
                }
            });
        },
        reference: function (el, attrData) {
            if (el.getAttribute(attrData.attributeName)) {
                console.warn('*reference attributes can only export the view model.');
            }
            var name = can.camelize(attrData.attributeName.substr(1).toLowerCase());
            var viewModel = can.viewModel(el);
            var refs = attrData.scope.getRefs();
            refs._context.attr('*' + name, viewModel);
        },
        event: function (el, data) {
            var attributeName = data.attributeName, legacyBinding = attributeName.indexOf('can-') === 0, event = attributeName.indexOf('can-') === 0 ? attributeName.substr('can-'.length) : removeBrackets(attributeName, '(', ')'), onBindElement = legacyBinding;
            if (event.charAt(0) === '$') {
                event = event.substr(1);
                onBindElement = true;
            }
            var handler = function (ev) {
                var attrVal = el.getAttribute(attributeName);
                if (!attrVal) {
                    return;
                }
                var $el = can.$(el), viewModel = can.viewModel($el[0]);
                var expr = expression.parse(removeBrackets(attrVal), {
                    lookupRule: 'method',
                    methodRule: 'call'
                });
                if (!(expr instanceof expression.Call) && !(expr instanceof expression.Helper)) {
                    var defaultArgs = can.map([
                        data.scope._context,
                        $el
                    ].concat(can.makeArray(arguments)), function (data) {
                        return new expression.Literal(data);
                    });
                    expr = new expression.Call(expr, defaultArgs, {});
                }
                var scopeData = data.scope.read(expr.methodExpr.key, { isArgument: true });
                if (!scopeData.value) {
                    scopeData = data.scope.read(expr.methodExpr.key, { isArgument: true });
                    return null;
                }
                var localScope = data.scope.add({
                    '@element': $el,
                    '@event': ev,
                    '@viewModel': viewModel,
                    '@scope': data.scope,
                    '@context': data.scope._context,
                    '%element': this,
                    '$element': $el,
                    '%event': ev,
                    '%viewModel': viewModel,
                    '%scope': data.scope,
                    '%context': data.scope._context
                }, { notContext: true });
                var args = expr.args(localScope, null)();
                return scopeData.value.apply(scopeData.parent, args);
            };
            if (special[event]) {
                var specialData = special[event](data, el, handler);
                handler = specialData.handler;
                event = specialData.event;
            }
            can.bind.call(onBindElement ? el : can.viewModel(el), event, handler);
            var attributesHandler = function (ev) {
                if (ev.attributeName === attributeName && !this.getAttribute(attributeName)) {
                    can.unbind.call(onBindElement ? el : can.viewModel(el), event, handler);
                    can.unbind.call(el, 'attributes', attributesHandler);
                }
            };
            can.bind.call(el, 'attributes', attributesHandler);
        },
        value: function (el, data) {
            var propName = '$value', attrValue = can.trim(removeBrackets(el.getAttribute('can-value'))), getterSetter;
            if (el.nodeName.toLowerCase() === 'input' && (el.type === 'checkbox' || el.type === 'radio')) {
                var property = getComputeFrom.scope(el, data.scope, attrValue, {}, true);
                if (el.type === 'checkbox') {
                    var trueValue = can.attr.has(el, 'can-true-value') ? el.getAttribute('can-true-value') : true, falseValue = can.attr.has(el, 'can-false-value') ? el.getAttribute('can-false-value') : false;
                    getterSetter = can.compute(function (newValue) {
                        if (arguments.length) {
                            property(newValue ? trueValue : falseValue);
                        } else {
                            return property() == trueValue;
                        }
                    });
                } else if (el.type === 'radio') {
                    getterSetter = can.compute(function (newValue) {
                        if (arguments.length) {
                            if (newValue) {
                                property(el.value);
                            }
                        } else {
                            return property() == el.value;
                        }
                    });
                }
                propName = '$checked';
                attrValue = 'getterSetter';
                data.scope = new can.view.Scope({ getterSetter: getterSetter });
            } else if (isContentEditable(el)) {
                propName = '$innerHTML';
            }
            var dataBinding = makeDataBinding({
                name: '{(' + propName + '})',
                value: attrValue
            }, el, {
                templateType: data.templateType,
                scope: data.scope,
                semaphore: {},
                initializeValues: true,
                legacyBindings: true,
                syncChildWithParent: true
            });
            can.one.call(el, 'removed', function () {
                dataBinding.onTeardown();
            });
        }
    };
    can.view.attr(/^\{[^\}]+\}$/, behaviors.data);
    can.view.attr(/\*[\w\.\-_]+/, behaviors.reference);
    can.view.attr(/^\([\$?\w\.]+\)$/, behaviors.event);
    can.view.attr(/can-[\w\.]+/, behaviors.event);
    can.view.attr('can-value', behaviors.value);
    var getComputeFrom = {
        scope: function (el, scope, scopeProp, bindingData, mustBeACompute, stickyCompute) {
            if (!scopeProp) {
                return can.compute();
            } else {
                if (mustBeACompute) {
                    var parentExpression = expression.parse(scopeProp, { baseMethodType: 'Call' });
                    return parentExpression.value(scope, new can.view.Options({}));
                } else {
                    return function (newVal) {
                        scope.attr(cleanVMName(scopeProp), newVal);
                    };
                }
            }
        },
        viewModel: function (el, scope, vmName, bindingData, mustBeACompute, stickyCompute) {
            var setName = cleanVMName(vmName);
            if (mustBeACompute) {
                return can.compute(function (newVal) {
                    var viewModel = bindingData.getViewModel();
                    if (arguments.length) {
                        viewModel.attr(setName, newVal);
                    } else {
                        return vmName === '.' ? viewModel : can.compute.read(viewModel, can.compute.read.reads(vmName), {}).value;
                    }
                });
            } else {
                return function (newVal) {
                    bindingData.getViewModel().attr(setName, newVal);
                };
            }
        },
        attribute: function (el, scope, prop, bindingData, mustBeACompute, stickyCompute, event) {
            var hasChildren = el.nodeName.toLowerCase() === 'select', isMultiselectValue = prop === 'value' && hasChildren && el.multiple, isStringValue, lastSet, scheduledAsyncSet = false, timer, parentEvents, originalValue;
            if (!event) {
                if (prop === 'innerHTML') {
                    event = [
                        'blur',
                        'change'
                    ];
                } else {
                    event = 'change';
                }
            }
            if (!can.isArray(event)) {
                event = [event];
            }
            var set = function (newVal) {
                    if (hasChildren && !scheduledAsyncSet) {
                        clearTimeout(timer);
                        timer = setTimeout(function () {
                            set(newVal);
                        }, 1);
                    }
                    lastSet = newVal;
                    if (isMultiselectValue) {
                        if (newVal && typeof newVal === 'string') {
                            newVal = newVal.split(';');
                            isStringValue = true;
                        } else if (newVal) {
                            newVal = can.makeArray(newVal);
                        } else {
                            newVal = [];
                        }
                        var isSelected = {};
                        can.each(newVal, function (val) {
                            isSelected[val] = true;
                        });
                        can.each(el.childNodes, function (option) {
                            if (option.value) {
                                option.selected = !!isSelected[option.value];
                            }
                        });
                    } else {
                        if (!bindingData.legacyBindings && hasChildren && 'selectedIndex' in el && prop === 'value') {
                            can.attr.setSelectValue(el, newVal);
                        } else {
                            can.attr.setAttrOrProp(el, prop, newVal == null ? '' : newVal);
                        }
                    }
                    return newVal;
                }, get = function () {
                    if (isMultiselectValue) {
                        var values = [], children = el.childNodes;
                        can.each(children, function (child) {
                            if (child.selected && child.value) {
                                values.push(child.value);
                            }
                        });
                        return isStringValue ? values.join(';') : values;
                    } else if (hasChildren && 'selectedIndex' in el && el.selectedIndex === -1) {
                        return undefined;
                    }
                    return can.attr.get(el, prop);
                };
            if (hasChildren) {
                setTimeout(function () {
                    scheduledAsyncSet = true;
                }, 1);
            }
            if (el.tagName && el.tagName.toLowerCase() === 'input' && el.form) {
                parentEvents = [{
                        el: el.form,
                        eventName: 'reset',
                        handler: function () {
                            set(originalValue);
                        }
                    }];
            }
            var observer;
            originalValue = get();
            return can.compute(originalValue, {
                on: function (updater) {
                    can.each(event, function (eventName) {
                        can.bind.call(el, eventName, updater);
                    });
                    can.each(parentEvents, function (parentEvent) {
                        can.bind.call(parentEvent.el, parentEvent.eventName, parentEvent.handler);
                    });
                    if (hasChildren) {
                        var onMutation = function (mutations) {
                            if (stickyCompute) {
                                set(stickyCompute());
                            }
                            updater();
                        };
                        if (can.attr.MutationObserver) {
                            observer = new can.attr.MutationObserver(onMutation);
                            observer.observe(el, {
                                childList: true,
                                subtree: true
                            });
                        } else {
                            can.data(can.$(el), 'canBindingCallback', { onMutation: onMutation });
                        }
                    }
                },
                off: function (updater) {
                    can.each(event, function (eventName) {
                        can.unbind.call(el, eventName, updater);
                    });
                    can.each(parentEvents, function (parentEvent) {
                        can.unbind.call(parentEvent.el, parentEvent.eventName, parentEvent.handler);
                    });
                    if (hasChildren) {
                        if (can.attr.MutationObserver) {
                            observer.disconnect();
                        } else {
                            can.data(can.$(el), 'canBindingCallback', null);
                        }
                    }
                },
                get: get,
                set: set
            });
        }
    };
    var bind = {
        childToParent: function (el, parentCompute, childCompute, bindingsSemaphore, attrName, syncChild) {
            var parentUpdateIsFunction = typeof parentCompute === 'function';
            var updateParent = function (ev, newVal) {
                if (!bindingsSemaphore[attrName]) {
                    if (parentUpdateIsFunction) {
                        parentCompute(newVal);
                        if (syncChild) {
                            if (parentCompute() !== childCompute()) {
                                bindingsSemaphore[attrName] = (bindingsSemaphore[attrName] || 0) + 1;
                                can.batch.start();
                                childCompute(parentCompute());
                                can.batch.after(function () {
                                    --bindingsSemaphore[attrName];
                                });
                                can.batch.stop();
                            }
                        }
                    } else if (parentCompute instanceof can.Map) {
                        parentCompute.attr(newVal, true);
                    }
                }
            };
            if (childCompute && childCompute.isComputed) {
                childCompute.bind('change', updateParent);
            }
            return updateParent;
        },
        parentToChild: function (el, parentCompute, childUpdate, bindingsSemaphore, attrName) {
            var updateChild = function (ev, newValue) {
                bindingsSemaphore[attrName] = (bindingsSemaphore[attrName] || 0) + 1;
                can.batch.start();
                childUpdate(newValue);
                can.batch.after(function () {
                    --bindingsSemaphore[attrName];
                });
                can.batch.stop();
            };
            if (parentCompute && parentCompute.isComputed) {
                parentCompute.bind('change', updateChild);
            }
            return updateChild;
        }
    };
    var getBindingInfo = function (node, attributeViewModelBindings, templateType, tagName) {
        var attributeName = node.name, attributeValue = node.value || '';
        var matches = attributeName.match(bindingsRegExp);
        if (!matches) {
            var ignoreAttribute = ignoreAttributesRegExp.test(attributeName);
            var vmName = can.camelize(attributeName);
            if (ignoreAttribute || viewCallbacks.attr(attributeName)) {
                return;
            }
            var syntaxRight = attributeValue[0] === '{' && can.last(attributeValue) === '}';
            var isAttributeToChild = templateType === 'legacy' ? attributeViewModelBindings[vmName] : !syntaxRight;
            var scopeName = syntaxRight ? attributeValue.substr(1, attributeValue.length - 2) : attributeValue;
            if (isAttributeToChild) {
                return {
                    bindingAttributeName: attributeName,
                    parent: 'attribute',
                    parentName: attributeName,
                    child: 'viewModel',
                    childName: vmName,
                    parentToChild: true,
                    childToParent: true
                };
            } else {
                return {
                    bindingAttributeName: attributeName,
                    parent: 'scope',
                    parentName: scopeName,
                    child: 'viewModel',
                    childName: vmName,
                    parentToChild: true,
                    childToParent: true
                };
            }
        }
        var twoWay = !!matches[1], childToParent = twoWay || !!matches[2], parentToChild = twoWay || !childToParent;
        var childName = matches[3];
        var isDOM = childName.charAt(0) === '$';
        if (isDOM) {
            var bindingInfo = {
                parent: 'scope',
                child: 'attribute',
                childToParent: childToParent,
                parentToChild: parentToChild,
                bindingAttributeName: attributeName,
                childName: childName.substr(1),
                parentName: attributeValue,
                initializeValues: true
            };
            if (tagName === 'select') {
                bindingInfo.stickyParentToChild = true;
            }
            return bindingInfo;
        } else {
            return {
                parent: 'scope',
                child: 'viewModel',
                childToParent: childToParent,
                parentToChild: parentToChild,
                bindingAttributeName: attributeName,
                childName: can.camelize(childName),
                parentName: attributeValue,
                initializeValues: true
            };
        }
    };
    var bindingsRegExp = /\{(\()?(\^)?([^\}\)]+)\)?\}/, ignoreAttributesRegExp = /^(data-view-id|class|id|\[[\w\.-]+\]|#[\w\.-])$/i;
    var makeDataBinding = function (node, el, bindingData) {
        var bindingInfo = getBindingInfo(node, bindingData.attributeViewModelBindings, bindingData.templateType, el.nodeName.toLowerCase());
        if (!bindingInfo) {
            return;
        }
        bindingInfo.alreadyUpdatedChild = bindingData.alreadyUpdatedChild;
        if (bindingData.initializeValues) {
            bindingInfo.initializeValues = true;
        }
        var parentCompute = getComputeFrom[bindingInfo.parent](el, bindingData.scope, bindingInfo.parentName, bindingData, bindingInfo.parentToChild), childCompute = getComputeFrom[bindingInfo.child](el, bindingData.scope, bindingInfo.childName, bindingData, bindingInfo.childToParent, bindingInfo.stickyParentToChild && parentCompute), updateParent, updateChild, childLifecycle;
        if (bindingData.nodeList) {
            if (parentCompute && parentCompute.isComputed) {
                parentCompute.computeInstance.setPrimaryDepth(bindingData.nodeList.nesting + 1);
            }
            if (childCompute && childCompute.isComputed) {
                childCompute.computeInstance.setPrimaryDepth(bindingData.nodeList.nesting + 1);
            }
        }
        if (bindingInfo.parentToChild) {
            updateChild = bind.parentToChild(el, parentCompute, childCompute, bindingData.semaphore, bindingInfo.bindingAttributeName);
        }
        var completeBinding = function () {
            if (bindingInfo.childToParent) {
                updateParent = bind.childToParent(el, parentCompute, childCompute, bindingData.semaphore, bindingInfo.bindingAttributeName, bindingData.syncChildWithParent);
            } else if (bindingInfo.stickyParentToChild) {
                childCompute.bind('change', childLifecycle = can.k);
            }
            if (bindingInfo.initializeValues) {
                initializeValues(bindingInfo, childCompute, parentCompute, updateChild, updateParent);
            }
        };
        var onTeardown = function () {
            unbindUpdate(parentCompute, updateChild);
            unbindUpdate(childCompute, updateParent);
            unbindUpdate(childCompute, childLifecycle);
        };
        if (bindingInfo.child === 'viewModel') {
            return {
                value: getValue(parentCompute),
                onCompleteBinding: completeBinding,
                bindingInfo: bindingInfo,
                onTeardown: onTeardown
            };
        } else {
            completeBinding();
            return {
                bindingInfo: bindingInfo,
                onTeardown: onTeardown
            };
        }
    };
    var initializeValues = function (bindingInfo, childCompute, parentCompute, updateChild, updateParent) {
        var doUpdateParent = false;
        if (bindingInfo.parentToChild && !bindingInfo.childToParent) {
        } else if (!bindingInfo.parentToChild && bindingInfo.childToParent) {
            doUpdateParent = true;
        } else if (getValue(childCompute) === undefined) {
        } else if (getValue(parentCompute) === undefined) {
            doUpdateParent = true;
        }
        if (doUpdateParent) {
            updateParent({}, getValue(childCompute));
        } else {
            if (!bindingInfo.alreadyUpdatedChild) {
                updateChild({}, getValue(parentCompute));
            }
        }
    };
    if (!can.attr.MutationObserver) {
        var updateSelectValue = function (el) {
            var bindingCallback = can.data(can.$(el), 'canBindingCallback');
            if (bindingCallback) {
                bindingCallback.onMutation(el);
            }
        };
        live.registerChildMutationCallback('select', updateSelectValue);
        live.registerChildMutationCallback('optgroup', function (el) {
            updateSelectValue(el.parentNode);
        });
    }
    var isContentEditable = function () {
            var values = {
                '': true,
                'true': true,
                'false': false
            };
            var editable = function (el) {
                if (!el || !el.getAttribute) {
                    return;
                }
                var attr = el.getAttribute('contenteditable');
                return values[attr];
            };
            return function (el) {
                var val = editable(el);
                if (typeof val === 'boolean') {
                    return val;
                } else {
                    return !!editable(el.parentNode);
                }
            };
        }(), removeBrackets = function (value, open, close) {
            open = open || '{';
            close = close || '}';
            if (value[0] === open && value[value.length - 1] === close) {
                return value.substr(1, value.length - 2);
            }
            return value;
        }, getValue = function (value) {
            return value && value.isComputed ? value() : value;
        }, unbindUpdate = function (compute, updateOther) {
            if (compute && compute.isComputed && typeof updateOther === 'function') {
                compute.unbind('change', updateOther);
            }
        }, cleanVMName = function (name) {
            return name.replace(/@/g, '');
        };
    var special = {
        enter: function (data, el, original) {
            return {
                event: 'keyup',
                handler: function (ev) {
                    if (ev.keyCode === 13) {
                        return original.call(this, ev);
                    }
                }
            };
        }
    };
    can.bindings = {
        behaviors: behaviors,
        getBindingInfo: getBindingInfo,
        special: special
    };
    return can.bindings;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#view/mustache/mustache*/
swifty.define('can/view/mustache',[
    'can/util/library',
    'can/view/scope',
    'can/view',
    'can/scanner',
    'can/compute',
    'can/render',
    'can/view/bindings'
], function (can) {
    can.view.ext = '.mustache';
    var SCOPE = 'scope', HASH = '___h4sh', CONTEXT_OBJ = '{scope:' + SCOPE + ',options:options}', SPECIAL_CONTEXT_OBJ = '{scope:' + SCOPE + ',options:options, special: true}', ARG_NAMES = SCOPE + ',options', argumentsRegExp = /((([^'"\s]+?=)?('.*?'|".*?"))|.*?)\s/g, literalNumberStringBooleanRegExp = /^(('.*?'|".*?"|[0-9]+\.?[0-9]*|true|false|null|undefined)|((.+?)=(('.*?'|".*?"|[0-9]+\.?[0-9]*|true|false)|(.+))))$/, makeLookupLiteral = function (type) {
            return '{get:"' + type.replace(/"/g, '\\"') + '"}';
        }, isLookup = function (obj) {
            return obj && typeof obj.get === 'string';
        }, isObserveLike = function (obj) {
            return obj instanceof can.Map || obj && !!obj._get;
        }, isArrayLike = function (obj) {
            return obj && obj.splice && typeof obj.length === 'number';
        }, makeConvertToScopes = function (original, scope, options) {
            var originalWithScope = function (ctx, opts) {
                return original(ctx || scope, opts);
            };
            return function (updatedScope, updatedOptions) {
                if (updatedScope !== undefined && !(updatedScope instanceof can.view.Scope)) {
                    updatedScope = scope.add(updatedScope);
                }
                if (updatedOptions !== undefined && !(updatedOptions instanceof can.view.Options)) {
                    updatedOptions = options.add(updatedOptions);
                }
                return originalWithScope(updatedScope, updatedOptions || options);
            };
        };
    var Mustache = function (options, helpers) {
        if (this.constructor !== Mustache) {
            var mustache = new Mustache(options);
            return function (data, options) {
                return mustache.render(data, options);
            };
        }
        if (typeof options === 'function') {
            this.template = { fn: options };
            return;
        }
        can.extend(this, options);
        this.template = this.scanner.scan(this.text, this.name);
    };
    can.Mustache = can.global.Mustache = Mustache;
    Mustache.prototype.render = function (data, options) {
        if (!(data instanceof can.view.Scope)) {
            data = new can.view.Scope(data || {});
        }
        if (!(options instanceof can.view.Options)) {
            options = new can.view.Options(options || {});
        }
        options = options || {};
        return this.template.fn.call(data, data, options);
    };
    can.extend(Mustache.prototype, {
        scanner: new can.view.Scanner({
            text: {
                start: '',
                scope: SCOPE,
                options: ',options: options',
                argNames: ARG_NAMES
            },
            tokens: [
                [
                    'returnLeft',
                    '{{{',
                    '{{[{&]'
                ],
                [
                    'commentFull',
                    '{{!}}',
                    '^[\\s\\t]*{{!.+?}}\\n'
                ],
                [
                    'commentLeft',
                    '{{!',
                    '(\\n[\\s\\t]*{{!|{{!)'
                ],
                [
                    'escapeFull',
                    '{{}}',
                    '(^[\\s\\t]*{{[#/^][^}]+?}}\\n|\\n[\\s\\t]*{{[#/^][^}]+?}}\\n|\\n[\\s\\t]*{{[#/^][^}]+?}}$)',
                    function (content) {
                        return {
                            before: /^\n.+?\n$/.test(content) ? '\n' : '',
                            content: content.match(/\{\{(.+?)\}\}/)[1] || ''
                        };
                    }
                ],
                [
                    'escapeLeft',
                    '{{'
                ],
                [
                    'returnRight',
                    '}}}'
                ],
                [
                    'right',
                    '}}'
                ]
            ],
            helpers: [
                {
                    name: /^>[\s]*\w*/,
                    fn: function (content, cmd) {
                        var templateName = can.trim(content.replace(/^>\s?/, '')).replace(/["|']/g, '');
                        return 'can.Mustache.renderPartial(\'' + templateName + '\',' + ARG_NAMES + ')';
                    }
                },
                {
                    name: /^\s*data\s/,
                    fn: function (content, cmd) {
                        var attr = content.match(/["|'](.*)["|']/)[1];
                        return 'can.proxy(function(__){' + 'can.data(can.$(__),\'' + attr + '\', this.attr(\'.\')); }, ' + SCOPE + ')';
                    }
                },
                {
                    name: /\s*\(([\$\w]+)\)\s*->([^\n]*)/,
                    fn: function (content) {
                        var quickFunc = /\s*\(([\$\w]+)\)\s*->([^\n]*)/, parts = content.match(quickFunc);
                        return 'can.proxy(function(__){var ' + parts[1] + '=can.$(__);with(' + SCOPE + '.attr(\'.\')){' + parts[2] + '}}, this);';
                    }
                },
                {
                    name: /^.*$/,
                    fn: function (content, cmd) {
                        var mode = false, result = {
                                content: '',
                                startTxt: false,
                                startOnlyTxt: false,
                                end: false
                            };
                        content = can.trim(content);
                        if (content.length && (mode = content.match(/^([#^\/]|else$)/))) {
                            mode = mode[0];
                            switch (mode) {
                            case '#':
                            case '^':
                                if (cmd.specialAttribute) {
                                    result.startOnlyTxt = true;
                                } else {
                                    result.startTxt = true;
                                    result.escaped = 0;
                                }
                                break;
                            case '/':
                                result.end = true;
                                result.content += 'return ___v1ew.join("");}}])';
                                return result;
                            }
                            content = content.substring(1);
                        }
                        if (mode !== 'else') {
                            var args = [], hashes = [], i = 0, m;
                            result.content += 'can.Mustache.txt(\n' + (cmd.specialAttribute ? SPECIAL_CONTEXT_OBJ : CONTEXT_OBJ) + ',\n' + (mode ? '"' + mode + '"' : 'null') + ',';
                            (can.trim(content) + ' ').replace(argumentsRegExp, function (whole, arg) {
                                if (i && (m = arg.match(literalNumberStringBooleanRegExp))) {
                                    if (m[2]) {
                                        args.push(m[0]);
                                    } else {
                                        hashes.push(m[4] + ':' + (m[6] ? m[6] : makeLookupLiteral(m[5])));
                                    }
                                } else {
                                    args.push(makeLookupLiteral(arg));
                                }
                                i++;
                            });
                            result.content += args.join(',');
                            if (hashes.length) {
                                result.content += ',{' + HASH + ':{' + hashes.join(',') + '}}';
                            }
                        }
                        if (mode && mode !== 'else') {
                            result.content += ',[\n\n';
                        }
                        switch (mode) {
                        case '^':
                        case '#':
                            result.content += '{fn:function(' + ARG_NAMES + '){var ___v1ew = [];';
                            break;
                        case 'else':
                            result.content += 'return ___v1ew.join("");}},\n{inverse:function(' + ARG_NAMES + '){\nvar ___v1ew = [];';
                            break;
                        default:
                            result.content += ')';
                            break;
                        }
                        if (!mode) {
                            result.startTxt = true;
                            result.end = true;
                        }
                        return result;
                    }
                }
            ]
        })
    });
    var helpers = can.view.Scanner.prototype.helpers;
    for (var i = 0; i < helpers.length; i++) {
        Mustache.prototype.scanner.helpers.unshift(helpers[i]);
    }
    Mustache.txt = function (scopeAndOptions, mode, name) {
        var scope = scopeAndOptions.scope, options = scopeAndOptions.options, args = [], helperOptions = {
                fn: function () {
                },
                inverse: function () {
                }
            }, hash, context = scope.attr('.'), getHelper = true, helper;
        for (var i = 3; i < arguments.length; i++) {
            var arg = arguments[i];
            if (mode && can.isArray(arg)) {
                helperOptions = can.extend.apply(can, [helperOptions].concat(arg));
            } else if (arg && arg[HASH]) {
                hash = arg[HASH];
                for (var prop in hash) {
                    if (isLookup(hash[prop])) {
                        hash[prop] = Mustache.get(hash[prop].get, scopeAndOptions, false, true);
                    }
                }
            } else if (arg && isLookup(arg)) {
                args.push(Mustache.get(arg.get, scopeAndOptions, false, true, true));
            } else {
                args.push(arg);
            }
        }
        if (isLookup(name)) {
            var get = name.get;
            name = Mustache.get(name.get, scopeAndOptions, args.length, false);
            getHelper = get === name;
        }
        helperOptions.fn = makeConvertToScopes(helperOptions.fn, scope, options);
        helperOptions.inverse = makeConvertToScopes(helperOptions.inverse, scope, options);
        if (mode === '^') {
            var tmp = helperOptions.fn;
            helperOptions.fn = helperOptions.inverse;
            helperOptions.inverse = tmp;
        }
        if (helper = getHelper && (typeof name === 'string' && Mustache.getHelper(name, options)) || can.isFunction(name) && !name.isComputed && { fn: name }) {
            can.extend(helperOptions, {
                context: context,
                scope: scope,
                contexts: scope,
                hash: hash
            });
            args.push(helperOptions);
            return function () {
                var result = helper.fn.apply(context, args);
                return result == null ? '' : result;
            };
        }
        return function () {
            var value;
            if (can.isFunction(name) && name.isComputed) {
                value = name();
            } else {
                value = name;
            }
            var validArgs = args.length ? args : [value], valid = true, result = [], i, argIsObserve, arg;
            if (mode) {
                for (i = 0; i < validArgs.length; i++) {
                    arg = validArgs[i];
                    argIsObserve = typeof arg !== 'undefined' && isObserveLike(arg);
                    if (isArrayLike(arg)) {
                        if (mode === '#') {
                            valid = valid && !!(argIsObserve ? arg.attr('length') : arg.length);
                        } else if (mode === '^') {
                            valid = valid && !(argIsObserve ? arg.attr('length') : arg.length);
                        }
                    } else {
                        valid = mode === '#' ? valid && !!arg : mode === '^' ? valid && !arg : valid;
                    }
                }
            }
            if (valid) {
                if (mode === '#') {
                    if (isArrayLike(value)) {
                        var isObserveList = isObserveLike(value);
                        for (i = 0; i < value.length; i++) {
                            result.push(helperOptions.fn(isObserveList ? value.attr('' + i) : value[i]));
                        }
                        return result.join('');
                    } else {
                        return helperOptions.fn(value || {}) || '';
                    }
                } else if (mode === '^') {
                    return helperOptions.inverse(value || {}) || '';
                } else {
                    return '' + (value != null ? value : '');
                }
            }
            return '';
        };
    };
    Mustache.get = function (key, scopeAndOptions, isHelper, isArgument, isLookup) {
        var context = scopeAndOptions.scope.attr('.'), options = scopeAndOptions.options || {};
        if (isHelper) {
            if (Mustache.getHelper(key, options)) {
                return key;
            }
            if (scopeAndOptions.scope && can.isFunction(context[key])) {
                return context[key];
            }
        }
        var computeData = scopeAndOptions.scope.computeData(key, {
                isArgument: isArgument,
                args: [
                    context,
                    scopeAndOptions.scope
                ]
            }), compute = computeData.compute;
        can.compute.temporarilyBind(compute);
        var initialValue = computeData.initialValue, helperObj = Mustache.getHelper(key, options);
        if (!isLookup && (initialValue === undefined || computeData.scope !== scopeAndOptions.scope) && Mustache.getHelper(key, options)) {
            return key;
        }
        if (!compute.computeInstance.hasDependencies) {
            return initialValue;
        } else {
            return compute;
        }
    };
    Mustache.resolve = function (value) {
        if (isObserveLike(value) && isArrayLike(value) && value.attr('length')) {
            return value;
        } else if (can.isFunction(value)) {
            return value();
        } else {
            return value;
        }
    };
    Mustache._helpers = {};
    Mustache.registerHelper = function (name, fn) {
        this._helpers[name] = {
            name: name,
            fn: fn
        };
    };
    Mustache.registerSimpleHelper = function (name, fn) {
        Mustache.registerHelper(name, can.view.simpleHelper(fn));
    };
    Mustache.getHelper = function (name, options) {
        var helper;
        if (options) {
            helper = options.get('helpers.' + name, { proxyMethods: false });
        }
        return helper ? { fn: helper } : this._helpers[name];
    };
    Mustache.render = function (partial, scope, options) {
        if (!can.view.cached[partial]) {
            can.__notObserve(function () {
                var scopePartialName = scope.attr(partial);
                if (scopePartialName) {
                    partial = scopePartialName;
                }
            })();
        }
        return can.view.render(partial, scope, options);
    };
    Mustache.safeString = function (str) {
        return {
            toString: function () {
                return str;
            }
        };
    };
    Mustache.renderPartial = function (partialName, scope, options) {
        var partial = options.get('partials.' + partialName, { proxyMethods: false });
        if (partial) {
            return partial.render ? partial.render(scope, options) : partial(scope, options);
        } else {
            return can.Mustache.render(partialName, scope, options);
        }
    };
    can.each({
        'if': function (expr, options) {
            var value;
            if (can.isFunction(expr)) {
                value = can.compute.truthy(expr)();
            } else {
                value = !!Mustache.resolve(expr);
            }
            if (value) {
                return options.fn(options.contexts || this);
            } else {
                return options.inverse(options.contexts || this);
            }
        },
        'is': function () {
            var lastValue, curValue, options = arguments[arguments.length - 1];
            if (arguments.length - 2 <= 0) {
                return options.inverse();
            }
            for (var i = 0; i < arguments.length - 1; i++) {
                curValue = Mustache.resolve(arguments[i]);
                curValue = can.isFunction(curValue) ? curValue() : curValue;
                if (i > 0) {
                    if (curValue !== lastValue) {
                        return options.inverse();
                    }
                }
                lastValue = curValue;
            }
            return options.fn();
        },
        'eq': function () {
            return Mustache._helpers.is.fn.apply(this, arguments);
        },
        'unless': function (expr, options) {
            return Mustache._helpers['if'].fn.apply(this, [
                expr,
                can.extend({}, options, {
                    fn: options.inverse,
                    inverse: options.fn
                })
            ]);
        },
        'each': function (expr, options) {
            var resolved = Mustache.resolve(expr), result = [], keys, key, i;
            if (can.view.lists && (resolved instanceof can.List || expr && expr.isComputed && resolved === undefined)) {
                return can.view.lists(expr, function (item, index) {
                    return options.fn(options.scope.add({ '@index': index }).add(item));
                });
            }
            expr = resolved;
            if (!!expr && isArrayLike(expr)) {
                for (i = 0; i < expr.length; i++) {
                    result.push(options.fn(options.scope.add({ '@index': i }).add(expr[i])));
                }
                return result.join('');
            } else if (isObserveLike(expr)) {
                keys = can.Map.keys(expr);
                for (i = 0; i < keys.length; i++) {
                    key = keys[i];
                    result.push(options.fn(options.scope.add({ '@key': key }).add(expr[key])));
                }
                return result.join('');
            } else if (expr instanceof Object) {
                for (key in expr) {
                    result.push(options.fn(options.scope.add({ '@key': key }).add(expr[key])));
                }
                return result.join('');
            }
        },
        'with': function (expr, options) {
            var ctx = expr;
            expr = Mustache.resolve(expr);
            if (!!expr) {
                return options.fn(ctx);
            }
        },
        'log': function (expr, options) {
            if (typeof console !== 'undefined' && console.log) {
                if (!options) {
                    console.log(expr.context);
                } else {
                    console.log(expr, options.context);
                }
            }
        },
        '@index': function (offset, options) {
            if (!options) {
                options = offset;
                offset = 0;
            }
            var index = options.scope.read('@index', { isArgument: true }).value;
            return '' + ((can.isFunction(index) ? index() : index) + offset);
        }
    }, function (fn, name) {
        Mustache.registerHelper(name, fn);
    });
    can.view.register({
        suffix: 'mustache',
        contentType: 'x-mustache-template',
        script: function (id, src) {
            return 'can.Mustache(function(' + ARG_NAMES + ') { ' + new Mustache({
                text: src,
                name: id
            }).template.out + ' })';
        },
        renderer: function (id, text) {
            return Mustache({
                text: text,
                name: id
            });
        }
    });
    can.mustache.registerHelper = can.proxy(can.Mustache.registerHelper, can.Mustache);
    can.mustache.safeString = can.Mustache.safeString;
    return can;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#observe/observe*/
swifty.define('can/observe',[
    'can/util/library',
    'can/map',
    'can/list',
    'can/compute'
], function (can) {
    can.Observe = can.Map;
    can.Observe.startBatch = can.batch.start;
    can.Observe.stopBatch = can.batch.stop;
    can.Observe.triggerBatch = can.batch.trigger;
    return can;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#util/view_model/view_model*/
swifty.define('can/util/view_model',['can/util/library'], function (can) {
    var $ = can.$;
    if ($.fn) {
        $.fn.scope = $.fn.viewModel = function () {
            return can.viewModel.apply(can, [this].concat(can.makeArray(arguments)));
        };
    }
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#component/component*/
swifty.define('can/component',[
    'can/util/library',
    'can/view/callbacks',
    'can/elements',
    'can/view/bindings',
    'can/control',
    'can/observe',
    'can/view/mustache',
    'can/util/view_model'
], function (can, viewCallbacks, elements, bindings) {
    var paramReplacer = /\{([^\}]+)\}/g;
    var Component = can.Component = can.Construct.extend({
        setup: function () {
            can.Construct.setup.apply(this, arguments);
            if (can.Component) {
                var self = this, protoViewModel = this.prototype.scope || this.prototype.viewModel;
                this.Control = ComponentControl.extend(this.prototype.events);
                if (!protoViewModel || typeof protoViewModel === 'object' && !(protoViewModel instanceof can.Map)) {
                    this.Map = can.Map.extend(protoViewModel || {});
                } else if (protoViewModel.prototype instanceof can.Map) {
                    this.Map = protoViewModel;
                }
                this.attributeScopeMappings = {};
                can.each(this.Map ? this.Map.defaults : {}, function (val, prop) {
                    if (val === '@') {
                        self.attributeScopeMappings[prop] = prop;
                    }
                });
                if (this.prototype.template) {
                    if (typeof this.prototype.template === 'function') {
                        var temp = this.prototype.template;
                        this.renderer = function () {
                            return can.view.frag(temp.apply(null, arguments));
                        };
                    } else {
                        this.renderer = can.view.mustache(this.prototype.template);
                    }
                }
                can.view.tag(this.prototype.tag, function (el, options) {
                    new self(el, options);
                });
            }
        }
    }, {
        setup: function (el, componentTagData) {
            var initialViewModelData = {}, component = this, lexicalContent = (typeof this.leakScope === 'undefined' ? false : !this.leakScope) && !!this.template, viewModel, frag, teardownFunctions = [], callTeardownFunctions = function () {
                    for (var i = 0, len = teardownFunctions.length; i < len; i++) {
                        teardownFunctions[i]();
                    }
                }, $el = can.$(el), setupBindings = !can.data($el, 'preventDataBindings');
            can.each(this.constructor.attributeScopeMappings, function (val, prop) {
                initialViewModelData[prop] = el.getAttribute(can.hyphenate(val));
            });
            if (setupBindings) {
                teardownFunctions.push(bindings.behaviors.viewModel(el, componentTagData, function (initialViewModelData) {
                    initialViewModelData['%root'] = componentTagData.scope.attr('%root');
                    var protoViewModel = component.scope || component.viewModel;
                    if (component.constructor.Map) {
                        viewModel = new component.constructor.Map(initialViewModelData);
                    } else if (protoViewModel instanceof can.Map) {
                        viewModel = protoViewModel;
                    } else if (can.isFunction(protoViewModel)) {
                        var scopeResult = protoViewModel.call(component, initialViewModelData, componentTagData.scope, el);
                        if (scopeResult instanceof can.Map) {
                            viewModel = scopeResult;
                        } else if (scopeResult.prototype instanceof can.Map) {
                            viewModel = new scopeResult(initialViewModelData);
                        } else {
                            viewModel = new (can.Map.extend(scopeResult))(initialViewModelData);
                        }
                    }
                    var oldSerialize = viewModel.serialize;
                    viewModel.serialize = function () {
                        var result = oldSerialize.apply(this, arguments);
                        delete result['%root'];
                        return result;
                    };
                    return viewModel;
                }, initialViewModelData));
            }
            this.scope = this.viewModel = viewModel;
            can.data($el, 'scope', this.viewModel);
            can.data($el, 'viewModel', this.viewModel);
            can.data($el, 'preventDataBindings', true);
            var shadowScope;
            if (lexicalContent) {
                shadowScope = can.view.Scope.refsScope().add(this.viewModel, { viewModel: true });
            } else {
                shadowScope = (this.constructor.renderer ? componentTagData.scope.add(new can.view.Scope.Refs()) : componentTagData.scope).add(this.viewModel, { viewModel: true });
            }
            var options = { helpers: {} }, addHelper = function (name, fn) {
                    options.helpers[name] = function () {
                        return fn.apply(viewModel, arguments);
                    };
                };
            can.each(this.helpers || {}, function (val, prop) {
                if (can.isFunction(val)) {
                    addHelper(prop, val);
                }
            });
            can.each(this.simpleHelpers || {}, function (val, prop) {
                addHelper(prop, can.view.simpleHelper(val));
            });
            this._control = new this.constructor.Control(el, {
                scope: this.viewModel,
                viewModel: this.viewModel,
                destroy: callTeardownFunctions
            });
            var nodeList = can.view.nodeLists.register([], undefined, componentTagData.parentNodeList || true, false);
            nodeList.expression = '<' + this.tag + '>';
            teardownFunctions.push(function () {
                can.view.nodeLists.unregister(nodeList);
            });
            if (this.constructor.renderer) {
                if (!options.tags) {
                    options.tags = {};
                }
                options.tags.content = function contentHookup(el, contentTagData) {
                    var subtemplate = componentTagData.subtemplate || contentTagData.subtemplate, renderingLightContent = subtemplate === componentTagData.subtemplate;
                    if (subtemplate) {
                        delete options.tags.content;
                        var lightTemplateData;
                        if (renderingLightContent) {
                            if (lexicalContent) {
                                lightTemplateData = componentTagData;
                            } else {
                                lightTemplateData = {
                                    scope: contentTagData.scope.cloneFromRef(),
                                    options: contentTagData.options
                                };
                            }
                        } else {
                            lightTemplateData = contentTagData;
                        }
                        if (contentTagData.parentNodeList) {
                            var frag = subtemplate(lightTemplateData.scope, lightTemplateData.options, contentTagData.parentNodeList);
                            elements.replace([el], frag);
                        } else {
                            can.view.live.replace([el], subtemplate(lightTemplateData.scope, lightTemplateData.options));
                        }
                        options.tags.content = contentHookup;
                    }
                };
                frag = this.constructor.renderer(shadowScope, componentTagData.options.add(options), nodeList);
            } else {
                if (componentTagData.templateType === 'legacy') {
                    frag = can.view.frag(componentTagData.subtemplate ? componentTagData.subtemplate(shadowScope, componentTagData.options.add(options)) : '');
                } else {
                    frag = componentTagData.subtemplate ? componentTagData.subtemplate(shadowScope, componentTagData.options.add(options), nodeList) : document.createDocumentFragment();
                }
            }
            can.appendChild(el, frag, can.document);
            can.view.nodeLists.update(nodeList, can.childNodes(el));
        }
    });
    var ComponentControl = can.Control.extend({
        _lookup: function (options) {
            return [
                options.scope,
                options,
                window
            ];
        },
        _action: function (methodName, options, controlInstance) {
            var hasObjectLookup, readyCompute;
            paramReplacer.lastIndex = 0;
            hasObjectLookup = paramReplacer.test(methodName);
            if (!controlInstance && hasObjectLookup) {
                return;
            } else if (!hasObjectLookup) {
                return can.Control._action.apply(this, arguments);
            } else {
                readyCompute = can.compute(function () {
                    var delegate;
                    var name = methodName.replace(paramReplacer, function (matched, key) {
                        var value;
                        if (key === 'scope' || key === 'viewModel') {
                            delegate = options.viewModel;
                            return '';
                        }
                        key = key.replace(/^(scope|^viewModel)\./, '');
                        value = can.compute.read(options.viewModel, can.compute.read.reads(key), { readCompute: false }).value;
                        if (value === undefined) {
                            value = can.getObject(key);
                        }
                        if (typeof value === 'string') {
                            return value;
                        } else {
                            delegate = value;
                            return '';
                        }
                    });
                    var parts = name.split(/\s+/g), event = parts.pop();
                    return {
                        processor: this.processors[event] || this.processors.click,
                        parts: [
                            name,
                            parts.join(' '),
                            event
                        ],
                        delegate: delegate || undefined
                    };
                }, this);
                var handler = function (ev, ready) {
                    controlInstance._bindings.control[methodName](controlInstance.element);
                    controlInstance._bindings.control[methodName] = ready.processor(ready.delegate || controlInstance.element, ready.parts[2], ready.parts[1], methodName, controlInstance);
                };
                readyCompute.bind('change', handler);
                controlInstance._bindings.readyComputes[methodName] = {
                    compute: readyCompute,
                    handler: handler
                };
                return readyCompute();
            }
        }
    }, {
        setup: function (el, options) {
            this.scope = options.scope;
            this.viewModel = options.viewModel;
            return can.Control.prototype.setup.call(this, el, options);
        },
        off: function () {
            if (this._bindings) {
                can.each(this._bindings.readyComputes || {}, function (value) {
                    value.compute.unbind('change', value.handler);
                });
            }
            can.Control.prototype.off.apply(this, arguments);
            this._bindings.readyComputes = {};
        },
        destroy: function () {
            can.Control.prototype.destroy.apply(this, arguments);
            if (typeof this.options.destroy === 'function') {
                this.options.destroy.apply(this, arguments);
            }
        }
    });
    var $ = can.$;
    if ($.fn) {
        $.fn.scope = $.fn.viewModel = function () {
            return can.viewModel.apply(can, [this].concat(can.makeArray(arguments)));
        };
    }
    return Component;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#can*/
swifty.define('can',[
    'can/util/library',
    'can/control/route',
    'can/model',
    'can/map/define',
    'can/view/mustache',
    'can/component'
], function (can) {
    return can;
});
swifty.define( 'swiftylib/mustache',[
    'can/../can',
    'can/view',
    // Other
    'can/view/mustache'
], function( can, View, can2 ) {
    

    return can2.Mustache; // dorh View.mustache;
} );

swifty.define( 'swiftylib/view',[
    'can/../can',
    'can/view',
    'can/view/bindings',
    'swiftylib/mustache'
], function( can ) {
    // Because Can's view.js does not return the view object
    return can.view;
} );

/**
 * messageformat.js
 *
 * ICU PluralFormat + SelectFormat for JavaScript
 *
 * @author Alex Sexton - @SlexAxton
 * @version 0.1.5
 * @license WTFPL
 * @contributor_license Dojo CLA
*/
(function ( root ) {

  // Create the contructor function
  function MessageFormat ( locale, pluralFunc ) {
    var fallbackLocale;

    if ( locale && pluralFunc ) {
      MessageFormat.locale[ locale ] = pluralFunc;
    }

    // Defaults
    fallbackLocale = locale = locale || "en";
    pluralFunc = pluralFunc || MessageFormat.locale[ fallbackLocale = MessageFormat.Utils.getFallbackLocale( locale ) ];

    if ( ! pluralFunc ) {
      throw new Error( "Plural Function not found for locale: " + locale );
    }

    // Own Properties
    this.pluralFunc = pluralFunc;
    this.locale = locale;
    this.fallbackLocale = fallbackLocale;
  }

  // Set up the locales object. Add in english by default
  MessageFormat.locale = {
    "en" : function ( n ) {
      if ( n === 1 ) {
        return "one";
      }
      return "other";
    }
  };

  // Build out our basic SafeString type
  // more or less stolen from Handlebars by @wycats
  MessageFormat.SafeString = function( string ) {
    this.string = string;
  };

  MessageFormat.SafeString.prototype.toString = function () {
    return this.string.toString();
  };

  MessageFormat.Utils = {
    numSub : function ( string, key, depth ) {
      // make sure that it's not an escaped octothorpe
      return string.replace( /^#|[^\\]#/g, function (m) {
        var prefix = m && m.length === 2 ? m.charAt(0) : '';
        return prefix + '" + (function(){ var x = ' +
        key+';\nif( isNaN(x) ){\nthrow new Error("MessageFormat: `"+lastkey_'+depth+'+"` isnt a number.");\n}\nreturn x;\n})() + "';
      });
    },
    escapeExpression : function (string) {
      var escape = {
            "\n": "\\n",
            "\"": '\\"'
          },
          badChars = /[\n"]/g,
          possible = /[\n"]/,
          escapeChar = function(chr) {
            return escape[chr] || "&amp;";
          };

      // Don't escape SafeStrings, since they're already safe
      if ( string instanceof MessageFormat.SafeString ) {
        return string.toString();
      }
      else if ( string === null || string === false ) {
        return "";
      }

      if ( ! possible.test( string ) ) {
        return string;
      }
      return string.replace( badChars, escapeChar );
    },
    getFallbackLocale: function( locale ) {
      var tagSeparator = locale.indexOf("-") >= 0 ? "-" : "_";

      // Lets just be friends, fallback through the language tags
      while ( ! MessageFormat.locale.hasOwnProperty( locale ) ) {
        locale = locale.substring(0, locale.lastIndexOf( tagSeparator ));
        if (locale.length === 0) {
          return null;
        }
      }

      return locale;
    }
  };

  // This is generated and pulled in for browsers.
  var mparser = (function(){
    /* Generated by PEG.js 0.6.2 (http://pegjs.majda.cz/). */

    var result = {
      /*
      * Parses the input with a generated parser. If the parsing is successfull,
      * returns a value explicitly or implicitly specified by the grammar from
      * which the parser was generated (see |PEG.buildParser|). If the parsing is
      * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
      */
      parse: function(input, startRule) {
        var parseFunctions = {
          "_": parse__,
          "char": parse_char,
          "chars": parse_chars,
          "digits": parse_digits,
          "elementFormat": parse_elementFormat,
          "hexDigit": parse_hexDigit,
          "id": parse_id,
          "messageFormatElement": parse_messageFormatElement,
          "messageFormatPattern": parse_messageFormatPattern,
          "messageFormatPatternRight": parse_messageFormatPatternRight,
          "offsetPattern": parse_offsetPattern,
          "pluralFormatPattern": parse_pluralFormatPattern,
          "pluralForms": parse_pluralForms,
          "pluralStyle": parse_pluralStyle,
          "selectFormatPattern": parse_selectFormatPattern,
          "selectStyle": parse_selectStyle,
          "start": parse_start,
          "string": parse_string,
          "stringKey": parse_stringKey,
          "whitespace": parse_whitespace
        };

        if (startRule !== undefined) {
          if (parseFunctions[startRule] === undefined) {
            throw new Error("Invalid rule name: " + quote(startRule) + ".");
          }
        } else {
          startRule = "start";
        }

        var pos = 0;
        var reportMatchFailures = true;
        var rightmostMatchFailuresPos = 0;
        var rightmostMatchFailuresExpected = [];
        var cache = {};

        function padLeft(input, padding, length) {
          var result = input;

          var padLength = length - input.length;
          for (var i = 0; i < padLength; i++) {
            result = padding + result;
          }

          return result;
        }

        function escape(ch) {
          var charCode = ch.charCodeAt(0);

          if (charCode <= 0xFF) {
            var escapeChar = 'x';
            var length = 2;
          } else {
            var escapeChar = 'u';
            var length = 4;
          }

          return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
        }

        function quote(s) {
          /*
          * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
          * string literal except for the closing quote character, backslash,
          * carriage return, line separator, paragraph separator, and line feed.
          * Any character may appear in the form of an escape sequence.
          */
          return '"' + s
          .replace(/\\/g, '\\\\')            // backslash
          .replace(/"/g, '\\"')              // closing quote character
          .replace(/\r/g, '\\r')             // carriage return
          .replace(/\n/g, '\\n')             // line feed
          .replace(/[\x80-\uFFFF]/g, escape) // non-ASCII characters
          + '"';
        }

        function matchFailed(failure) {
          if (pos < rightmostMatchFailuresPos) {
            return;
          }

          if (pos > rightmostMatchFailuresPos) {
            rightmostMatchFailuresPos = pos;
            rightmostMatchFailuresExpected = [];
          }

          rightmostMatchFailuresExpected.push(failure);
        }

        function parse_start() {
          var cacheKey = 'start@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos0 = pos;
          var result1 = parse_messageFormatPattern();
          var result2 = result1 !== null
          ? (function(messageFormatPattern) { return { type: "program", program: messageFormatPattern }; })(result1)
          : null;
          if (result2 !== null) {
            var result0 = result2;
          } else {
            var result0 = null;
            pos = savedPos0;
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_messageFormatPattern() {
          var cacheKey = 'messageFormatPattern@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos0 = pos;
          var savedPos1 = pos;
          var result3 = parse_string();
          if (result3 !== null) {
            var result4 = [];
            var result5 = parse_messageFormatPatternRight();
            while (result5 !== null) {
              result4.push(result5);
              var result5 = parse_messageFormatPatternRight();
            }
            if (result4 !== null) {
              var result1 = [result3, result4];
            } else {
              var result1 = null;
              pos = savedPos1;
            }
          } else {
            var result1 = null;
            pos = savedPos1;
          }
          var result2 = result1 !== null
          ? (function(s1, inner) {
            var st = [];
            if ( s1 && s1.val ) {
              st.push( s1 );
            }
            for( var i in inner ){
              if ( inner.hasOwnProperty( i ) ) {
                st.push( inner[ i ] );
              }
            }
            return { type: 'messageFormatPattern', statements: st };
          })(result1[0], result1[1])
          : null;
          if (result2 !== null) {
            var result0 = result2;
          } else {
            var result0 = null;
            pos = savedPos0;
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_messageFormatPatternRight() {
          var cacheKey = 'messageFormatPatternRight@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos0 = pos;
          var savedPos1 = pos;
          if (input.substr(pos, 1) === "{") {
            var result3 = "{";
              pos += 1;
            } else {
              var result3 = null;
              if (reportMatchFailures) {
                matchFailed("\"{\"");
                }
              }
              if (result3 !== null) {
                var result4 = parse__();
                if (result4 !== null) {
                  var result5 = parse_messageFormatElement();
                  if (result5 !== null) {
                    var result6 = parse__();
                    if (result6 !== null) {
                      if (input.substr(pos, 1) === "}") {
                        var result7 = "}";
                        pos += 1;
                  } else {
                    var result7 = null;
                    if (reportMatchFailures) {
                      matchFailed("\"}\"");
                  }
                }
                if (result7 !== null) {
                  var result8 = parse_string();
                  if (result8 !== null) {
                    var result1 = [result3, result4, result5, result6, result7, result8];
                  } else {
                    var result1 = null;
                    pos = savedPos1;
                  }
                } else {
                  var result1 = null;
                  pos = savedPos1;
                }
              } else {
                var result1 = null;
                pos = savedPos1;
              }
            } else {
              var result1 = null;
              pos = savedPos1;
            }
          } else {
            var result1 = null;
            pos = savedPos1;
          }
          } else {
            var result1 = null;
            pos = savedPos1;
          }
          var result2 = result1 !== null
          ? (function(mfe, s1) {
            var res = [];
            if ( mfe ) {
              res.push(mfe);
            }
            if ( s1 && s1.val ) {
              res.push( s1 );
            }
            return { type: "messageFormatPatternRight", statements : res };
          })(result1[2], result1[5])
          : null;
          if (result2 !== null) {
            var result0 = result2;
          } else {
            var result0 = null;
            pos = savedPos0;
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_messageFormatElement() {
          var cacheKey = 'messageFormatElement@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos0 = pos;
          var savedPos1 = pos;
          var result3 = parse_id();
          if (result3 !== null) {
            var savedPos2 = pos;
            if (input.substr(pos, 1) === ",") {
              var result6 = ",";
              pos += 1;
            } else {
              var result6 = null;
              if (reportMatchFailures) {
                matchFailed("\",\"");
              }
            }
            if (result6 !== null) {
              var result7 = parse_elementFormat();
              if (result7 !== null) {
                var result5 = [result6, result7];
              } else {
                var result5 = null;
                pos = savedPos2;
              }
            } else {
              var result5 = null;
              pos = savedPos2;
            }
            var result4 = result5 !== null ? result5 : '';
            if (result4 !== null) {
              var result1 = [result3, result4];
            } else {
              var result1 = null;
              pos = savedPos1;
            }
          } else {
            var result1 = null;
            pos = savedPos1;
          }
          var result2 = result1 !== null
          ? (function(argIdx, efmt) {
            var res = {
              type: "messageFormatElement",
              argumentIndex: argIdx
            };
            if ( efmt && efmt.length ) {
              res.elementFormat = efmt[1];
            }
            else {
              res.output = true;
            }
            return res;
          })(result1[0], result1[1])
          : null;
          if (result2 !== null) {
            var result0 = result2;
          } else {
            var result0 = null;
            pos = savedPos0;
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_elementFormat() {
          var cacheKey = 'elementFormat@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos2 = pos;
          var savedPos3 = pos;
          var result14 = parse__();
          if (result14 !== null) {
            if (input.substr(pos, 6) === "plural") {
              var result15 = "plural";
              pos += 6;
            } else {
              var result15 = null;
              if (reportMatchFailures) {
                matchFailed("\"plural\"");
              }
            }
            if (result15 !== null) {
              var result16 = parse__();
              if (result16 !== null) {
                if (input.substr(pos, 1) === ",") {
                  var result17 = ",";
                  pos += 1;
                } else {
                  var result17 = null;
                  if (reportMatchFailures) {
                    matchFailed("\",\"");
                  }
                }
                if (result17 !== null) {
                  var result18 = parse__();
                  if (result18 !== null) {
                    var result19 = parse_pluralStyle();
                    if (result19 !== null) {
                      var result20 = parse__();
                      if (result20 !== null) {
                        var result12 = [result14, result15, result16, result17, result18, result19, result20];
                      } else {
                        var result12 = null;
                        pos = savedPos3;
                      }
                    } else {
                      var result12 = null;
                      pos = savedPos3;
                    }
                  } else {
                    var result12 = null;
                    pos = savedPos3;
                  }
                } else {
                  var result12 = null;
                  pos = savedPos3;
                }
              } else {
                var result12 = null;
                pos = savedPos3;
              }
            } else {
              var result12 = null;
              pos = savedPos3;
            }
          } else {
            var result12 = null;
            pos = savedPos3;
          }
          var result13 = result12 !== null
          ? (function(t, s) {
            return {
              type : "elementFormat",
              key  : t,
              val  : s.val
            };
          })(result12[1], result12[5])
          : null;
          if (result13 !== null) {
            var result11 = result13;
          } else {
            var result11 = null;
            pos = savedPos2;
          }
          if (result11 !== null) {
            var result0 = result11;
          } else {
            var savedPos0 = pos;
            var savedPos1 = pos;
            var result4 = parse__();
            if (result4 !== null) {
              if (input.substr(pos, 6) === "select") {
                var result5 = "select";
                pos += 6;
              } else {
                var result5 = null;
                if (reportMatchFailures) {
                  matchFailed("\"select\"");
                }
              }
              if (result5 !== null) {
                var result6 = parse__();
                if (result6 !== null) {
                  if (input.substr(pos, 1) === ",") {
                    var result7 = ",";
                    pos += 1;
                  } else {
                    var result7 = null;
                    if (reportMatchFailures) {
                      matchFailed("\",\"");
                    }
                  }
                  if (result7 !== null) {
                    var result8 = parse__();
                    if (result8 !== null) {
                      var result9 = parse_selectStyle();
                      if (result9 !== null) {
                        var result10 = parse__();
                        if (result10 !== null) {
                          var result2 = [result4, result5, result6, result7, result8, result9, result10];
                        } else {
                          var result2 = null;
                          pos = savedPos1;
                        }
                      } else {
                        var result2 = null;
                        pos = savedPos1;
                      }
                    } else {
                      var result2 = null;
                      pos = savedPos1;
                    }
                  } else {
                    var result2 = null;
                    pos = savedPos1;
                  }
                } else {
                  var result2 = null;
                  pos = savedPos1;
                }
              } else {
                var result2 = null;
                pos = savedPos1;
              }
            } else {
              var result2 = null;
              pos = savedPos1;
            }
            var result3 = result2 !== null
            ? (function(t, s) {
              return {
                type : "elementFormat",
                key  : t,
                val  : s.val
              };
            })(result2[1], result2[5])
            : null;
            if (result3 !== null) {
              var result1 = result3;
            } else {
              var result1 = null;
              pos = savedPos0;
            }
            if (result1 !== null) {
              var result0 = result1;
            } else {
              var result0 = null;;
            };
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_pluralStyle() {
          var cacheKey = 'pluralStyle@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos0 = pos;
          var result1 = parse_pluralFormatPattern();
          var result2 = result1 !== null
          ? (function(pfp) {
            return { type: "pluralStyle", val: pfp };
          })(result1)
          : null;
          if (result2 !== null) {
            var result0 = result2;
          } else {
            var result0 = null;
            pos = savedPos0;
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_selectStyle() {
          var cacheKey = 'selectStyle@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos0 = pos;
          var result1 = parse_selectFormatPattern();
          var result2 = result1 !== null
          ? (function(sfp) {
            return { type: "selectStyle", val: sfp };
          })(result1)
          : null;
          if (result2 !== null) {
            var result0 = result2;
          } else {
            var result0 = null;
            pos = savedPos0;
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_pluralFormatPattern() {
          var cacheKey = 'pluralFormatPattern@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos0 = pos;
          var savedPos1 = pos;
          var result6 = parse_offsetPattern();
          var result3 = result6 !== null ? result6 : '';
          if (result3 !== null) {
            var result4 = [];
            var result5 = parse_pluralForms();
            while (result5 !== null) {
              result4.push(result5);
              var result5 = parse_pluralForms();
            }
            if (result4 !== null) {
              var result1 = [result3, result4];
            } else {
              var result1 = null;
              pos = savedPos1;
            }
          } else {
            var result1 = null;
            pos = savedPos1;
          }
          var result2 = result1 !== null
          ? (function(op, pf) {
            var res = {
              type: "pluralFormatPattern",
              pluralForms: pf
            };
            if ( op ) {
              res.offset = op;
            }
            else {
              res.offset = 0;
            }
            return res;
          })(result1[0], result1[1])
          : null;
          if (result2 !== null) {
            var result0 = result2;
          } else {
            var result0 = null;
            pos = savedPos0;
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_offsetPattern() {
          var cacheKey = 'offsetPattern@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos0 = pos;
          var savedPos1 = pos;
          var result3 = parse__();
          if (result3 !== null) {
            if (input.substr(pos, 6) === "offset") {
              var result4 = "offset";
              pos += 6;
            } else {
              var result4 = null;
              if (reportMatchFailures) {
                matchFailed("\"offset\"");
              }
            }
            if (result4 !== null) {
              var result5 = parse__();
              if (result5 !== null) {
                if (input.substr(pos, 1) === ":") {
                  var result6 = ":";
                  pos += 1;
                } else {
                  var result6 = null;
                  if (reportMatchFailures) {
                    matchFailed("\":\"");
                  }
                }
                if (result6 !== null) {
                  var result7 = parse__();
                  if (result7 !== null) {
                    var result8 = parse_digits();
                    if (result8 !== null) {
                      var result9 = parse__();
                      if (result9 !== null) {
                        var result1 = [result3, result4, result5, result6, result7, result8, result9];
                      } else {
                        var result1 = null;
                        pos = savedPos1;
                      }
                    } else {
                      var result1 = null;
                      pos = savedPos1;
                    }
                  } else {
                    var result1 = null;
                    pos = savedPos1;
                  }
                } else {
                  var result1 = null;
                  pos = savedPos1;
                }
              } else {
                var result1 = null;
                pos = savedPos1;
              }
            } else {
              var result1 = null;
              pos = savedPos1;
            }
          } else {
            var result1 = null;
            pos = savedPos1;
          }
          var result2 = result1 !== null
          ? (function(d) {
            return d;
          })(result1[5])
          : null;
          if (result2 !== null) {
            var result0 = result2;
          } else {
            var result0 = null;
            pos = savedPos0;
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_selectFormatPattern() {
          var cacheKey = 'selectFormatPattern@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos0 = pos;
          var result1 = [];
          var result3 = parse_pluralForms();
          while (result3 !== null) {
            result1.push(result3);
            var result3 = parse_pluralForms();
          }
          var result2 = result1 !== null
          ? (function(pf) {
            return {
              type: "selectFormatPattern",
              pluralForms: pf
            };
          })(result1)
          : null;
          if (result2 !== null) {
            var result0 = result2;
          } else {
            var result0 = null;
            pos = savedPos0;
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_pluralForms() {
          var cacheKey = 'pluralForms@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos0 = pos;
          var savedPos1 = pos;
          var result3 = parse__();
          if (result3 !== null) {
            var result4 = parse_stringKey();
            if (result4 !== null) {
              var result5 = parse__();
              if (result5 !== null) {
                if (input.substr(pos, 1) === "{") {
                  var result6 = "{";
                    pos += 1;
                  } else {
                    var result6 = null;
                    if (reportMatchFailures) {
                      matchFailed("\"{\"");
                      }
                    }
                    if (result6 !== null) {
                      var result7 = parse__();
                      if (result7 !== null) {
                        var result8 = parse_messageFormatPattern();
                        if (result8 !== null) {
                          var result9 = parse__();
                          if (result9 !== null) {
                            if (input.substr(pos, 1) === "}") {
                              var result10 = "}";
                              pos += 1;
                        } else {
                          var result10 = null;
                          if (reportMatchFailures) {
                            matchFailed("\"}\"");
                        }
                      }
                      if (result10 !== null) {
                        var result1 = [result3, result4, result5, result6, result7, result8, result9, result10];
                      } else {
                        var result1 = null;
                        pos = savedPos1;
                      }
                    } else {
                      var result1 = null;
                      pos = savedPos1;
                    }
                  } else {
                    var result1 = null;
                    pos = savedPos1;
                  }
                } else {
                  var result1 = null;
                  pos = savedPos1;
                }
                } else {
                  var result1 = null;
                  pos = savedPos1;
                }
              } else {
                var result1 = null;
                pos = savedPos1;
              }
            } else {
              var result1 = null;
              pos = savedPos1;
            }
          } else {
            var result1 = null;
            pos = savedPos1;
          }
          var result2 = result1 !== null
          ? (function(k, mfp) {
            return {
              type: "pluralForms",
              key: k,
              val: mfp
            };
          })(result1[1], result1[5])
          : null;
          if (result2 !== null) {
            var result0 = result2;
          } else {
            var result0 = null;
            pos = savedPos0;
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_stringKey() {
          var cacheKey = 'stringKey@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos2 = pos;
          var result7 = parse_id();
          var result8 = result7 !== null
          ? (function(i) {
            return i;
          })(result7)
          : null;
          if (result8 !== null) {
            var result6 = result8;
          } else {
            var result6 = null;
            pos = savedPos2;
          }
          if (result6 !== null) {
            var result0 = result6;
          } else {
            var savedPos0 = pos;
            var savedPos1 = pos;
            if (input.substr(pos, 1) === "=") {
              var result4 = "=";
              pos += 1;
            } else {
              var result4 = null;
              if (reportMatchFailures) {
                matchFailed("\"=\"");
              }
            }
            if (result4 !== null) {
              var result5 = parse_digits();
              if (result5 !== null) {
                var result2 = [result4, result5];
              } else {
                var result2 = null;
                pos = savedPos1;
              }
            } else {
              var result2 = null;
              pos = savedPos1;
            }
            var result3 = result2 !== null
            ? (function(d) {
              return d;
            })(result2[1])
            : null;
            if (result3 !== null) {
              var result1 = result3;
            } else {
              var result1 = null;
              pos = savedPos0;
            }
            if (result1 !== null) {
              var result0 = result1;
            } else {
              var result0 = null;;
            };
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_string() {
          var cacheKey = 'string@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos0 = pos;
          var savedPos1 = pos;
          var result3 = parse__();
          if (result3 !== null) {
            var result4 = [];
            var savedPos2 = pos;
            var result6 = parse__();
            if (result6 !== null) {
              var result7 = parse_chars();
              if (result7 !== null) {
                var result8 = parse__();
                if (result8 !== null) {
                  var result5 = [result6, result7, result8];
                } else {
                  var result5 = null;
                  pos = savedPos2;
                }
              } else {
                var result5 = null;
                pos = savedPos2;
              }
            } else {
              var result5 = null;
              pos = savedPos2;
            }
            while (result5 !== null) {
              result4.push(result5);
              var savedPos2 = pos;
              var result6 = parse__();
              if (result6 !== null) {
                var result7 = parse_chars();
                if (result7 !== null) {
                  var result8 = parse__();
                  if (result8 !== null) {
                    var result5 = [result6, result7, result8];
                  } else {
                    var result5 = null;
                    pos = savedPos2;
                  }
                } else {
                  var result5 = null;
                  pos = savedPos2;
                }
              } else {
                var result5 = null;
                pos = savedPos2;
              }
            }
            if (result4 !== null) {
              var result1 = [result3, result4];
            } else {
              var result1 = null;
              pos = savedPos1;
            }
          } else {
            var result1 = null;
            pos = savedPos1;
          }
          var result2 = result1 !== null
          ? (function(ws, s) {
            var tmp = [];
            for( var i = 0; i < s.length; ++i ) {
              for( var j = 0; j < s[ i ].length; ++j ) {
                tmp.push(s[i][j]);
              }
            }
            return {
              type: "string",
              val: ws + tmp.join('')
            };
          })(result1[0], result1[1])
          : null;
          if (result2 !== null) {
            var result0 = result2;
          } else {
            var result0 = null;
            pos = savedPos0;
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_id() {
          var cacheKey = 'id@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos0 = pos;
          var savedPos1 = pos;
          var result3 = parse__();
          if (result3 !== null) {
            if (input.substr(pos).match(/^[a-zA-Z$_]/) !== null) {
              var result4 = input.charAt(pos);
              pos++;
            } else {
              var result4 = null;
              if (reportMatchFailures) {
                matchFailed("[a-zA-Z$_]");
              }
            }
            if (result4 !== null) {
              var result5 = [];
              if (input.substr(pos).match(/^[^ 	\n\r,.+={}]/) !== null) {
                var result7 = input.charAt(pos);
                pos++;
              } else {
                var result7 = null;
                if (reportMatchFailures) {
                  matchFailed("[^ 	\\n\\r,.+={}]");
                }
              }
              while (result7 !== null) {
                result5.push(result7);
                if (input.substr(pos).match(/^[^ 	\n\r,.+={}]/) !== null) {
                  var result7 = input.charAt(pos);
                  pos++;
                } else {
                  var result7 = null;
                  if (reportMatchFailures) {
                    matchFailed("[^ 	\\n\\r,.+={}]");
                  }
                }
              }
              if (result5 !== null) {
                var result6 = parse__();
                if (result6 !== null) {
                  var result1 = [result3, result4, result5, result6];
                } else {
                  var result1 = null;
                  pos = savedPos1;
                }
              } else {
                var result1 = null;
                pos = savedPos1;
              }
            } else {
              var result1 = null;
              pos = savedPos1;
            }
          } else {
            var result1 = null;
            pos = savedPos1;
          }
          var result2 = result1 !== null
          ? (function(s1, s2) {
            return s1 + (s2 ? s2.join('') : '');
          })(result1[1], result1[2])
          : null;
          if (result2 !== null) {
            var result0 = result2;
          } else {
            var result0 = null;
            pos = savedPos0;
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_chars() {
          var cacheKey = 'chars@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos0 = pos;
          var result3 = parse_char();
          if (result3 !== null) {
            var result1 = [];
            while (result3 !== null) {
              result1.push(result3);
              var result3 = parse_char();
            }
          } else {
            var result1 = null;
          }
          var result2 = result1 !== null
          ? (function(chars) { return chars.join(''); })(result1)
          : null;
          if (result2 !== null) {
            var result0 = result2;
          } else {
            var result0 = null;
            pos = savedPos0;
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_char() {
          var cacheKey = 'char@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos5 = pos;
          if (input.substr(pos).match(/^[^{}\\\0- 	\n\r]/) !== null) {
            var result19 = input.charAt(pos);
            pos++;
          } else {
            var result19 = null;
            if (reportMatchFailures) {
              matchFailed("[^{}\\\\\\0- 	\\n\\r]");
            }
          }
          var result20 = result19 !== null
          ? (function(x) {
            return x;
          })(result19)
          : null;
          if (result20 !== null) {
            var result18 = result20;
          } else {
            var result18 = null;
            pos = savedPos5;
          }
          if (result18 !== null) {
            var result0 = result18;
          } else {
            var savedPos4 = pos;
            if (input.substr(pos, 2) === "\\#") {
              var result16 = "\\#";
              pos += 2;
            } else {
              var result16 = null;
              if (reportMatchFailures) {
                matchFailed("\"\\\\#\"");
              }
            }
            var result17 = result16 !== null
            ? (function() {
              return "\\#";
            })()
            : null;
            if (result17 !== null) {
              var result15 = result17;
            } else {
              var result15 = null;
              pos = savedPos4;
            }
            if (result15 !== null) {
              var result0 = result15;
            } else {
              var savedPos3 = pos;
              if (input.substr(pos, 2) === "\\{") {
                var result13 = "\\{";
                  pos += 2;
                } else {
                  var result13 = null;
                  if (reportMatchFailures) {
                    matchFailed("\"\\\\{\"");
                    }
                  }
                  var result14 = result13 !== null
                  ? (function() {
                    return "\u007B";
                  })()
                  : null;
                  if (result14 !== null) {
                    var result12 = result14;
                  } else {
                    var result12 = null;
                    pos = savedPos3;
                  }
                  if (result12 !== null) {
                    var result0 = result12;
                  } else {
                    var savedPos2 = pos;
                    if (input.substr(pos, 2) === "\\}") {
                      var result10 = "\\}";
                      pos += 2;
                } else {
                  var result10 = null;
                  if (reportMatchFailures) {
                    matchFailed("\"\\\\}\"");
                }
              }
              var result11 = result10 !== null
              ? (function() {
                return "\u007D";
              })()
              : null;
              if (result11 !== null) {
                var result9 = result11;
              } else {
                var result9 = null;
                pos = savedPos2;
              }
              if (result9 !== null) {
                var result0 = result9;
              } else {
                var savedPos0 = pos;
                var savedPos1 = pos;
                if (input.substr(pos, 2) === "\\u") {
                  var result4 = "\\u";
                  pos += 2;
                } else {
                  var result4 = null;
                  if (reportMatchFailures) {
                    matchFailed("\"\\\\u\"");
                  }
                }
                if (result4 !== null) {
                  var result5 = parse_hexDigit();
                  if (result5 !== null) {
                    var result6 = parse_hexDigit();
                    if (result6 !== null) {
                      var result7 = parse_hexDigit();
                      if (result7 !== null) {
                        var result8 = parse_hexDigit();
                        if (result8 !== null) {
                          var result2 = [result4, result5, result6, result7, result8];
                        } else {
                          var result2 = null;
                          pos = savedPos1;
                        }
                      } else {
                        var result2 = null;
                        pos = savedPos1;
                      }
                    } else {
                      var result2 = null;
                      pos = savedPos1;
                    }
                  } else {
                    var result2 = null;
                    pos = savedPos1;
                  }
                } else {
                  var result2 = null;
                  pos = savedPos1;
                }
                var result3 = result2 !== null
                ? (function(h1, h2, h3, h4) {
                  return String.fromCharCode(parseInt("0x" + h1 + h2 + h3 + h4));
                })(result2[1], result2[2], result2[3], result2[4])
                : null;
                if (result3 !== null) {
                  var result1 = result3;
                } else {
                  var result1 = null;
                  pos = savedPos0;
                }
                if (result1 !== null) {
                  var result0 = result1;
                } else {
                  var result0 = null;;
                };
              };
              };
            };
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_digits() {
          var cacheKey = 'digits@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos0 = pos;
          if (input.substr(pos).match(/^[0-9]/) !== null) {
            var result3 = input.charAt(pos);
            pos++;
          } else {
            var result3 = null;
            if (reportMatchFailures) {
              matchFailed("[0-9]");
            }
          }
          if (result3 !== null) {
            var result1 = [];
            while (result3 !== null) {
              result1.push(result3);
              if (input.substr(pos).match(/^[0-9]/) !== null) {
                var result3 = input.charAt(pos);
                pos++;
              } else {
                var result3 = null;
                if (reportMatchFailures) {
                  matchFailed("[0-9]");
                }
              }
            }
          } else {
            var result1 = null;
          }
          var result2 = result1 !== null
          ? (function(ds) {
            return parseInt((ds.join('')), 10);
          })(result1)
          : null;
          if (result2 !== null) {
            var result0 = result2;
          } else {
            var result0 = null;
            pos = savedPos0;
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_hexDigit() {
          var cacheKey = 'hexDigit@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          if (input.substr(pos).match(/^[0-9a-fA-F]/) !== null) {
            var result0 = input.charAt(pos);
            pos++;
          } else {
            var result0 = null;
            if (reportMatchFailures) {
              matchFailed("[0-9a-fA-F]");
            }
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse__() {
          var cacheKey = '_@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }

          var savedReportMatchFailures = reportMatchFailures;
          reportMatchFailures = false;
          var savedPos0 = pos;
          var result1 = [];
          var result3 = parse_whitespace();
          while (result3 !== null) {
            result1.push(result3);
            var result3 = parse_whitespace();
          }
          var result2 = result1 !== null
          ? (function(w) { return w.join(''); })(result1)
          : null;
          if (result2 !== null) {
            var result0 = result2;
          } else {
            var result0 = null;
            pos = savedPos0;
          }
          reportMatchFailures = savedReportMatchFailures;
          if (reportMatchFailures && result0 === null) {
            matchFailed("whitespace");
          }

          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_whitespace() {
          var cacheKey = 'whitespace@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          if (input.substr(pos).match(/^[ 	\n\r]/) !== null) {
            var result0 = input.charAt(pos);
            pos++;
          } else {
            var result0 = null;
            if (reportMatchFailures) {
              matchFailed("[ 	\\n\\r]");
            }
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function buildErrorMessage() {
          function buildExpected(failuresExpected) {
            failuresExpected.sort();

            var lastFailure = null;
            var failuresExpectedUnique = [];
            for (var i = 0; i < failuresExpected.length; i++) {
              if (failuresExpected[i] !== lastFailure) {
                failuresExpectedUnique.push(failuresExpected[i]);
                lastFailure = failuresExpected[i];
              }
            }

            switch (failuresExpectedUnique.length) {
              case 0:
                return 'end of input';
              case 1:
                return failuresExpectedUnique[0];
              default:
                return failuresExpectedUnique.slice(0, failuresExpectedUnique.length - 1).join(', ')
              + ' or '
              + failuresExpectedUnique[failuresExpectedUnique.length - 1];
            }
          }

          var expected = buildExpected(rightmostMatchFailuresExpected);
          var actualPos = Math.max(pos, rightmostMatchFailuresPos);
          var actual = actualPos < input.length
          ? quote(input.charAt(actualPos))
          : 'end of input';

          return 'Expected ' + expected + ' but ' + actual + ' found.';
        }

        function computeErrorPosition() {
          /*
          * The first idea was to use |String.split| to break the input up to the
          * error position along newlines and derive the line and column from
          * there. However IE's |split| implementation is so broken that it was
          * enough to prevent it.
          */

          var line = 1;
          var column = 1;
          var seenCR = false;

          for (var i = 0; i <  rightmostMatchFailuresPos; i++) {
            var ch = input.charAt(i);
            if (ch === '\n') {
              if (!seenCR) { line++; }
              column = 1;
              seenCR = false;
            } else if (ch === '\r' | ch === '\u2028' || ch === '\u2029') {
              line++;
              column = 1;
              seenCR = true;
            } else {
              column++;
              seenCR = false;
            }
          }

          return { line: line, column: column };
        }



        var result = parseFunctions[startRule]();

        /*
        * The parser is now in one of the following three states:
        *
        * 1. The parser successfully parsed the whole input.
        *
        *    - |result !== null|
        *    - |pos === input.length|
        *    - |rightmostMatchFailuresExpected| may or may not contain something
        *
        * 2. The parser successfully parsed only a part of the input.
        *
        *    - |result !== null|
        *    - |pos < input.length|
        *    - |rightmostMatchFailuresExpected| may or may not contain something
        *
        * 3. The parser did not successfully parse any part of the input.
        *
        *   - |result === null|
        *   - |pos === 0|
        *   - |rightmostMatchFailuresExpected| contains at least one failure
        *
        * All code following this comment (including called functions) must
        * handle these states.
        */
        if (result === null || pos !== input.length) {
          var errorPosition = computeErrorPosition();
          throw new this.SyntaxError(
            buildErrorMessage(),
            errorPosition.line,
            errorPosition.column
          );
        }

        return result;
      },

      /* Returns the parser source code. */
      toSource: function() { return this._source; }
    };

    /* Thrown when a parser encounters a syntax error. */

    result.SyntaxError = function(message, line, column) {
      this.name = 'SyntaxError';
      this.message = message;
      this.line = line;
      this.column = column;
    };

    result.SyntaxError.prototype = Error.prototype;

    return result;
  })();

  MessageFormat.prototype.parse = function () {
    // Bind to itself so error handling works
    return mparser.parse.apply( mparser, arguments );
  };

  MessageFormat.prototype.precompile = function ( ast ) {
    var self = this,
        needOther = false,
        fp = {
      begin: 'function(d){\nvar r = "";\n',
      end  : "return r;\n}"
    };

    function interpMFP ( ast, data ) {
      // Set some default data
      data = data || {};
      var s = '', i, tmp, lastkeyname;

      switch ( ast.type ) {
        case 'program':
          return interpMFP( ast.program );
        case 'messageFormatPattern':
          for ( i = 0; i < ast.statements.length; ++i ) {
            s += interpMFP( ast.statements[i], data );
          }
          return fp.begin + s + fp.end;
        case 'messageFormatPatternRight':
          for ( i = 0; i < ast.statements.length; ++i ) {
            s += interpMFP( ast.statements[i], data );
          }
          return s;
        case 'messageFormatElement':
          data.pf_count = data.pf_count || 0;
          s += 'if(!d){\nthrow new Error("MessageFormat: No data passed to function.");\n}\n';
          if ( ast.output ) {
            s += 'r += d["' + ast.argumentIndex + '"];\n';
          }
          else {
            lastkeyname = 'lastkey_'+(data.pf_count+1);
            s += 'var '+lastkeyname+' = "'+ast.argumentIndex+'";\n';
            s += 'var k_'+(data.pf_count+1)+'=d['+lastkeyname+'];\n';
            s += interpMFP( ast.elementFormat, data );
          }
          return s;
        case 'elementFormat':
          if ( ast.key === 'select' ) {
            s += interpMFP( ast.val, data );
            s += 'r += (pf_' +
                 data.pf_count +
                 '[ k_' + (data.pf_count+1) + ' ] || pf_'+data.pf_count+'[ "other" ])( d );\n';
          }
          else if ( ast.key === 'plural' ) {
            s += interpMFP( ast.val, data );
            s += 'if ( pf_'+(data.pf_count)+'[ k_'+(data.pf_count+1)+' + "" ] ) {\n';
            s += 'r += pf_'+data.pf_count+'[ k_'+(data.pf_count+1)+' + "" ]( d ); \n';
            s += '}\nelse {\n';
            s += 'r += (pf_' +
                 data.pf_count +
                 '[ MessageFormat.locale["' +
                 self.fallbackLocale +
                 '"]( k_'+(data.pf_count+1)+' - off_'+(data.pf_count)+' ) ] || pf_'+data.pf_count+'[ "other" ] )( d );\n';
            s += '}\n';
          }
          return s;
        /* // Unreachable cases.
        case 'pluralStyle':
        case 'selectStyle':*/
        case 'pluralFormatPattern':
          data.pf_count = data.pf_count || 0;
          s += 'var off_'+data.pf_count+' = '+ast.offset+';\n';
          s += 'var pf_' + data.pf_count + ' = { \n';
          needOther = true;
          // We're going to simultaneously check to make sure we hit the required 'other' option.

          for ( i = 0; i < ast.pluralForms.length; ++i ) {
            if ( ast.pluralForms[ i ].key === 'other' ) {
              needOther = false;
            }
            if ( tmp ) {
              s += ',\n';
            }
            else{
              tmp = 1;
            }
            s += '"' + ast.pluralForms[ i ].key + '" : ' + interpMFP( ast.pluralForms[ i ].val,
          (function(){ var res = JSON.parse(JSON.stringify(data)); res.pf_count++; return res; })() );
          }
          s += '\n};\n';
          if ( needOther ) {
            throw new Error("No 'other' form found in pluralFormatPattern " + data.pf_count);
          }
          return s;
        case 'selectFormatPattern':

          data.pf_count = data.pf_count || 0;
          s += 'var off_'+data.pf_count+' = 0;\n';
          s += 'var pf_' + data.pf_count + ' = { \n';
          needOther = true;

          for ( i = 0; i < ast.pluralForms.length; ++i ) {
            if ( ast.pluralForms[ i ].key === 'other' ) {
              needOther = false;
            }
            if ( tmp ) {
              s += ',\n';
            }
            else{
              tmp = 1;
            }
            s += '"' + ast.pluralForms[ i ].key + '" : ' + interpMFP( ast.pluralForms[ i ].val,
              (function(){
                var res = JSON.parse( JSON.stringify( data ) );
                res.pf_count++;
                return res;
              })()
            );
          }
          s += '\n};\n';
          if ( needOther ) {
            throw new Error("No 'other' form found in selectFormatPattern " + data.pf_count);
          }
          return s;
        /* // Unreachable
        case 'pluralForms':
        */
        case 'string':
          return 'r += "' + MessageFormat.Utils.numSub(
            MessageFormat.Utils.escapeExpression( ast.val ),
            'k_' + data.pf_count + ' - off_' + ( data.pf_count - 1 ),
            data.pf_count
          ) + '";\n';
        default:
          throw new Error( 'Bad AST type: ' + ast.type );
      }
    }
    return interpMFP( ast );
  };

  MessageFormat.prototype.compile = function ( message ) {
    return (new Function( 'MessageFormat',
      'return ' +
        this.precompile(
          this.parse( message )
        )
    ))(MessageFormat);
  };


  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = MessageFormat;
    }
    exports.MessageFormat = MessageFormat;
  }
  else if (typeof swifty.define === 'function' && swifty.define.amd) {
    swifty.define('swiftylib/i18n/messageformat',[],function() {
      return MessageFormat;
    });
  }
  else {
    root['MessageFormat'] = MessageFormat;
  }

})( this );

swifty.define( 'swiftylib/i18n/i18n',[
    'jquery',
    'can/construct',
    'can/compute',
    'can/map',
    './messageformat'//,
    // Other
//    'json!ui/i18n/locales/en.json'
], function(
    $, Construct, Compute, Map, MessageFormat
) {
    


    var locale2 = new Compute(); // dorh
    var cache2 = new Map(); // dorh

    var compileText2 = function( key, data, lang ) { // dorh
        var msgFormat = new MessageFormat();
        var keys = key.split( '|' );
        var msg;

        // Here we find the template at n levels deep.
        while ( keys[ 0 ] && lang ) {
            lang = lang[ keys.shift() ];
        }

        if ( lang == null ) {
            lang = key; // dorh This used to be '???', can we leave it this way for quicker development?
        }

        if ( typeof data === 'string' && data.length > 0 ) {
            msg = msgFormat.compile( lang );
            return msg( data || {} );
        } else {
            return '';
        }
    };

    return new Construct( {
//        supportedLocales: [
//            'en',
//            'nl'
//        ],

        cache: cache2, // dorh new Observe(),

        locale: locale2, // dorh new Compute(),

        init: function() {
//            this.locale( this.getLocale() );
            this.locale( 'nl' );
        },

//        getLocale:  function() {
//            var self = this;
//            var locale;
//
//            if ( isDefined( window.navigator ) ) {
//                locale = window.navigator.userLanguage || window.navigator.language;
//
//                if ( !locale ) {
//                    return cfg.locale;
//                } else {
//                    locale = locale.toLowerCase().split( '-' )[ 0 ];
//
//                    if ( !contains( self.supportedLocales, locale ) ) {
//                        return cfg.locale;
//                    }
//                }
//
//                return locale;
//            } else {
//                return cfg.locale;
//            }
//        },

        print: function() {
            var self = this;

            return new Compute( function( key, data ) {
                // dorh Since CanJs 2.0 we sometimes get undefined as key
                if( ! key ) {
                    return '';
                }

                var path = self.locale() + '|' + key;

//                require( [
//                    'json!ui/i18n/locales/' + self.locale()  + '.json'
//                ], function( lang ) {
                var lang = swifty_data.i18n;

                self.cache.attr( path, self.compileText( key, data, lang ) );
//                } );

                return self.cache.attr( path );
            } );
        },

        printMus: function() {
//            var self = this;

//            console.log( 'eee222', self, arguments );

//            return new Compute( function( key, data ) {
                // dorh Since CanJs 2.0 we sometimes get undefined as key
//                if( ! key ) {
//                    return '';
//                }

                var keyName = '';
                $.each( arguments, function( ii, val ) {
//                    console.log( 'ddd333', typeof val );
                    if( typeof val === 'function' ) { // dorh isFunction?
                        keyName += val();
                    }
                    if( typeof val === 'string' ) { // dorh isString?
                        keyName += val;
                    }
                } );
//                console.log( 'ddd444', keyName, locale2() );

                var path = locale2() + '|' + keyName;

//                require( [
//                    'json!ui/i18n/locales/' + locale2()  + '.json'
//                ], function( lang ) {
                    var lang = swifty_data.i18n;
//                    console.log( 'ddd555', compileText2( keyName, keyName, lang ) );
                    var compTxt = compileText2( keyName, keyName, lang );

                    // Replace '[key]' in the string by the value of that key in the current context
                    var lastArg = arguments[ arguments.length - 1 ];
                    if( typeof lastArg === 'object' && lastArg.context ) {
                        var rePattern = /\[(.+?)\]/gi;
                        compTxt = compTxt.replace(rePattern, function(match, text/*, urlId*/){
                            function recursiveFindInContext( con, text ) {
                                if( con._context && con._context[ text ] ) {
                                    return con._context[ text ];
                                }
                                if( con._parent ) {
                                    return recursiveFindInContext( con._parent, text );
                                }
                                return '[' + text + ']';
                            }
                            return recursiveFindInContext( lastArg.contexts, text );
                        });
                    }

                    cache2.attr( path.replace( /\./gi, '_dot_' ), compTxt );
//                } );

                return cache2.attr( path.replace( /\./gi, '_dot_' ) );
//            } );
        },

        compileText: function( key, data, lang ) {
            var msgFormat = new MessageFormat();
            var keys = key.split( '|' );
            var msg;

            // Here we find the template at n levels deep.
            while ( keys[ 0 ] && lang ) {
                lang = lang[ keys.shift() ];
            }

            if ( lang == null ) {
                lang = key; // dorh This used to be '???', can we leave it this way for quicker development?
            }

            msg = msgFormat.compile( lang );

            return msg( data || {} );
        }
    } );
} );
swifty.define( 'swiftylib/i18n/i18n_instance',[
    './i18n'
], function( I18n ) {
    

    return new I18n();
} );
swifty.define( 'swiftylib/i18n/__',[
    './i18n_instance'
], function( i18nInstance ) {
    

    return i18nInstance.printMus;
} );
swifty.define( 'swiftylib/evt',[
    'jquery',
    'can' //'canself' //'can/../can'
], function( $, can ) {
    

    function evt( cmd, data, el ){
        var dfd = new $.Deferred();
        var can2 = can;
        var el2 = typeof el !== 'undefined' ? el : window;

        can2.trigger(
            el2,
            'evt_swc_' + cmd,
            [ data, dfd ]
        );

        if( window.parent && window.parent !== window ) {
            can2 = window.parent.can;
            el2 = typeof el !== 'undefined' ? el : window.parent;

            if( can2 ) {
                can2.trigger(
                    el2,
                    'evt_swc_' + cmd,
                    [ data, dfd ]
                );
            }
        }

        if( document.querySelectorAll( 'iframe.swifty_event_frame' ).length > 0 ) {
            var win = document.querySelectorAll( 'iframe.swifty_event_frame' )[ 0 ].contentWindow;
            can2 = win.can;
            el2 = typeof el !== 'undefined' ? el : win;

            if( can2 ) {
                can2.trigger(
                    el2,
                    'evt_swc_' + cmd,
                    [ data, dfd ]
                );
            }
        }

        return dfd;
    }

    return evt;
} );

swifty.define( 'swiftylib/map',[
    'can/map'
], function( Map ) {
    

    return Map;
} );

/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#construct/super/super*/
swifty.define('can/construct/super',[
    'can/util/library',
    'can/construct'
], function (can, Construct) {
    var isFunction = can.isFunction, fnTest = /xyz/.test(function () {
            return this.xyz;
        }) ? /\b_super\b/ : /.*/, getset = [
            'get',
            'set'
        ], getSuper = function (base, name, fn) {
            return function () {
                var tmp = this._super, ret;
                this._super = base[name];
                ret = fn.apply(this, arguments);
                this._super = tmp;
                return ret;
            };
        };
    can.Construct._defineProperty = function (addTo, base, name, descriptor) {
        var _super = Object.getOwnPropertyDescriptor(base, name);
        if (_super) {
            can.each(getset, function (method) {
                if (isFunction(_super[method]) && isFunction(descriptor[method])) {
                    descriptor[method] = getSuper(_super, method, descriptor[method]);
                } else if (!isFunction(descriptor[method])) {
                    descriptor[method] = _super[method];
                }
            });
        }
        Object.defineProperty(addTo, name, descriptor);
    };
    can.Construct._overwrite = function (addTo, base, name, val) {
        addTo[name] = isFunction(val) && isFunction(base[name]) && fnTest.test(val) ? getSuper(base, name, val) : val;
    };
    return can;
});
/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#construct/proxy/proxy*/
swifty.define('can/construct/proxy',[
    'can/util/library',
    'can/construct'
], function (can, Construct) {
    var isFunction = can.isFunction, isArray = can.isArray, makeArray = can.makeArray, proxy = function (funcs) {
            var args = makeArray(arguments), self;
            funcs = args.shift();
            if (!isArray(funcs)) {
                funcs = [funcs];
            }
            self = this;
            return function class_cb() {
                var cur = args.concat(makeArray(arguments)), isString, length = funcs.length, f = 0, func;
                for (; f < length; f++) {
                    func = funcs[f];
                    if (!func) {
                        continue;
                    }
                    isString = typeof func === 'string';
                    cur = (isString ? self[func] : func).apply(self, cur || []);
                    if (f < length - 1) {
                        cur = !isArray(cur) || cur._use_call ? [cur] : cur;
                    }
                }
                return cur;
            };
        };
    can.Construct.proxy = can.Construct.prototype.proxy = proxy;
    var correctedClasses = [
            can.Map,
            can.Control,
            can.Model
        ], i = 0;
    for (; i < correctedClasses.length; i++) {
        if (correctedClasses[i]) {
            correctedClasses[i].proxy = proxy;
        }
    }
    return can;
});
swifty.define( 'swiftylib/construct',[
    'can/construct',
    // other
    'can/construct/super',
    'can/construct/proxy'
], function( Construct ) {
    

    return Construct;
} );

swifty.define( 'swiftylib/control',[
    'can', //'canself', //'can/../can',
    'can/control',
    // other
    './construct'
//    'can/control/route'
], function( can, Control ) {
    

    patchCanjsLiveBindingEachKeypress();

    ////////////////////////////////////

    // Contains a lot of original code from Canjs
    // Do not restyle or change quotes!!!

    function patchCanjsLiveBindingEachKeypress() {
        var Value = Control.extend({
                init: function() {
                    // Handle selects by calling `set` after this thread so the rest of the element can finish rendering.
                    if (this.element[0].nodeName.toUpperCase() === 'SELECT') {
                        setTimeout(can.proxy(this.set, this), 1);
                    } else {
                        this.set();
                    }

                },
                // If the live bound data changes, call set to reflect the change in the dom.
                "{value} change": "set",
                set: function() {
                    // This may happen in some edgecases, esp. with selects that are not in DOM after the timeout has fired
                    if (!this.element) {
                        return;
                    }
                    var val = this.options.value();
                    // Set the element's value to match the attribute that was passed in
                    if( this.element[0].value !== (val == null ? '' : val) ) {
                        this.element[0].value = (val == null ? '' : val);
                    }
                },
                // If the input value changes, this will set the live bound data to reflect the change.
                "change": function() {
                    // This may happen in some edgecases, esp. with selects that are not in DOM after the timeout has fired
                    if (!this.element) {
                        return;
                    }
                    // Set the value of the attribute passed in to reflect what the user typed
                    if( this.element[0].value !== this.options.value() ) {
                        this.options.value(this.element[0].value);
                    }
                },
                "keyup": function(){
                  this.options.value(this.element[0].value)
                }
            });

        var Content = Control.extend({
            init: function () {
                this.set();
                this.on("blur", "setValue");
            },
            "{value} change": "set",
            set: function () {
                var val = this.options.value();
                this.element[0].innerHTML = (typeof val === 'undefined' ? '' : val);
            },
            setValue: function () {
                this.options.value(this.element[0].innerHTML);
            },
            "keyup": function(){
              this.options.value(this.element[0].innerHTML)
            }
        });

        var Checked = Control.extend({
            init: function () {
                // If its not a checkbox, its a radio input
                this.isCheckbox = (this.element[0].type.toLowerCase() === "checkbox");
                this.check();
            },
            // `value` is the compute representing the can-value for this element.  For example can-value="foo" and current
            // scope is someObj, value is the compute representing someObj.attr('foo')
            "{value} change": "check",
            check: function () {
                // jshint eqeqeq: false
                if (this.isCheckbox) {
                    var value = this.options.value(),
                        trueValue = this.options.trueValue || true;
                    // If `can-true-value` attribute was set, check if the value is equal to that string value, and set
                    // the checked property based on their equality.
                    this.element[0].checked = (value === trueValue);
                }
                // Its a radio input type
                else {
                    var setOrRemove = this.options.value() == this.element[0].value ?
                        "set" : "remove";

                    can.attr[setOrRemove](this.element[0], 'checked', true);

                }

            },
            // This event is triggered by the DOM.  If a change event occurs, we must set the value of the compute (options.value).
            "change": function () {

                if (this.isCheckbox) {
                    // If the checkbox is checked and can-true-value was used, set value to the string value of can-true-value.  If
                    // can-false-value was used and checked is false, set value to the string value of can-false-value.
                    this.options.value(this.element[0].checked ? this.options.trueValue : this.options.falseValue);
                }
                // Radio input type
                else {
                    if (this.element[0].checked) {
                        this.options.value(this.element[0].value);
                    }
                }

            }
        });

        var isContentEditable = (function() {
            // A contenteditable element has a value of an empty string or "true"
            var values = {
                "": true,
                "true": true,
                "false": false
            };

            // Tests if an element has the appropriate contenteditable attribute
            var editable = function(el) {
                // DocumentFragments do not have a getAttribute
                if (!el || !el.getAttribute) {
                    return;
                }

                var attr = el.getAttribute("contenteditable");
                return values[attr];
            };

            return function(el) {
                // First check if the element is explicitly true or false
                var val = editable(el);
                if (typeof val === "boolean") {
                    return val;
                } else {
                    // Otherwise, check the parent
                    return !!editable(el.parentNode);
                }
            };
        })();

        var removeCurly = function(value) {
                if (value[0] === "{" && value[value.length - 1] === "}") {
                    return value.substr(1, value.length - 2);
                }
                return value;
            };

        can.view.attr("can-value", function(el, data) {

            var attr = removeCurly(el.getAttribute("can-value")),
                // Turn the attribute passed in into a compute.  If the user passed in can-value="name" and the current
                // scope of the template is some object called data, the compute representing this can-value will be the
                // data.attr('name') property.
                value = data.scope.computeData(attr, {
                        args: []
                    })
                    .compute,
                trueValue,
                falseValue;

            // Depending on the type of element, this attribute has different behavior. can.Controls are defined (further below
            // in this file) for each type of input. This block of code collects arguments and instantiates each can.Control. There
            // is one for checkboxes/radios, another for multiselect inputs, and another for everything else.
            if (el.nodeName.toLowerCase() === "input" || el.nodeName.toLowerCase() === "textarea") {
                if (el.type === "checkbox") {
                    // If the element is a checkbox and has an attribute called "can-true-value",
                    // set up a compute that toggles the value of the checkbox to "true" based on another attribute.
                    // 		<input type='checkbox' can-value='sex' can-true-value='male' can-false-value='female' />
                    if (can.attr.has(el, "can-true-value")) {
                        trueValue = el.getAttribute("can-true-value");
                    } else {
                        trueValue = true;
                    }
                    if (can.attr.has(el, "can-false-value")) {
                        falseValue = el.getAttribute("can-false-value");
                    } else {
                        falseValue = false;
                    }
                }

                if (el.type === "checkbox" || el.type === "radio") {
                    // For checkboxes and radio buttons, create a Checked can.Control around the input.  Pass in
                    // the compute representing the can-value and can-true-value and can-false-value properties (if
                    // they were used).
                    new Checked(el, {
                            value: value,
                            trueValue: trueValue,
                            falseValue: falseValue
                        });
                    return;
                }
            }
            if (el.nodeName.toLowerCase() === "select" && el.multiple) {
                // For multiselect enabled select inputs, we instantiate a special control around that select element
                // called Multiselect
                new Multiselect(el, {
                        value: value
                    });
                return;
            }
            // For contenteditable elements, we instantiate a Content control.
            if (isContentEditable(el)) {
                new Content(el, {
                        value: value
                    });
                return;
            }
            // The default case. Instantiate the Value control around the element. Pass it the compute representing
            // the observable attribute property that was set.
            new Value(el, {
                    value: value
                });
        });
    }

    return Control;
} );

swifty.define( 'js/libs/yepnope',[], function() {




// yepnope.js
// v2.0.0
//
// by
// Alex Sexton - @slexaxton - alexsexton[at]gmail.com
// Ralph Holzmann - @rlph - ralphholzmann[at]gmail.com
//
// http://yepnopejs.com/
// https://github.com/SlexAxton/yepnope.js/
//
// New BSD
//
// Consider inlining this script after minifying

window.yepnope = (function (window, document, undef) {
  // Yepnope's style is intentionally very flat to aid in
  // minification. The authors are usually against too much
  // self-minification, but in the case of a script loader, we're
  // especially file size sensitive.

  // Some aliases
  var sTimeout = window.setTimeout;
  var firstScript;
  var scriptsQueue = [];
  var count = 0;
  var toString = {}.toString;

  // This is just used for a race condition,
  // so even if it fails it's not a huge risk
  var isOldIE = !!document.attachEvent && !(window.opera && toString.call(window.opera) == '[object Opera]');

  function noop(){}

  // Helper functions
  function isObject(obj) {
    return Object(obj) === obj;
  }

  function isString(s) {
    return typeof s == 'string';
  }

  // Loader Utilities
  function uniq() {
    return 'yn_' + (count++);
  }

  function readFirstScript() {
    if (!firstScript || !firstScript.parentNode) {
      firstScript = document.getElementsByTagName('script')[0];
    }
  }

  function isFileReady(readyState) {
    // Check to see if any of the ways a file can be ready are available as properties on the file's element
    return (!readyState || readyState == 'loaded' || readyState == 'complete' || readyState == 'uninitialized');
  }

  function runWhenReady(src, cb) {
      cb.call(window);
  }

  // Inject a script into the page and know when it's done
  function injectJs(options, cb) {
    var src;
    var attrs;
    var timeout;

    if (isString(options)) {
      src = options;
    }
    else if (isObject(options)) {
      // Allow rewritten url to take precedence
      src = options._url || options.src;
      attrs = options.attrs;
      timeout = options.timeout;
    }

    cb = cb || noop;
    attrs = attrs || {};

    var script = document.createElement('script');
    var done;
    var i;

    timeout = timeout || yepnope.errorTimeout;

    script.src = src;

    // IE Race condition
    // http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
    if (isOldIE) {
      script.event = 'onclick';
      script.id = script.htmlFor = attrs.id || uniq();
    }

    // Add our extra attributes to the script element
    for (i in attrs) {
      script.setAttribute(i, attrs[i]);
    }

    // Bind to load events
    script.onreadystatechange = script.onload = function () {

      if ( !done && isFileReady(script.readyState) ) {
        // Set done to prevent this function from being called twice.
        done = 1;

        // Second half of IE race condition hack
        if (isOldIE) {
          try {
            // By calling this here, we create a synchronous
            // execution of the contents of the script
            // and the execution of the callback below.
            script.onclick();
          }
          catch (e) {}
        }

        // Just run the callback
        runWhenReady(src, cb);
      }

      // Handle memory leak in IE
      script.onload = script.onreadystatechange = script.onerror = null;
    };

    // This won't work in every browser, but
    // would be helpful in those that it does.
    // http://stackoverflow.com/questions/2027849/how-to-trigger-script-onerror-in-internet-explorer/2032014#2032014
    // For those that don't support it, the timeout will be the backup
    script.onerror = function () {
      // Don't call the callback again, so we mark it done
      done = 1;
      cb(new Error('Script Error: ' + src));
      // We don't waste bytes on cleaning up memory in error cases
      // because hopefully it doesn't happen often enough to matter.
      // And you're probably already in an 'uh-oh' situation.
    };

    // 404 Fallback
    sTimeout(function () {
      // Don't do anything if the script has already finished
      if (!done) {
        // Mark it as done, which means the callback won't run again
        done = 1;

        // Might as well pass in an error-state if we fire the 404 fallback
        cb(new Error('Timeout: ' + src));
        // Maybe...
        script.parentNode.removeChild(script);
      }
    }, timeout);

    // Inject script into to document
    readFirstScript();
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  function injectCss(options, cb) {
    var attrs = {};
    var href;
    var i;
    var media;

    // optionally accept an object of settings
    // or a string that's the url
    if (isObject(options)) {
      // allow the overriden _url property to take precendence
      href = options._url || options.href;
      attrs = options.attrs || {};
    }
    else if (isString(options)) {
      href = options;
    }

    // Create stylesheet link
    var link = document.createElement('link');

    cb = cb || noop;

    // Add attributes
    link.href = href;
    link.rel = 'stylesheet';
    // Technique to force non-blocking loading from:
    // https://github.com/filamentgroup/loadCSS/blob/master/loadCSS.js#L20
    link.media = 'only x';
    link.type = 'text/css';

    // On next tick, just set the media to what it's supposed to be
    sTimeout(function() {
      link.media = attrs.media || 'all';
    });

    // Add our extra attributes to the link element
    for (i in attrs) {
      link.setAttribute(i, attrs[i]);
    }

    readFirstScript();
    // We append link tags so the cascades work as expected.
    // A little more dangerous, but if you're injecting CSS
    // dynamically, you probably can handle it.
    firstScript.parentNode.appendChild(link);

    // Always just run the callback for CSS on next tick. We're not
    // going to try to normalize this, so don't worry about runwhenready here.
    sTimeout(function() {
      cb.call(window);
    });
  }

  function getExtension(url) {
    //The extension is always the last characters before the ? and after a period.
    //The previous method was not accounting for the possibility of a period in the query string.
    var b = url.split('?')[0];
    return b.substr(b.lastIndexOf('.')+1);
  }

  function defaultUrlFormatter(base, tests) {
    var url = base;
    var passed = [];
    var failed = [];

    for(var i in tests) {
      if (tests.hasOwnProperty(i)) {
        if (tests[i]) {
          passed.push(encodeURIComponent(i));
        }
        else {
          failed.push(encodeURIComponent(i));
        }
      }
    }

    if (passed.length || failed.length) {
      url += '?';
    }

    if (passed.length) {
      url += 'yep=' + passed.join(',');
    }

    if (failed.length) {
      url += (passed.length ? '&' : '') + 'nope=' + failed.join(',');
    }

    return url;
  }

  // The leaked function. Mostly just takes a set
  // of arguments, and then passes them to be run.
  function yepnope(url, tests, cb) {
    var options;

    if (isObject(url)) {
      // It was just kidding about being the url
      options = url;
      // Can't ever have both, so this is fine
      url = options.src || options.href;
    }

    url = yepnope.urlFormatter(url, tests);

    if (!options) {
      options = {_url: url};
    }
    else {
      options._url = url;
    }

    var type = getExtension(url);

    if (type === 'js') {
      injectJs(options, cb);
    }
    else if (type === 'css') {
      injectCss(options, cb);
    }
    else {
      throw new Error('Unable to determine filetype.');
    }
  }

  // Add a default for the error timer
  yepnope.errorTimeout = 10e3;
  // Expose no BS script injection
  yepnope.injectJs = injectJs;
  // Expose super-lightweight css injector
  yepnope.injectCss = injectCss;
  // Allow someone to override the url writer
  yepnope.urlFormatter = defaultUrlFormatter;

  return yepnope;
})(window, document);





return window.yepnope; } );
swifty.define( 'js/diverse/utils',[
    'jquery',
    'swiftylib/construct'
], function(
    $, Construct
) {
    

    var Utils = Construct.extend( {

    }, {
        // taken from http://stackoverflow.com/questions/5999118/add-or-update-query-string-parameter
        // replace/update/remove the querystring parameters based on the users input and taking the urls anchor into consideration.
        //
        // Not supplying a value will remove the parameter, supplying one will add/update the parameter. If no URL is supplied,
        // it will be grabbed from window.location
        updateQueryString: function( key, value, url ) {
            if( ! url ) {
                url = window.location.href;
            }

            var re = new RegExp( '([?&])' + key + '=.*?(&|#|$)(.*)', 'gi' ),
                hash;

            if( re.test( url ) ) {
                if( typeof value !== 'undefined' && value !== null ) {
                    return url.replace( re, '$1' + key + '=' + value + '$2$3' );
                } else {
                    hash = url.split( '#' );
                    url = hash[ 0 ].replace( re, '$1$3' ).replace( /(&|\?)$/, '' );

                    if( typeof hash[ 1 ] !== 'undefined' && hash[ 1 ] !== null ) {
                        url += '#' + hash[ 1 ];
                    }

                    return url;
                }
            } else {
                if( typeof value !== 'undefined' && value !== null ) {
                    var separator = url.indexOf( '?' ) !== - 1 ? '&' : '?';

                    hash = url.split( '#' );
                    url = hash[ 0 ] + separator + key + '=' + value;

                    if( typeof hash[ 1 ] !== 'undefined' && hash[ 1 ] !== null ) {
                        url += '#' + hash[ 1 ];
                    }

                    return url;
                } else {
                    return url;
                }
            }
        },

        getSWCreatorAjaxUrl: function() {
            return this.updateQueryString( 'swcreator_ajax', true, scc_data.view_url );
        },

        // ucs-2 string to base64 encoded ascii
        utoa: function( str ) {
            return window.btoa( encodeURIComponent( str ).replace( /%([0-9A-F]{2})/g, function( match, p1 ) {
                return String.fromCharCode( '0x' + p1 );
            } ) );
        },

        // base64 encoded ascii to ucs-2 string
        atou: function( str ) {
            return decodeURIComponent( Array.prototype.map.call( window.atob( str ), function( c ) {
                return '%' + ('00' + c.charCodeAt( 0 ).toString( 16 )).slice( - 2 );
            } ).join( '' ) );
        }
    } );

    return new Utils();

} );

swifty.define('js/libs/mout/src/function/debounce',[],function () {

    /**
     * Debounce callback execution
     */
    function debounce(fn, threshold, isAsap){
        var timeout, result;
        function debounced(){
            var args = arguments, context = this;
            function delayed(){
                if (! isAsap) {
                    result = fn.apply(context, args);
                }
                timeout = null;
            }
            if (timeout) {
                clearTimeout(timeout);
            } else if (isAsap) {
                result = fn.apply(context, args);
            }
            timeout = setTimeout(delayed, threshold);
            return result;
        }
        debounced.cancel = function(){
            clearTimeout(timeout);
        };
        return debounced;
    }

    return debounce;

});

swifty.define( 'js/diverse/iframe_page',[
    'jquery',
    'swiftylib/evt',
    'swiftylib/map',
    'swiftylib/control',
    'js/libs/yepnope',
    'js/diverse/utils',
    'swiftylib/i18n/__',
    'js/libs/mout/src/function/debounce'
], function(
    $, evt, Map, Control, yepnope, Utils, __, debounce
) {
    

    var map = new Map( {
        'selector': '.swc_main_content_pane.swc_page_cntnt'
    } );

    return Control.extend( {
        'defaults': {
            'area_content_selector': '.swc_main_content_pane.swc_page_cntnt',
            'area_names': [ 'topbar', 'header', 'navbar', 'sidebar', 'extrasidebar', 'footer', 'bottombar' ]
        }
    }, {
        init: function() {
            var self = this;

            if( ! self.isEditingMain() ) {
                self.getMap().attr( 'selector', '.swifty_area_inner_content_' + scc_data.area + ' .swc_page_cntnt' );

                self.options.area_content_selector = self.getMap().attr( 'selector' );
            }

            scc_data.pages = $.parseJSON( scc_data.pages );

            self._super();

            self.addSCCModeToPageLinks();

            self.addThemeAreaCogs();

            var beta_message = scc_data.is_swifty_site_designer_active ? '' : '<span>BETA version ' + scc_data.scc_version + '</span>';
            $( '<div class="swc_iframe_gradient">' + beta_message + '</div>' ).appendTo( 'body' );

            self.pafeMouseMovedThrottledObject = debounce( $.proxy( self.endPageMouseMoved, self ), 500 );

            self.on();
        },

        getMap: function() {
            return map;
        },

        isEditingMain: function() {
            return scc_data && ( scc_data.area === 'main' );
        },

        addThemeAreaCogs: function() {
            // add overlay to main area
            $( '.swifty_area_inner_content_main.swifty_area_inner_content' ).prepend( '<div class="swc_theme_edit_overlay" ></div>' );

            // find area's to include overlays
            var $area_wrappers = $( '.swifty_area_included' );

            // make sure the icons and overlays are positioned properly within it's parent
            $area_wrappers.css( 'position', 'relative' );
            $area_wrappers.prepend( '<div class="swc_theme_edit_overlay" ></div>' );

            // add cogs to areas when main area is edited
            if( scc_data.area === 'main' ) {
                $area_wrappers.each( function( ii, area_wrapper ) {
                    var classList = $( area_wrapper ).attr( 'class' ).split( /\s+/ );

                    var areaTemplate = '';
                    $.each( classList, function( index, item ) {
                        var template = item.match( 'swifty_areatemplate_(.*)' );
                        if( template && template.length > 1 && template[1].length > 0 ) {
                            areaTemplate = '" area_template="' + template[1];
                        }
                    } );

                    $.each( classList, function( index, item ) {
                        var areaName = item.match( 'swifty_area_(.*)' );
                        if( areaName && areaName.length > 1 && areaName[1].length > 0 ) {
                            if( ( areaName[1] !== 'included' ) && ( areaName[1] !== 'page_overrule_' ) ) {
                                var divCogs = '<div class="swc_theme_edit_icon_wrapper" title="' + __( 'Click to edit' ) + '" area="' + areaName[1] + areaTemplate + '"><i class="fa fa-cogs" contenteditable="false"></i></div>';
                                $( area_wrapper ).prepend( divCogs );

                                if( scc_data.swifty_gui_mode === 'advanced' ) {
                                    var divAreaVisibility = '<div class="swc_theme_area_visibility_icon_wrapper" title="'
                                        + __( 'Click to hide this area' )
                                        + '" data-area="' + areaName[1] + areaTemplate
                                        + '"><i class="fa fa-eye-slash" contenteditable="false"></i></div>';

                                    $( area_wrapper ).prepend( divAreaVisibility );
                                }

                                return false;
                            }
                        }
                    } );
                } );
            }

            // make sure the icons and overlays are positioned properly within it's parent
            var $wrappers = $( '.swc_theme_edit_icon_wrapper' );

            // === 0 when a area is edited, then set overlay on for all except the edited area
            if( $wrappers.length === 0 ) {
                $( '.swc_theme_edit_overlay' ).css( 'display', 'inline' );
                $( '.swifty_area_' + scc_data.area ).find( '.swc_theme_edit_overlay' ).css( 'display', 'none' );
            } else {
                $wrappers.each( function( ii, icon ) {
                    var $area = $( icon ).parent();
                    var wrapperSelectors = ( scc_data.swifty_gui_mode === 'advanced' )
                        ? '.swc_theme_edit_icon_wrapper, .swc_theme_area_visibility_icon_wrapper'
                        : '.swc_theme_edit_icon_wrapper';

                    $area.on( 'mouseenter', function() {
                        // .swc_theme_edit_icon_wrapper_show
                        $( this ).find( wrapperSelectors ).addClass( 'swc_theme_edit_icon_wrapper_show' );

                        if( scc_data.swifty_gui_mode === 'advanced' ) {
                            $( this ).find( '.swc_theme_area_visibility_icon_wrapper' ).position( {
                                my: 'right',
                                at: 'left-1',
                                of: $( this ).find( '.swc_theme_edit_icon_wrapper' ),
                                collision: 'none'
                            } );
                        }
                    } );

                    $area.on( 'mouseleave', function() {
                        // .swc_theme_edit_icon_wrapper_show
                        $( this ).find( wrapperSelectors ).removeClass( 'swc_theme_edit_icon_wrapper_show' );
                    } );

                    $( icon ).on( 'click', function( ev ) {
                        ev.preventDefault();
                        // show overlays and refresh to edit the selected area
                        $( '.swc_theme_edit_overlay' ).css( 'display', 'inline' );
                        $( this ).parent().find( '.swc_theme_edit_overlay' ).css( 'display', 'none' );

                        var edit_area = $( this ).attr( 'area' );
                        var edit_area_template = $( this ).attr( 'area_template' );

                        evt(
                            'swifty_area_select',
                            {
                                'areaname': __( edit_area ),
                                'edit_area': edit_area,
                                'edit_area_template': edit_area_template
                            }
                        );
                    } );
                } );
            }
        },

        '.swc_theme_area_visibility_icon_wrapper click': function( el, ev ) {
            var self = this;
            var area = $( el ).data( 'area' );

            self.storeCurrentAreas();
            self.changeCurrentArea( area, 'hide', '' );
            self.saveCurrentArea( area, 'hide' );

            ev.preventDefault();
        },

        addSCCModeToPageLinks: function() {
            var self = this;
            var domain = scc_data.domain;

            $( 'a' ).each( function( ) {
                var link = $( this );
                var href = link.attr( 'href' );
                var isEditable = false;
                var $smAdminBar = $( '#smadminbar' );

                if( $.contains( $( '.swc_page_cntnt' )[ 0 ], link[ 0 ] ) ||
                    ( $smAdminBar.length && $.contains( $smAdminBar[ 0 ], link[ 0 ] ) ) ||
                    ( /wp\-(admin|login)/i ).test( href )
                ) {
                    return;
                }

                if( ( new RegExp( domain, 'i' ) ).test( href ) ) {   // Urls within this domain.
                    isEditable = self.isPage( href );
                } else {
                    if( !( /^(http[s]?|www|#)/i ).test( href ) ) {   // Skip urls starting with http, https, www and #.
                        isEditable = self.isPage( href );
                    } else {
                        return;
                    }
                }

                if( isEditable ) {

                    // in editable area? (cke_editable is not set yet, so we use the same selector as for ckeditor)
                    if( link.closest( self.options.area_content_selector ).length > 0 ) {

                        link.on( 'click', function( ev ) {

                            ev.preventDefault();
                            var url = link.attr( 'href' );
                            url = Utils.updateQueryString( 'swcreator_edit', 'main', url );
                            url = Utils.updateQueryString( 'swcreator_area_template', null, url );
                            evt( 'swifty_editor_change_window_location', { 'url': url } );
                        } );
                    } else {
                        link.attr( 'target', '_top' );
                        var url = href;
                        url = Utils.updateQueryString( 'swcreator_edit', 'main', url );
                        url = Utils.updateQueryString( 'swcreator_area_template', null, url );
                        link.attr( 'href', url );
                    }
                }
            } );
        },

        isPage: function( href ) {
            var pageFound = $.grep( scc_data.pages, function( item ) {
                return ( new RegExp( item, 'i' ) ).test( href );
            } );

            if( $.isArray( pageFound ) && pageFound.length ) {   // A SCC editable page was found.
                return true;
            } else {
                var homeUrl = scc_data.home_url;

                homeUrl = homeUrl.replace( /^(https?:\/\/)?(www\.)?/, '' ).replace( /\/$/, '' );

                if( ( new RegExp( homeUrl + '(/)?$', 'i' ) ).test( href ) ) {  // Home url.
                    return true;
                }
            }

            return false;
        },

        processCssAndJsAdditions: function( data ) {
            var self = this;

            if( data.js_css_additions ) {

                // Handle css
                if( $.isArray( data.js_css_additions.css ) && data.js_css_additions.css.length ) {
                    $.each( data.js_css_additions.css, function( ii, styletag ) {
                        var hrefArray = styletag.match( /href=["\'](.*?)["\']/i );

                        if( hrefArray && hrefArray.length > 1 ) {
                            var href = hrefArray[ 1 ];

                            // Check if style link tag not yet exists on the page
                            if( $( 'link:contains("' + href + '")' ).length === 0 ) {
                                $( 'body' ).append( styletag );
                            }
                        }
                    } );
                }

                // Handle inline js
                if( $.isArray( data.js_css_additions.js_inline ) && data.js_css_additions.js_inline.length ) {
                    $.each( data.js_css_additions.js_inline, function( ii, jsInline ) {

                        if( jsInline.id && jsInline.inline ) {

                            // remove old script tags with this id, prevend multiple insertions of this script
                            $( 'script#' + jsInline.id ).remove();

                            var js = document.createElement( 'script' );
                            var first = document.getElementsByTagName( 'script' )[0];
                            js.setAttribute( 'id', jsInline.id );
                            js.innerHTML = jsInline.inline;
                            first.parentNode.insertBefore( js, first );
                        }
                    } );
                }

                // Handle js file includes
                if( $.isArray( data.js_css_additions.js ) && data.js_css_additions.js.length ) {
                    var includeScripts = [];
                    $.each( data.js_css_additions.js, function( ii, jsSrc ) {

                        // is there a protocol included? if not make sure there is one, use the current location
                        if( jsSrc.indexOf( '//' ) === 0 ) {
                            var link = document.createElement( 'a' );
                            //  set href to any path
                            link.setAttribute( 'href', jsSrc );
                            jsSrc = link.href;
                        }

                        // Check if style link tag not yet exists on the page
                        if( ! self.isMyScriptLoaded( jsSrc ) ) {
                            includeScripts.push( jsSrc );
                        }
                    } );
                    self.includeJsFile( 0, includeScripts );
                }
            }
        },

        replaceImageWithAsset: function( $image_wrapper, src, caption, alt, href ) {

            caption = (caption) ? ' caption="' + caption + '"' : '';

            var viewer = (href) ? ' viewer="go_to_url"' : '';
            href = (href) ? ' href="' + href + '"' : '';
            alt = (alt) ? ' alt="' + alt + '"' : '';

            var html = '[swifty_image' + href + viewer + caption + alt + ' url="' + src + '" swc_swifty_on="1"]';

            // Convert the html because it contains shortcodes.
            // The shortcodes will be rendered by the server and included in the returned html.
            $.post(
                Utils.getSWCreatorAjaxUrl(),
                {
                    'action': 'convert_html_with_shortcodes',
                    'id': scc_data.page_id,
                    'ajax_nonce': scc_data.ajax_nonce,
                    'data': html
                },
                function( data ) {
                    data = $.parseJSON( data );

                    // Remove trailing line-end, because that wil cause an extra p tag in CKeditor.
                    data.html = data.html.replace( /\n$/, '' );
                    // Insert the html in the page.
                    evt( 'replace_asset', {
                        'html': data.html,
                        'widget_class': 'swc_asset',
                        '$element': $image_wrapper
                    } );
                }
            );
        },

        /**
         * Store the content of the areas and whether they are visible or not
         * Will store this information only once
         *
         * The methods for temporary changing the areas needs to be called in this order:
         * - storeCurrentAreas
         * - changeCurrentArea <- can be called multiple times for different ares
         * - restoreCurrentAreas
         */
        storeCurrentAreas: function(  ) {
            var self = this;

            if( ! self.areainfo ) {
                self.areainfo = {};

                $.each( self.options.area_names, function( ii, areaName ) {
                    var $area = $( '.swifty_area_' + areaName + '.swifty_area' );
                    if( $area.length === 1 ) {

                        var classList = $area.attr( 'class' ).split( /\s+/ );
                        var areaOverrule = '';
                        $.each( classList, function( index, item ) {
                            var template = item.match( 'swifty_area_page_overrule_(.*)' );
                            if( template && template.length > 1 && template[1].length > 0 ) {
                                areaOverrule = template[1];
                            }
                        } );

                        var $areaContent = $area.find( 'div.swc_page_cntnt' );

                        self.areainfo[ areaName ] = {
                            'areaOverrule': areaOverrule,
                            'areaContent': $areaContent.html()
                        };
                    }
                } );
            }
        },

        /**
         * change content and visibility of a area, only possible after storeCurrentAreas() has been called
         *
         * @param areaName
         * @param areaOverrule
         * @param areaContent
         */
        changeCurrentArea: function( areaName, areaOverrule, areaContent ) {
            var self = this;

            if( self.areainfo ) {
                var $area = $( '.swifty_area_' + areaName + '.swifty_area' );
                if( $area.length === 1 ) {
                    var classList = $area.attr( 'class' ).split( /\s+/ );
                    $.each( classList, function( index, item ) {
                        var template = item.match( 'swifty_area_page_overrule_(.*)' );
                        if( template && template.length > 1 && template[1].length >= 0 ) {
                            $area.removeClass( item );
                        }
                    } );
                    $area.addClass( 'swifty_area_page_overrule_' + areaOverrule );

                    if( areaContent ) {
                        var $areaContent = $area.find( 'div.swc_page_cntnt' );
                        $areaContent.html( areaContent );
                    }

                    $area.attr( 'style', function( i, style ) {
                        var rgx = /min\-height:\s*20px;/;
                        var hasMinHeight = rgx.test( style );

                        if ( areaOverrule !== 'show' && hasMinHeight ) {
                            return style.replace( rgx, '' );
                        }

                        if ( areaOverrule === 'show' && ! hasMinHeight ) {
                            style += ' min-height: 20px;';

                            return style;
                        }

                        return style;
                    } );
                }
            }
        },

        /**
         * restore content and visibility of all areaa, only possible after storeCurrentAreas() has been called
         * a new call to storeCurrentAreas() is needed before using this method again
         */
        restoreCurrentAreas: function(  ) {
            var self = this;

            if( self.areainfo ) {
                $.each( self.options.area_names, function( ii, areaName ) {
                    var $area = $( '.swifty_area_' + areaName + '.swifty_area' );
                    if( $area.length === 1 ) {

                        var classList = $area.attr( 'class' ).split( /\s+/ );
                        $.each( classList, function( index, item ) {
                            var template = item.match( 'swifty_area_page_overrule_(.*)' );
                            if( template && template.length > 1 && template[1].length >= 0 ) {
                                $area.removeClass( item );
                            }
                        } );
                        $area.addClass( 'swifty_area_page_overrule_' + self.areainfo[ areaName ].areaOverrule );

                        var $areaContent = $area.find( 'div.swc_page_cntnt' );
                        $areaContent.html( self.areainfo[ areaName ].areaContent );
                    }
                } );
                self.areainfo = null;
            }
        },

        /**
         * Save content and visibility of a area, only possible after storeCurrentAreas() has been called.
         * Make sure this content is also used when calling restoreCurrentAreas()
         *
         * @param areaName
         * @param areaOverrule, when 'hide' will not save content of area
         */
        saveCurrentArea: function( areaName, areaOverrule ) {
            var self = this;
            var dfd = new $.Deferred();

            if( self.areainfo ) {
                var $area = $( '.swifty_area_' + areaName + '.swifty_area' );
                if( $area.length === 1 ) {
                    var $areaContent = $area.find( 'div.swc_page_cntnt' );

                    self.areainfo[ areaName ] = {
                        'areaOverrule': areaOverrule,
                        'areaContent': $areaContent.html()
                    };

                    self.convertFromAreaHtml( areaName ).done( function( content ) {
                        $areaContent.html( self.areainfo[ areaName ].areaContent );

                        $.post(
                            scc_data.ajax_url,
                            {
                                'action': 'swcreator_save_area_for_page',
                                'id': scc_data.page_id,
                                'ajax_nonce': scc_data.ajax_nonce,
                                'area_name': areaName,
                                'area_visibility': areaOverrule,
                                'area_content': areaOverrule !== 'hide' ? content : null
                            }
                        ).done( function() {
                            dfd.resolve();
                        } );
                    } );
                } else {
                    dfd.resolve();
                }
            } else {
                dfd.resolve();
            }

            return dfd;
        },

        /**
         * Convert the html in a area back to content with shortcodes. Do this by creating a temporary ckeditor component
         * that downcasts this html.
         *
         * @param areaName
         * @returns {jQuery.Deferred}
         */
        convertFromAreaHtml: function( areaName ) {

            var dfd = new $.Deferred();

            var $area = $( '.swifty_area_' + areaName + '.swifty_area' );
            if( $area.length === 1 ) {
                var $areaContent = $area.find( 'div.swc_page_cntnt' );

                evt( 'create_editor', { '$element': $areaContent } ).done( function( $editor ) {

                    setTimeout( function() {
                        var html = $editor.editor.getData();

                        evt( 'swifty_html_to_content', { 'content': html } ).done( function( content ) {
                            $editor.editor.destroy();
                            dfd.resolve( content );
                        } );
                    }, 1 );
                } );
            } else {
                dfd.resolve( '' );
            }

            return dfd;
        },

        convertImageToAsset: function( $image_wrapper ) {
            var self = this;

            if( $image_wrapper.length === 1) {
                var caption = $image_wrapper.find( 'figcaption' ).html();
                var href = $image_wrapper.find( 'a' ).attr( 'href' );
                var alt = $image_wrapper.find( 'img' ).attr( 'alt' );
                var src = $image_wrapper.find( 'img' ).attr( 'src' );
                var classname = $image_wrapper.find( 'img' ).attr( 'class' );

                // Look for attachment id in the class of the img tag.
                var attachId = - 1;
                if( classname ) {
                    var classnames = classname.split( ' ' );
                    $.each( classnames, function( index, value ) {
                        var id = value.match( /wp-image-(\d+)/ );
                        if( id ) {
                            attachId = id[1];
                        }
                    } );
                }

                if( attachId > 0 ) {
                    $.post(
                        scc_data.ajax_url,
                        {
                            'action': 'get-attachment',
                            'id': attachId
                        },
                        function( result ) {
                            if( result.success && result.data ) {

                                var url = result.data.url;
                                if( url ) {
                                    src = url;
                                }
                            }
                            self.replaceImageWithAsset( $image_wrapper, src, caption, alt, href );
                        }
                    );
                } else {
                    self.replaceImageWithAsset( $image_wrapper, src, caption, alt, href );
                }
            }
        },

        convertFromElementHtml: function( $element, dfd ) {

            dfd || ( dfd = new $.Deferred() );

            $( '#swc_convert_html' ).remove();
            $( '<div id="swc_convert_html"></div>' ).appendTo( 'body' );

            var $clone = $element.clone();
            $( '#swc_convert_html' ).append( $clone );

            evt( 'create_editor', { '$element': $( '#swc_convert_html' ) } ).done( function( $editor ) {

                setTimeout( function() {
                    var html = $editor.editor.getData();

                    evt( 'swifty_html_to_content', { 'content': html } ).done( function( content ) {
                        $editor.editor.destroy();
                        $( '#swc_convert_html' ).remove();
                        dfd.resolve( content );
                    } );
                }, 1 );
            } );

            return dfd;
        },

        isMyScriptLoaded: function( url ) {
            var scripts = document.getElementsByTagName( 'script' );
            for( var i = scripts.length; i--; ) {
                if( scripts[ i ].src === url ) {
                    return true;
                }
            }
            return false;
        },

        includeJsFile: function( index, includeScripts ) {
            var self = this;

            if( index < includeScripts.length ) {
                // we already know it is a js file, so we can skip the extension test to make includes to js files without
                // extension working
                yepnope.injectJs( { _url: includeScripts[index] }, function() {
                    self.includeJsFile( index + 1, includeScripts );
                    return false;
                } );
            }
        },

        endPageMouseMoved: function() {
            $( 'body' ).addClass( 'swc_page_m_m_fadeout' );
            setTimeout( function() {
                $( 'body' ).removeClass( 'swc_page_m_m_fadeout' );
                $( 'body' ).removeClass( 'swc_page_mouse_moved' );
            }, 1000 );
        },

        scrollTo: function( $el /*, blink*/ ) {
            var dfd = new $.Deferred();
            var wHeight = $( parent.window ).height();
            var topMargin = ( wHeight - $el.height() ) / 2;

            // // Scroll into view if necessary.
            // // Some extra space added because there could be fixed headers etc.
            // var pos = $el.offset().top - 0.25 * $( '.swc_display' ).height();
            // var posMin = $( 'body' ).scrollTop() + 0.25 * $( '.swc_display' ).height();
            // var posMax = $( 'body' ).scrollTop() + 0.75 * $( '.swc_display' ).height();

            // if( $el.offset().top < posMin || $el.offset().top > posMax ) {
                $( 'body' ).animate( {
                    scrollTop: $el.offset().top - topMargin
                }, 500, 'swing', function() {
                    dfd.resolve();
                } );
            // } else {
            //     dfd.resolve();
            // }
        },

        getPageStyleKY: function( subKey ) {
            var ky = 'page_';

            if( scc_data.area !== 'main' ) {
                ky = scc_data.area + '_' + ( scc_data.area_template ? scc_data.area_template : '' );
            }

            if( ! swifty_ssd_page_styles ) {
                swifty_ssd_page_styles = {};
            }
            if( ! swifty_ssd_page_styles[ ky ] ) {
                swifty_ssd_page_styles[ ky ] = {};
            }
            if( ! swifty_ssd_page_styles[ ky ][ subKey ] ) {
                swifty_ssd_page_styles[ ky ][ subKey ] = [];
            }

            return ky;
        },

        applyFoundFonts: function( foundFonts ) {
            var ky = this.getPageStyleKY( 'used_fonts' );

            $.each( foundFonts, function( ii, font ) {
                // font = font.replace( /\w\S*/g, function( txt ) { return txt.charAt( 0 ).toUpperCase() + txt.substr( 1 ).toLowerCase(); } );
                font = font.replace( / /g, '+');

                if( $.inArray( font, swifty_ssd_page_styles[ ky ].used_fonts ) < 0 ) {
                    swifty_ssd_page_styles[ ky ].used_fonts.push( font );
                }
            } );

            if( typeof swifty_addFonts === 'function' ) {
                swifty_addFonts( swifty_ssd_page_styles[ ky ].used_fonts );
            }
        },

        getPageStyleObject: function( ky ) {
            if( swifty_ssd_page_styles && swifty_ssd_page_styles[ ky ] ) {
                return swifty_ssd_page_styles[ ky ];
            }
            return null;
        },

        '{window} evt_swc_scroll_to_element': function( el, ev, opts ) {
            this.scrollTo( opts.$el, false );
        },

        '{window} evt_swc_store_current_areas': function( /*el, ev, opts, dfd*/ ) {
            this.storeCurrentAreas();
        },

        '{window} evt_swc_change_current_areas': function( el, ev, opts/*, dfd*/ ) {
            var self = this;

            if( opts && opts.preset_areas ) {
                opts.preset_areas.each( function( area_map, area_name ) {
                    self.changeCurrentArea(
                        area_name,
                        area_map.attr( 'overrule' ),
                        area_map.attr( 'html' )
                    );
                } );
            }
        },

        '{window} evt_swc_restore_current_areas': function( /*el, ev, opts, dfd*/ ) {
            this.restoreCurrentAreas();
        },

        '{window} evt_swc_save_current_areas': function( el, ev, opts, dfd ) {
            var self = this;

            if( opts && opts.preset_areas ) {
                var deferreds = [];

                opts.preset_areas.each( function( area_map, area_name ) {
                    deferreds.push( self.saveCurrentArea(
                        area_name,
                        area_map.attr( 'overrule' )
                    ) );
                } );

                $.when.apply( $, deferreds ).done( function() {
                    dfd.resolve()
                } );
            }

            return dfd;
        },

        '{window} evt_swc_convert_from_element_html': function( el, ev, opts, dfd ) {
            var self = this;

            self.convertFromElementHtml( opts.$element, dfd );
        },

        '{window} evt_swc_reset_theme_edit_overlay': function( el, ev, opts/*, dfd*/ ) {
            // hide overlays
            $( '.swc_theme_edit_overlay' ).css( 'display', 'none' );
        },

        '{window} evt_swc_process_css_and_js_additions': function( el, ev, opts/*, dfd*/ ) {
            if( opts && opts.data ) {
                this.processCssAndJsAdditions( opts.data );
            }
        },

        '{window} evt_swc_add_exec': function( el, ev, opts/*, dfd*/ ) {
            swifty_add_exec( opts );
        },

        '{window} evt_swc_swifty_set_breakout': function( el, ev, opts/*, dfd*/ ) {
            swifty_set_breakout( opts.row, opts.breakout, opts.contentBreakout );
        },

        '{window} evt_swc_swifty_update_scrolleffect': function( /*el, ev, opts, dfd*/ ) {
            swifty_updateScrolleffect();
        },

        '{window} evt_swc_swifty_reset_scrolleffect': function( el, ev, opts/*, dfd*/ ) {
            swifty_resetScrolleffect( opts );
        },

        '{window} evt_swc_get_swifty_ssd_data': function( el, ev, opts, dfd ) {
            dfd.resolve( ( typeof( swifty_ssd_data ) !== 'undefined' ) ? swifty_ssd_data : null );
        },

        '{window} evt_swc_convert_image_to_asset': function( el, ev, opts ) {
            if( opts && opts.$image_wrapper ) {
                this.convertImageToAsset( opts.$image_wrapper );
            }
        },

        // Outcommented this code because table element is moved back to the CKE toolbar.
        // '{area_content_selector} table mouseenter': function( el /*, ev*/ ) {
        //     var $table = $( el );
        //     var $editButton = $table.prev( 'div.swc_table_edit_button' );
        //     var $contentArea = $table.closest( '.swc_page_cntnt' );
        //     var $area = $contentArea.closest( '.swifty_area' );
        //     var tableAlign = $table.prop( 'align' );
        //     var tablePos = $table.position();
        //     var tableWidth = $table.outerWidth();
        //     var contentWidth = $contentArea.outerWidth();
        //     var areaWidth = $area.outerWidth();
        //     var contentAreaPos = $contentArea.position();
        //     var editButtonWidth;
        //
        //     if ( ! $editButton.length ) {
        //         $table.before(
        //             '<div class="swc_table_edit_button cke_reset cke_widget_drag_handler_container" contenteditable="false">' +
        //             '<i class="fa fa-cogs" contenteditable="false"></i>' +
        //             '</div>'
        //         );
        //
        //         $editButton = $table.prev( 'div.swc_table_edit_button' );
        //     }
        //     editButtonWidth = $editButton.outerWidth();
        //
        //     $table.addClass( 'swc_table_outline' );
        //
        //     var cssObj = {
        //         'top': tablePos.top,
        //         'display': 'block'
        //     };
        //
        //     switch ( tableAlign ) {
        //         case 'left':
        //             $.extend( cssObj, { 'left': contentAreaPos.left + tableWidth - editButtonWidth } );
        //
        //             break;
        //         case 'right':
        //             $.extend( cssObj, { 'right': areaWidth - contentWidth - contentAreaPos.left } );
        //
        //             break;
        //         case 'center':
        //             $.extend( cssObj, {
        //                 'left': contentAreaPos.left + ( 0.5 * contentWidth ) + ( 0.5 * tableWidth ) - editButtonWidth
        //             } );
        //
        //             break;
        //         default:
        //             $.extend( cssObj, { 'left': contentAreaPos.left + tableWidth - editButtonWidth } );
        //     }
        //
        //     $editButton.css( cssObj );
        // },

        // Outcommented this code because table element is moved back to the CKE toolbar.
        // '{area_content_selector} table mouseleave': function( el, ev ) {
        //     var target = ev.toElement || ev.relatedTarget;
        //     var $table = $( el );
        //
        //     if ( $( target ).is( 'i.fa-cogs' ) || $( target ).is( 'div.swc_table_edit_button' ) ) {
        //         $table.addClass( 'swc_table_outline' );
        //     } else {
        //         $table.removeClass( 'swc_table_outline' ).prev( 'div.swc_table_edit_button' ).remove();
        //     }
        // },

        // Outcommented this code because table element is moved back to the CKE toolbar.
        // '{area_content_selector} .swc_table_edit_button mouseleave': function( el, ev ) {
        //     var target = ev.toElement || ev.relatedTarget;
        //     var $table = $( el ).next( 'table' );
        //
        //     if ( $table.has( target ).length ) {
        //         $table.addClass( 'swc_table_outline' );
        //     } else {
        //         $table.removeClass( 'swc_table_outline' ).prev( 'div.swc_table_edit_button' ).remove();
        //     }
        // },

        // Outcommented this code because table element is moved back to the CKE toolbar.
        // '{area_content_selector} .swc_table_edit_button click': function( el /*, ev*/ ) {
        //     evt( 'editor_open_table_properties', {
        //         '$table': $( el ).next( 'table' )
        //     } );
        // },

        '{window} evt_swc_determine_image_sizes': function( /*el, ev, data , dfd*/ ) {

            if( typeof window.swiftyDetermineImageSizes === 'function' ) {
                window.swiftyDetermineImageSizes( scc_data.page_id, document );
            }
        },

        // Get the width of the content pane.

        '{window} evt_swc_get_main_content_width': function( el, ev, data, dfd ) {
            dfd.resolve( $( '.swc_main_content_pane' ).innerWidth() );
        },

        // Get all stylesheets contents.

        '{window} evt_swc_get_main_all_styles': function( el, ev, data, dfd ) {
            var arrStyleSheets = document.getElementsByTagName( 'style' );
            var txt = '';

            for( var j = 0; j < arrStyleSheets.length; j++ ) {
                var sheet = arrStyleSheets[ j ];
                //for( var i = 0; i < sheet.cssRules.length; i++ ) {
                //    txt += sheet.cssRules[ i ].cssText;
                //}
                txt += $( sheet ).html();
            }

            dfd.resolve( txt );
        },

        '{window} evt_swc_get_ssd_list_loadfont': function( el, ev, data, dfd ) {
            
            dfd.resolve( ssd_list_loadFont );
        },

        // Fix for adding video's via presets.
        
        '{window} evt_swc_video_fitvids': function( /*el, ev, data, dfd*/ ) {
            yepnope.injectJs( { _url: scc_data.swcreator_url + 'js/libs/jquery.fitvids.js' }, function() {
                $( '.swc_video_wrapper' ).fitVids();

                var $div = $( '<div class="frameOverlay"/>' );
                $( '.swc_video_wrapper iframe' ).after( $div );
            } );
        },

        '{window} mousemove': function() {
            $( 'body' ).addClass( 'swc_page_mouse_moved' );
            this.pafeMouseMovedThrottledObject();
        },

        '{window} evt_swc_change_style_tag': function( el, ev, data/*, dfd*/ ) {
            var styleTagId = data.id;
            var css = data.css;
            var area_data = data.area_data;

            var head = document.getElementsByTagName( 'head' )[ 0 ];
            var style = document.getElementById( styleTagId );
            if( ! style ) {
                style = document.createElement( 'style' );
                style.id = styleTagId;
                head.appendChild( style );
            }
            style.type = 'text/css';
            if( style.styleSheet ) {
                style.styleSheet.cssText = css;
            } else {
                style.innerHTML = css;
            }
            
            var ky = this.getPageStyleKY( 'custom_css' );
            swifty_ssd_page_styles[ ky ].custom_css = css;
            swifty_ssd_page_styles[ ky ].area_data = area_data;
        },

        '{window} evt_swc_set_bg_img': function( el, ev, data/*, dfd*/ ) {
            var key = data.key;
            data = data.data;
            
            swifty_setBgImg(
                key,
                data.attr( 'bg_img' ) || '' ,
                data.attr( 'bg_type' ) || '',
                data.attr( 'def_bg_type' ) || '',
                data.attr( 'def_bg_img' ) || '',
                data.attr( 'bg_pattern' ) || '',
                data.attr( 'bg_color' ) || '#c4c4c4',
                data.attr( 'bg_colr2' ) || '#898989',
                $( 'body' ).hasClass( 'swifty_boxed' ) ? 'boxed' : 'wide',
                data.attr( 'set_bg_im_ssry' ) === 'custom' ? data.attr( 'bg_im_ssry' ) || '50' : ''
            );
        },

        '{window} evt_swc_change_scc_data': function( el, ev, opts/*, dfd*/ ) {
            scc_data[ opts.key ] = opts.val;
        },

        '{window} evt_swc_apply_found_fonts': function( el, ev, opts/*, dfd*/ ) {
            this.applyFoundFonts( opts );
        },

        '{window} evt_swc_get_page_style_object': function( el, ev, opts, dfd ) {
            dfd.resolve( this.getPageStyleObject( opts ) );
        }

    } );
} );
swifty.define( 'swiftylib/component',[
    'can/component'
], function( Component ) {
    

    return Component;
} );

swifty.define('text',{});
swifty.define('stache',{load: function(id){throw new Error("Dynamic load not allowed: " + id);}});

swifty.define('stache!js/components/editor_ckeditor/editor_ckeditor.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/components/editor_ckeditor/editor_ckeditor.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<div class="{{className}}"></div>' ); return idn; });

swifty.define( 'js/libs/jBox.min',[ 'jquery' ], function( jQuery ) {


function jBox(e,t){this.options={id:null,width:"auto",height:"auto",attach:null,trigger:"click",preventDefault:false,title:null,content:null,getTitle:null,getContent:null,ajax:null,data:"",reload:false,target:null,position:{x:"center",y:"center"},outside:null,offset:0,attributes:{x:"left",y:"top"},adjustPosition:false,adjustTracker:false,adjustDistance:5,fixed:false,reposition:false,pointer:false,fade:180,animation:null,theme:"Default",addClass:"",overlay:false,zIndex:1e4,delayOpen:0,delayClose:0,closeOnEsc:false,closeOnClick:false,closeOnMouseleave:false,closeButton:false,constructOnInit:false,blockScroll:false,appendTo:jQuery("body"),draggable:null,onInit:function(){},onCreated:function(){},onOpen:function(){},onClose:function(){},onCloseComplete:function(){},onAjax:function(){},onAjaxComplete:function(){},autoClose:7e3,color:null,stack:true,audio:false,volume:100,src:"href",gallery:"data-jbox-image",imageLabel:"title",imageFade:600,imageSize:"cover"};this.defaultOptions={Tooltip:{getContent:"title",trigger:"mouseenter",position:{x:"center",y:"top"},outside:"y",pointer:true,adjustPosition:true,reposition:true},Mouse:{target:"mouse",position:{x:"right",y:"bottom"},offset:15,trigger:"mouseenter",adjustPosition:"flip"},Modal:{target:jQuery(window),fixed:true,blockScroll:true,closeOnEsc:true,closeOnClick:"overlay",closeButton:"title",overlay:true,animation:"zoomOut"},Notice:{target:jQuery(window),fixed:true,position:{x:20,y:20},attributes:{x:"right",y:"top"},animation:"zoomIn",closeOnClick:"box",_onInit:function(){this.open();this.options.delayClose=this.options.autoClose;this.options.delayClose&&this.close()}.bind(this),_onCreated:function(){this.options.color&&this.wrapper.addClass("jBox-Notice-color jBox-Notice-"+this.options.color)},_onOpen:function(){jQuery.each(jQuery(".jBox-Notice"),function(e,t){t=jQuery(t);if(t.attr("id")==this.id||t.css(this.options.attributes.y)=="auto"||t.css(this.options.attributes.x)=="auto")return;if(!this.options.stack){t.data("jBox").close({ignoreDelay:true});return}t.css("margin-"+this.options.attributes.y,parseInt(t.css("margin-"+this.options.attributes.y))+this.dimensions.y+10)}.bind(this));if(this.options.audio&&!this.IE8){this.audio=jQuery("<audio/>");jQuery("<source/>",{src:this.options.audio+".mp3"}).appendTo(this.audio);jQuery("<source/>",{src:this.options.audio+".ogg"}).appendTo(this.audio);this.audio[0].volume=Math.min(this.options.volume/100,1);this.audio[0].play()}}.bind(this),_onCloseComplete:function(){this.destroy()}.bind(this)},Image:{target:jQuery(window),fixed:true,blockScroll:true,closeOnEsc:true,closeOnClick:"overlay",overlay:true,animation:"zoomOut",width:800,height:533,attach:jQuery("[data-jbox-image]"),preventDefault:true,_onInit:function(){this.images=this.currentImage={};this.imageZIndex=1;jQuery.each(this.attachedElements,function(e,t){t=jQuery(t);if(t.data("jBox-image-gallery"))return;var n=t.attr(this.options.gallery)||"default";!this.images[n]&&(this.images[n]=[]);this.images[n].push({src:t.attr(this.options.src),label:t.attr(this.options.imageLabel)||""});this.options.imageLabel=="title"&&t.removeAttr("title");t.data("jBox-image-gallery",n);t.data("jBox-image-id",this.images[n].length-1)}.bind(this));var e=function(e,t,n,r){if(jQuery("#jBox-image-"+e+"-"+t).length)return;var i=jQuery("<div/>",{id:"jBox-image-"+e+"-"+t,"class":"jBox-image-container"}).css({backgroundImage:"url("+this.images[e][t].src+")",backgroundSize:this.options.imageSize,opacity:r?1:0,zIndex:n?0:this.imageZIndex++}).appendTo(this.content);var s=jQuery("<div/>",{id:"jBox-image-label-"+e+"-"+t,"class":"jBox-image-label"+(r?" active":"")}).html(this.images[e][t].label).appendTo(this.imageLabel);!r&&!n&&i.animate({opacity:1},this.options.imageFade)}.bind(this);var t=function(e,t){jQuery(".jBox-image-label.active").removeClass("active");jQuery("#jBox-image-label-"+e+"-"+t).addClass("active")};this.showImage=function(n){if(n!="open"){var r=this.currentImage.gallery;var i=this.currentImage.id+(1*(n=="prev")?-1:1);i=i>this.images[r].length-1?0:i<0?this.images[r].length-1:i}else{var r=this.source.data("jBox-image-gallery");var i=this.source.data("jBox-image-id");jQuery(".jBox-image-pointer-prev, .jBox-image-pointer-next").css({display:this.images[r].length>1?"block":"none"})}this.currentImage={gallery:r,id:i};if(jQuery("#jBox-image-"+r+"-"+i).length){jQuery("#jBox-image-"+r+"-"+i).css({zIndex:this.imageZIndex++,opacity:0}).animate({opacity:1},n=="open"?0:this.options.imageFade);t(r,i)}else{this.wrapper.addClass("jBox-loading");var s=jQuery('<img src="'+this.images[r][i].src+'">').load(function(){e(r,i,false);t(r,i);this.wrapper.removeClass("jBox-loading")}.bind(this))}var o=i+1;o=o>this.images[r].length-1?0:o<0?this.images[r].length-1:o;!jQuery("#jBox-image-"+r+"-"+o).length&&jQuery('<img src="'+this.images[r][o].src+'">').load(function(){e(r,o,true)})}},_onCreated:function(){this.imageLabel=jQuery("<div/>",{id:"jBox-image-label"}).appendTo(this.wrapper);this.wrapper.append(jQuery("<div/>",{"class":"jBox-image-pointer-prev",click:function(){this.showImage("prev")}.bind(this)})).append(jQuery("<div/>",{"class":"jBox-image-pointer-next",click:function(){this.showImage("next")}.bind(this)}))},_onOpen:function(){jQuery("body").addClass("jBox-image-open");jQuery(document).on("keyup.jBox-"+this.id,function(e){e.keyCode==37&&this.showImage("prev");e.keyCode==39&&this.showImage("next")}.bind(this));this.showImage("open")},_onClose:function(){jQuery("body").removeClass("jBox-image-open");jQuery(document).off("keyup.jBox-"+this.id)},_onCloseComplete:function(){this.wrapper.find(".jBox-image-container").css("opacity",0)}}};if(jQuery.type(e)=="string"){this.type=e;e=this.defaultOptions[e]}this.options=jQuery.extend(this.options,e,t);if(this.options.id===null){var n=1;while(jQuery("#jBox"+n).length!=0)n++;this.options.id="jBox"+n}this.id=this.options.id;(this.options.position.x=="center"&&this.options.outside=="x"||this.options.position.y=="center"&&this.options.outside=="y")&&(this.options.outside=false);(!this.options.outside||this.options.outside=="xy")&&(this.options.pointer=false);jQuery.type(this.options.offset)!="object"&&(this.options.offset={x:this.options.offset,y:this.options.offset});this.options.offset.x||(this.options.offset.x=0);this.options.offset.y||(this.options.offset.y=0);jQuery.type(this.options.adjustDistance)!="object"&&(this.options.adjustDistance={top:this.options.adjustDistance,right:this.options.adjustDistance,bottom:this.options.adjustDistance,left:this.options.adjustDistance});this.align=this.options.outside&&this.options.outside!="xy"?this.options.position[this.options.outside]:this.options.position.y!="center"&&jQuery.type(this.options.position.y)!="number"?this.options.position.x:this.options.position.x!="center"&&jQuery.type(this.options.position.x)!="number"?this.options.position.y:this.options.attributes.x;this.options.outside&&this.options.outside!="xy"&&(this.outside=this.options.position[this.options.outside]);var r=navigator.userAgent.toLowerCase();this.IE8=r.indexOf("msie")!=-1&&parseInt(r.split("msie")[1])==8;this.prefix=r.indexOf("webkit")!=-1?"-webkit-":"";this._getOpp=function(e){return{left:"right",right:"left",top:"bottom",bottom:"top",x:"y",y:"x"}[e]};this._getXY=function(e){return{left:"x",right:"x",top:"y",bottom:"y",center:"x"}[e]};this._getTL=function(e){return{left:"left",right:"left",top:"top",bottom:"top",center:"left",x:"left",y:"top"}[e]};this._create=function(){if(this.wrapper)return;this.wrapper=jQuery("<div/>",{id:this.id,"class":"jBox-wrapper"+(this.type?" jBox-"+this.type:"")+(this.options.theme?" jBox-"+this.options.theme:"")+(this.options.addClass?" "+this.options.addClass:"")+(this.IE8?" jBox-IE8":"")}).css({position:this.options.fixed?"fixed":"absolute",display:"none",opacity:0,zIndex:this.options.zIndex}).data("jBox",this);this.options.closeOnMouseleave&&this.wrapper.mouseenter(function(){this.open()}.bind(this)).mouseleave(function(){this.close()}.bind(this));this.container=jQuery("<div/>",{"class":"jBox-container"}).appendTo(this.wrapper);this.content=jQuery("<div/>",{"class":"jBox-content"}).css({width:this.options.width,height:this.options.height}).appendTo(this.container);if(this.options.closeButton){this.closeButton=jQuery("<div/>",{"class":"jBox-closeButton jBox-noDrag"}).click(function(){this.close()}.bind(this));if(this.options.closeButton!="title"){this.wrapper.addClass("jBox-closeButton-box");this.closeButton.appendTo(this.container)}}this.wrapper.appendTo(this.options.appendTo);if(this.options.pointer){this.pointer={position:this._getOpp(this.outside),xy:this._getXY(this.outside),align:"center",offset:0};this.pointer.element=jQuery("<div/>",{"class":"jBox-pointer jBox-pointer-"+this.pointer.position}).appendTo(this.wrapper);this.pointer.dimensions={x:this.pointer.element.outerWidth(),y:this.pointer.element.outerHeight()};if(jQuery.type(this.options.pointer)=="string"){var e=this.options.pointer.split(":");e[0]&&(this.pointer.align=e[0]);e[1]&&(this.pointer.offset=parseInt(e[1]))}this.pointer.alignAttribute=this.pointer.xy=="x"?this.pointer.align=="bottom"?"bottom":"top":this.pointer.align=="right"?"right":"left";this.wrapper.css("padding-"+this.pointer.position,this.pointer.dimensions[this.pointer.xy]);this.pointer.element.css(this.pointer.alignAttribute,this.pointer.align=="center"?"50%":0).css("margin-"+this.pointer.alignAttribute,this.pointer.offset);this.pointer.margin={margin:this.pointer.element.css("margin")};this.pointer.align=="center"&&this.pointer.element.css(this.prefix+"transform","translate("+(this.pointer.xy=="y"?this.pointer.dimensions.x*-.5+"px":0)+", "+(this.pointer.xy=="x"?this.pointer.dimensions.y*-.5+"px":0)+")");this.pointer.element.css(this.pointer.xy=="x"?"width":"height",parseInt(this.pointer.dimensions[this.pointer.xy])+parseInt(this.container.css("border-"+this.pointer.alignAttribute+"-width")));this.wrapper.addClass("jBox-pointerPosition-"+this.pointer.position)}this.setContent(this.options.content);this.setTitle(this.options.title);if(this.options.draggable){var t=this.options.draggable=="title"?this.titleContainer:this.options.draggable.length>0?this.options.draggable:this.wrapper;t.addClass("jBox-draggable").on("mousedown",function(e){if(e.button==2||jQuery(e.target).hasClass("jBox-noDrag")||jQuery(e.target).parents(".jBox-noDrag").length)return;var t=this.wrapper.outerHeight(),n=this.wrapper.outerWidth(),r=this.wrapper.offset().top+t-e.pageY,i=this.wrapper.offset().left+n-e.pageX;jQuery(document).on("mousemove.jBox-draggable-"+this.id,function(e){this.wrapper.offset({top:e.pageY+r-t,left:e.pageX+i-n})}.bind(this));e.preventDefault()}.bind(this)).on("mouseup",function(){jQuery(document).off("mousemove.jBox-draggable-"+this.id)}.bind(this))}this.options.onCreated.bind(this)();this.options._onCreated&&this.options._onCreated.bind(this)()};this.options.constructOnInit&&this._create();this.options.attach&&this.attach();this._positionMouse=function(e){this.pos={left:e.pageX,top:e.pageY};var t=function(e,t){if(this.options.position[t]=="center"){this.pos[e]-=Math.ceil(this.dimensions[t]/2);return}this.pos[e]+=e==this.options.position[t]?this.dimensions[t]*-1-this.options.offset[t]:this.options.offset[t];return this.pos[e]}.bind(this);this.wrapper.css({left:t("left","x"),top:t("top","y")});this.targetDimensions={x:0,y:0,left:e.pageX,top:e.pageY};this._adjustPosition()};this._attachEvents=function(){this.options.closeOnEsc&&jQuery(document).on("keyup.jBox-"+this.id,function(e){if(e.keyCode==27){this.close({ignoreDelay:true})}}.bind(this));this.options.closeOnClick&&jQuery(document).on("click.jBox-"+this.id,function(e){if(this.blockBodyClick||this.options.closeOnClick=="overlay"&&(!this.overlay||e.target!=this.overlay[0])||this.options.closeOnClick=="box"&&e.target!=this.wrapper[0]&&!this.wrapper.has(e.target).length||this.options.closeOnClick=="body"&&(e.target==this.wrapper[0]||this.wrapper.has(e.target).length))return;this.close({ignoreDelay:true})}.bind(this));if((this.options.adjustPosition&&this.options.adjustTracker||this.options.reposition)&&!this.fixed&&this.outside){var e,t=0,n=150;var r=function(){var r=(new Date).getTime();if(!e){if(r-t>n){this.options.reposition&&this.position();this.options.adjustTracker&&this._adjustPosition();t=r}e=setTimeout(function(){e=null;t=(new Date).getTime();this.options.reposition&&this.position();this.options.adjustTracker&&this._adjustPosition()}.bind(this),n)}}.bind(this);this.options.adjustTracker&&this.options.adjustTracker!="resize"&&jQuery(window).on("scroll.jBox-"+this.id,function(e){r()}.bind(this));(this.options.adjustTracker&&this.options.adjustTracker!="scroll"||this.options.reposition)&&jQuery(window).on("resize.jBox-"+this.id,function(e){r()}.bind(this))}this.options.target=="mouse"&&jQuery("body").on("mousemove.jBox-"+this.id,function(e){this._positionMouse(e)}.bind(this))};this._detachEvents=function(){this.options.closeOnEsc&&jQuery(document).off("keyup.jBox-"+this.id);this.options.closeOnClick&&jQuery(document).off("click.jBox-"+this.id);if(this.options.adjustPosition&&this.options.adjustTracker||this.options.reposition){jQuery(window).off("scroll.jBox-"+this.id);jQuery(window).off("resize.jBox-"+this.id)}this.options.target=="mouse"&&jQuery("body").off("mousemove.jBox-"+this.id)};this._addOverlay=function(){!this.overlay&&(this.overlay=jQuery("#jBox-overlay").length?jQuery("#jBox-overlay").css({zIndex:Math.min(jQuery("#jBox-overlay").css("z-index"),this.options.zIndex-1)}):jQuery("<div/>",{id:"jBox-overlay"}).css({display:"none",opacity:0,zIndex:this.options.zIndex-1}).appendTo(jQuery("body")));var e=this.overlay.data("jBox")||{};e["jBox-"+this.id]=true;this.overlay.data("jBox",e);if(this.overlay.css("display")=="block")return;this.options.fade?this.overlay.stop()&&this.overlay.animate({opacity:1},{queue:false,duration:this.options.fade,start:function(){this.overlay.css({display:"block"})}.bind(this)}):this.overlay.css({display:"block",opacity:1})};this._removeOverlay=function(){if(!this.overlay)return;var e=this.overlay.data("jBox");delete e["jBox-"+this.id];this.overlay.data("jBox",e);if(jQuery.isEmptyObject(e)){this.options.fade?this.overlay.stop()&&this.overlay.animate({opacity:0},{queue:false,duration:this.options.fade,complete:function(){this.overlay.css({display:"none"})}.bind(this)}):this.overlay.css({display:"none",opacity:0})}};this._generateCSS=function(){if(this.IE8)return;jQuery.type(this.options.animation)!="object"&&(this.options.animation={pulse:{open:"pulse",close:"zoomOut"},zoomIn:{open:"zoomIn",close:"zoomIn"},zoomOut:{open:"zoomOut",close:"zoomOut"},move:{open:"move",close:"move"},slide:{open:"slide",close:"slide"},flip:{open:"flip",close:"flip"},tada:{open:"tada",close:"zoomOut"}}[this.options.animation]);this.options.animation.open&&(this.options.animation.open=this.options.animation.open.split(":"));this.options.animation.close&&(this.options.animation.close=this.options.animation.close.split(":"));this.options.animation.openDirection=this.options.animation.open?this.options.animation.open[1]:null;this.options.animation.closeDirection=this.options.animation.close?this.options.animation.close[1]:null;this.options.animation.open&&(this.options.animation.open=this.options.animation.open[0]);this.options.animation.close&&(this.options.animation.close=this.options.animation.close[0]);this.options.animation.open&&(this.options.animation.open+="Open");this.options.animation.close&&(this.options.animation.close+="Close");var e={pulse:{duration:350,css:[["0%","scale(1)"],["50%","scale(1.1)"],["100%","scale(1)"]]},zoomInOpen:{duration:this.options.fade||180,css:[["0%","scale(0.9)"],["100%","scale(1)"]]},zoomInClose:{duration:this.options.fade||180,css:[["0%","scale(1)"],["100%","scale(0.9)"]]},zoomOutOpen:{duration:this.options.fade||180,css:[["0%","scale(1.1)"],["100%","scale(1)"]]},zoomOutClose:{duration:this.options.fade||180,css:[["0%","scale(1)"],["100%","scale(1.1)"]]},moveOpen:{duration:this.options.fade||180,positions:{top:{"0%":-12},right:{"0%":12},bottom:{"0%":12},left:{"0%":-12}},css:[["0%","translate%XY(%Vpx)"],["100%","translate%XY(0px)"]]},moveClose:{duration:this.options.fade||180,timing:"ease-in",positions:{top:{"100%":-12},right:{"100%":12},bottom:{"100%":12},left:{"100%":-12}},css:[["0%","translate%XY(0px)"],["100%","translate%XY(%Vpx)"]]},slideOpen:{duration:400,positions:{top:{"0%":-400},right:{"0%":400},bottom:{"0%":400},left:{"0%":-400}},css:[["0%","translate%XY(%Vpx)"],["100%","translate%XY(0px)"]]},slideClose:{duration:400,timing:"ease-in",positions:{top:{"100%":-400},right:{"100%":400},bottom:{"100%":400},left:{"100%":-400}},css:[["0%","translate%XY(0px)"],["100%","translate%XY(%Vpx)"]]},flipOpen:{duration:600,css:[["0%","perspective(400px) rotateX(90deg)"],["40%","perspective(400px) rotateX(-15deg)"],["70%","perspective(400px) rotateX(15deg)"],["100%","perspective(400px) rotateX(0deg)"]]},flipClose:{duration:this.options.fade||300,css:[["0%","perspective(400px) rotateX(0deg)"],["100%","perspective(400px) rotateX(90deg)"]]},tada:{duration:800,css:[["0%","scale(1)"],["10%, 20%","scale(0.9) rotate(-3deg)"],["30%, 50%, 70%, 90%","scale(1.1) rotate(3deg)"],["40%, 60%, 80%","scale(1.1) rotate(-3deg)"],["100%","scale(1) rotate(0)"]]}};jQuery.each(["pulse","tada"],function(t,n){e[n+"Open"]=e[n+"Close"]=e[n]});var t=function(t,n){keyframe_css="@"+this.prefix+"keyframes jBox-animation-"+this.options.animation[t]+"-"+t+(n?"-"+n:"")+" {";jQuery.each(e[this.options.animation[t]].css,function(r,i){var s=n?i[1].replace("%XY",this._getXY(n).toUpperCase()):i[1];e[this.options.animation[t]].positions&&(s=s.replace("%V",e[this.options.animation[t]].positions[n][i[0]]));keyframe_css+=i[0]+" {"+this.prefix+"transform:"+s+";}"}.bind(this));keyframe_css+="}";keyframe_css+=".jBox-animation-"+this.options.animation[t]+"-"+t+(n?"-"+n:"")+" {";keyframe_css+=this.prefix+"animation-duration: "+e[this.options.animation[t]].duration+"ms;";keyframe_css+=this.prefix+"animation-name: jBox-animation-"+this.options.animation[t]+"-"+t+(n?"-"+n:"")+";";keyframe_css+=e[this.options.animation[t]].timing?this.prefix+"animation-timing-function: "+e[this.options.animation[t]].timing+";":"";keyframe_css+="}";return keyframe_css}.bind(this);var n="";jQuery.each(["open","close"],function(r,i){if(!this.options.animation[i]||!e[this.options.animation[i]]||i=="close"&&!this.options.fade)return"";e[this.options.animation[i]].positions?jQuery.each(["top","right","bottom","left"],function(e,r){n+=t(i,r)}):n+=t(i)}.bind(this));jQuery("<style/>").append(n).appendTo(jQuery("head"))};this._blockBodyClick=function(){this.blockBodyClick=true;setTimeout(function(){this.blockBodyClick=false}.bind(this),10)};this.options.animation&&this._generateCSS();this._animate=function(e){if(this.IE8)return;e||(e=this.isOpen?"open":"close");if(!this.options.fade&&e=="close")return null;var t=this.options.animation[e+"Direction"]||(this.align!="center"?this.align:this.options.attributes.x);this.flipped&&this._getXY(t)==this._getXY(this.align)&&(t=this._getOpp(t));var n="jBox-animation-"+this.options.animation[e]+"-"+e+" jBox-animation-"+this.options.animation[e]+"-"+e+"-"+t;this.wrapper.addClass(n);var r=parseFloat(this.wrapper.css(this.prefix+"animation-duration"))*1e3;e=="close"&&(r=Math.min(r,this.options.fade));setTimeout(function(){this.wrapper.removeClass(n)}.bind(this),r)};this._abortAnimation=function(){if(this.IE8)return;var e="jBox-animation";var t=this.wrapper.attr("class").split(" ").filter(function(t){return t.lastIndexOf(e,0)!==0});this.wrapper.attr("class",t.join(" "))};this._adjustPosition=function(){if(!this.options.adjustPosition)return null;if(this.positionAdjusted){this.wrapper.css(this.pos);this.pointer&&this.wrapper.css("padding",0).css("padding-"+this._getOpp(this.outside),this.pointer.dimensions[this._getXY(this.outside)]).removeClass("jBox-pointerPosition-"+this._getOpp(this.pointer.position)).addClass("jBox-pointerPosition-"+this.pointer.position);this.pointer&&this.pointer.element.attr("class","jBox-pointer jBox-pointer-"+this._getOpp(this.outside)).css(this.pointer.margin);this.positionAdjusted=false;this.flipped=false}var e=jQuery(window);var t={x:e.width(),y:e.height(),top:e.scrollTop(),left:e.scrollLeft()};t.bottom=t.top+t.y;t.right=t.left+t.x;var n=t.top>this.pos.top-(this.options.adjustDistance.top||0),r=t.right<this.pos.left+this.dimensions.x+(this.options.adjustDistance.right||0),i=t.bottom<this.pos.top+this.dimensions.y+(this.options.adjustDistance.bottom||0),s=t.left>this.pos.left-(this.options.adjustDistance.left||0),o=s?"left":r?"right":null,u=n?"top":i?"bottom":null,a=o||u;if(!a)return;if(this.options.adjustPosition!="move"&&(o==this.outside||u==this.outside)){this.target=="mouse"&&(this.outside="right");if((this.outside=="top"||this.outside=="left"?t[this._getXY(this.outside)]-(this.targetDimensions[this._getTL(this.outside)]-t[this._getTL(this.outside)])-this.targetDimensions[this._getXY(this.outside)]:this.targetDimensions[this._getTL(this.outside)]-t[this._getTL(this.outside)])>this.dimensions[this._getXY(this.outside)]+this.options.adjustDistance[this._getOpp(this.outside)]){this.wrapper.css(this._getTL(this.outside),this.pos[this._getTL(this.outside)]+(this.dimensions[this._getXY(this.outside)]+this.options.offset[this._getXY(this.outside)]+this.targetDimensions[this._getXY(this.outside)])*(this.outside=="top"||this.outside=="left"?1:-1)).removeClass("jBox-pointerPosition-"+this.pointer.position).addClass("jBox-pointerPosition-"+this._getOpp(this.pointer.position));this.pointer&&this.wrapper.css("padding",0).css("padding-"+this.outside,this.pointer.dimensions[this._getXY(this.outside)]);this.pointer&&this.pointer.element.attr("class","jBox-pointer jBox-pointer-"+this.outside);this.positionAdjusted=true;this.flipped=true}}var f=this._getXY(this.outside)=="x"?u:o;if(this.pointer&&this.options.adjustPosition!="flip"&&this._getXY(f)==this._getOpp(this._getXY(this.outside))){if(this.pointer.align=="center"){var l=this.dimensions[this._getXY(f)]/2-this.pointer.dimensions[this._getOpp(this.pointer.xy)]/2-parseInt(this.pointer.element.css("margin-"+this.pointer.alignAttribute))*(f!=this._getTL(f)?-1:1)}else{var l=f==this.pointer.alignAttribute?parseInt(this.pointer.element.css("margin-"+this.pointer.alignAttribute)):this.dimensions[this._getXY(f)]-parseInt(this.pointer.element.css("margin-"+this.pointer.alignAttribute))-this.pointer.dimensions[this._getXY(f)]}spaceDiff=f==this._getTL(f)?t[this._getTL(f)]-this.pos[this._getTL(f)]+this.options.adjustDistance[f]:(t[this._getOpp(this._getTL(f))]-this.pos[this._getTL(f)]-this.options.adjustDistance[f]-this.dimensions[this._getXY(f)])*-1;if(f==this._getOpp(this._getTL(f))&&this.pos[this._getTL(f)]-spaceDiff<t[this._getTL(f)]+this.options.adjustDistance[this._getTL(f)]){spaceDiff-=t[this._getTL(f)]+this.options.adjustDistance[this._getTL(f)]-(this.pos[this._getTL(f)]-spaceDiff)}spaceDiff=Math.min(spaceDiff,l);if(spaceDiff<=l&&spaceDiff>0){this.pointer.element.css("margin-"+this.pointer.alignAttribute,parseInt(this.pointer.element.css("margin-"+this.pointer.alignAttribute))-spaceDiff*(f!=this.pointer.alignAttribute?-1:1));this.wrapper.css(this._getTL(f),this.pos[this._getTL(f)]+spaceDiff*(f!=this._getTL(f)?-1:1));this.positionAdjusted=true}}};this.options.onInit.bind(this)();this.options._onInit&&this.options._onInit.bind(this)();return this}jBox.prototype.attach=function(e,t){e||(e=jQuery(this.options.attach.selector));t||(t=this.options.trigger);e&&e.length&&jQuery.each(e,function(e,n){n=jQuery(n);if(!n.data("jBox-attached-"+this.id)){this.options.getContent=="title"&&n.attr("title")!=undefined&&n.data("jBox-getContent",n.attr("title")).removeAttr("title");this.attachedElements||(this.attachedElements=[]);this.attachedElements.push(n[0]);n.on(t+".jBox-attach-"+this.id,function(e){if(this.isOpen&&this.source[0]!=n[0])var r=true;this.source=n;!this.options.target&&(this.target=n);t=="click"&&this.options.preventDefault&&e.preventDefault();this[t=="click"&&!r?"toggle":"open"]()}.bind(this));this.options.trigger=="mouseenter"&&n.on("mouseleave",function(){this.close()}.bind(this));n.data("jBox-attached-"+this.id,t)}}.bind(this));return this};jBox.prototype.detach=function(e){e||(e=this.attachedElements||[]);e&&e.length&&jQuery.each(e,function(e,t){t=jQuery(t);if(t.data("jBox-attached-"+this.id)){t.off(t.data("jBox-attached-"+this.id+".jBox-attach-"+this.id));t.data("jBox-attached-"+this.id,null)}});return this};jBox.prototype.setTitle=function(e){if(e==null||e==undefined)return this;!this.wrapper&&this._create();if(!this.title){this.titleContainer=jQuery("<div/>",{"class":"jBox-title"});this.title=jQuery("<div/>").appendTo(this.titleContainer);this.wrapper.addClass("jBox-hasTitle");if(this.options.closeButton=="title"){this.wrapper.addClass("jBox-closeButton-title");this.closeButton.appendTo(this.titleContainer)}this.titleContainer.insertBefore(this.content)}this.title.html(e);this.position();return this};jBox.prototype.setContent=function(e){if(e==null)return this;!this.wrapper&&this._create();switch(jQuery.type(e)){case"string":this.content.html(e);break;case"object":this.content.children().css({display:"none"});this.options.content.appendTo(this.content).css({display:"block"});break}this.position();return this};jBox.prototype.position=function(e){e||(e={});this.target=e.target||this.target||this.options.target||jQuery(window);this.dimensions={x:this.wrapper.outerWidth(),y:this.wrapper.outerHeight()};if(this.target=="mouse")return;if(this.options.position.x=="center"&&this.options.position.y=="center"){this.wrapper.css({left:"50%",top:"50%",marginLeft:this.dimensions.x*-.5+this.options.offset.x,marginTop:this.dimensions.y*-.5+this.options.offset.y});return this}var t=this.target.offset();this.targetDimensions={x:this.target.outerWidth(),y:this.target.outerHeight(),top:t?t.top:0,left:t?t.left:0};this.pos={};var n=function(e){if(jQuery.inArray(this.options.position[e],["top","right","bottom","left","center"])==-1){this.pos[this.options.attributes[e]]=this.options.position[e];return}var t=this.options.attributes[e]=e=="x"?"left":"top";this.pos[t]=this.targetDimensions[t];if(this.options.position[e]=="center"){this.pos[t]+=Math.ceil((this.targetDimensions[e]-this.dimensions[e])/2);return}t!=this.options.position[e]&&(this.pos[t]+=this.targetDimensions[e]-this.dimensions[e]);(this.options.outside==e||this.options.outside=="xy")&&(this.pos[t]+=this.dimensions[e]*(t!=this.options.position[e]?1:-1))}.bind(this);n("x");n("y");if(this.options.pointer){var r=0;switch(this.pointer.align){case"center":if(this.options.position[this._getOpp(this.options.outside)]!="center"){r+=this.dimensions[this._getOpp(this.options.outside)]/2}break;default:switch(this.options.position[this._getOpp(this.options.outside)]){case"center":r+=(this.dimensions[this._getOpp(this.options.outside)]/2-this.pointer.dimensions[this._getOpp(this.options.outside)]/2)*(this.pointer.align==this._getTL(this.pointer.align)?1:-1);break;default:r+=this.pointer.align!=this.options.position[this._getOpp(this.options.outside)]?this.dimensions[this._getOpp(this.options.outside)]-this.pointer.dimensions[this._getOpp(this.options.outside)]/2:this.pointer.dimensions[this._getOpp(this.options.outside)]/2;break}break}r*=this.options.position[this._getOpp(this.options.outside)]==this.pointer.alignAttribute?-1:1;r+=this.pointer.offset*(this.pointer.align==this._getOpp(this._getTL(this.pointer.align))?1:-1);this.pos[this._getTL(this._getOpp(this.pointer.xy))]+=r}this.pos[this.options.attributes.x]+=this.options.offset.x;this.pos[this.options.attributes.y]+=this.options.offset.y;this.wrapper.css(this.pos);this._adjustPosition();return this};jBox.prototype.open=function(e){e||(e={});!this.wrapper&&this._create();this.timer&&clearTimeout(this.timer);this._blockBodyClick();if(this.isDisabled)return this;var t=function(){this.source&&this.options.getTitle&&this.source.attr(this.options.getTitle)!=undefined&&this.setTitle(this.source.attr(this.options.getTitle));this.source&&this.options.getContent&&(this.source.data("jBox-getContent")!=undefined?this.setContent(this.source.data("jBox-getContent")):this.source.attr(this.options.getContent)!=undefined?this.setContent(this.source.attr(this.options.getContent)):null);this.position({target:e.target});this.options.onOpen.bind(this)();this.options._onOpen&&this.options._onOpen.bind(this)();this.options.ajax&&(!this.ajaxLoaded||this.options.reload)&&this.ajax();this.isClosing&&this._abortAnimation();if(!this.isOpen){this.isOpen=true;this._attachEvents();this.options.blockScroll&&jQuery("body").addClass("jBox-blockScroll-"+this.id);this.options.overlay&&this._addOverlay();this.options.animation&&!this.isClosing&&this._animate("open");if(this.options.fade){this.wrapper.stop().animate({opacity:1},{queue:false,duration:this.options.fade,start:function(){this.isOpening=true;this.wrapper.css({display:"block"})}.bind(this),always:function(){this.isOpening=false}.bind(this)})}else{this.wrapper.css({display:"block",opacity:1})}}}.bind(this);this.options.delayOpen&&!this.isOpen&&!this.isClosing&&!e.ignoreDelay?this.timer=setTimeout(t,this.options.delayOpen):t();return this};jBox.prototype.close=function(e){e||(e={});this.timer&&clearTimeout(this.timer);this._blockBodyClick();if(this.isDisabled)return this;var t=function(){this.options.onClose.bind(this)();if(this.isOpen){this.isOpen=false;this._detachEvents();this.options.blockScroll&&jQuery("body").removeClass("jBox-blockScroll-"+this.id);this.options.overlay&&this._removeOverlay();this.options.animation&&!this.isOpening&&this._animate("close");this.source=null;if(this.options.fade){this.wrapper.stop().animate({opacity:0},{queue:false,duration:this.options.fade,start:function(){this.isClosing=true}.bind(this),complete:function(){this.wrapper.css({display:"none"});this.options.onCloseComplete&&this.options.onCloseComplete.bind(this)();this.options._onCloseComplete&&this.options._onCloseComplete.bind(this)()}.bind(this),always:function(){this.isClosing=false}.bind(this)})}else{this.wrapper.css({display:"none",opacity:0});this.options._onCloseComplete&&this.options._onCloseComplete.bind(this)()}}}.bind(this);e.ignoreDelay?t():this.timer=setTimeout(t,Math.max(this.options.delayClose,10));return this};jBox.prototype.toggle=function(e){this[this.isOpen?"close":"open"](e);return this};jBox.prototype.disable=function(){this.isDisabled=true;return this};jBox.prototype.enable=function(){this.isDisabled=false;return this};jBox.prototype.ajax=function(e){e||(e={});this.ajaxRequest&&this.ajaxRequest.abort();this.ajaxRequest=jQuery.ajax({url:e.url||this.options.ajax,data:e.data||this.options.data,beforeSend:function(){this.content.html("");this.wrapper.addClass("jBox-loading");this.position();this.options.onAjax.bind(this)()}.bind(this),complete:function(e){this.wrapper.removeClass("jBox-loading");this.content.html(e.responseText);this.position();this.ajaxLoaded=true;this.options.onAjaxComplete.bind(this)()}.bind(this)});return this};jBox.prototype.destroy=function(){this.close({ignoreDelay:true});this.wrapper.remove();return this};jQuery.fn.jBox=function(e,t){e||(e={});t||(t={});return new jBox(e,jQuery.extend(t,{attach:this}))};if(!Function.prototype.bind){Function.prototype.bind=function(e){var t=Array.prototype.slice.call(arguments,1),n=this,r=function(){},i=function(){return n.apply(this instanceof r&&e?this:e,t.concat(Array.prototype.slice.call(arguments)))};r.prototype=this.prototype;i.prototype=new r;return i}}


    return jBox;
} );
swifty.define( 'swiftylib/compute',[
    // CanJs 2.0
    'can/compute'
    // CanJs < 2.0 (old)
//    'can/observe/compute'
], function( Compute ) {
    

    return Compute;
} );

swifty.define( 'js/components/editor_ckeditor/ckeditor_helpers/ckeditor_helper_link_type',[
    'jquery',
    'swiftylib/construct',
    'swiftylib/i18n/__'
], function(
    $, Construct, __
) {
    

    var LinkType = Construct.extend( {
        insertNewLinkType: function( linkTypeSelect, infoTab ) {
            var self = this;
            var dfd = new $.Deferred();

            // Add a "Internal page" option to the link type select box.
            linkTypeSelect.items.unshift( [ __( 'Internal page' ), 'page' ] );

            infoTab.elements.push( {
                'type': 'vbox',
                'id': 'pageOptions',
                'children': [ {
                    'type': 'select',
                    'id': 'page',
                    'label': 'Select a page',
                    'items': [],
                    'onLoad': function( /*el*/ ) {
                        self._addPagesToSelectElement( this, dfd );
                    },
                    'setup': function( data ) {
                        var that = this;

                        dfd.done( function() {
                            if( data && data.type && data.type === 'page' && data.url && data.url.url ) {
                                var url = data.url.url;

                                // Internal page
                                if( url.indexOf( document.location.hostname ) > -1 ) {
                                    that.setValue( data.url.protocol + url );
                                }
                            }
                        } );
                    }
                } ]
            } );
        },

        linkTypeSelectOnChange: function( linkTypeSelect, editor ) {
            linkTypeSelect.onChange = CKEDITOR.tools.override( linkTypeSelect.onChange, function( original ) {
                return function() {
                    original.call( this );   // Run the default logic (handles all other select items)

                    // Fetch our UI that we've added to the dialog.
                    var dialog = this.getDialog();
                    var ourUIControls = dialog.getContentElement( 'info', 'pageOptions' )
                        .getElement().getParent().getParent();
                    var uploadTab;

                    // Handle our own link type option
                    if( this.getValue() === 'page' ) {
                        ourUIControls.show();

                        // Set the visible states for CkEditor's linkTarget and upload tabs for our option.
                        if( editor.config.linkShowTargetTab ) {
                            dialog.showPage( 'target' );
                        }

                        uploadTab = dialog.definition.getContents( 'upload' );

                        if( uploadTab && !uploadTab.hidden ) {
                            dialog.hidePage( 'upload' );
                        }
                    }
                    else {
                        ourUIControls.hide();
                    }
                };
            } );
        },

        linkTypeSelectSetup: function( linkTypeSelect ) {
            linkTypeSelect.setup = function( data ) {
                if( data ) {
                    if( !data.type ) {   // Set 'internal page' as default
                        data.type = 'page';
                    } else if( data.type && data.type === 'url' && data.url && data.url.url ) {
                        // Internal page
                        if( data.url.url.indexOf( document.location.hostname ) > -1 ) {
                            data.type = 'page';
                        }
                    }
                }

                this.setValue( data.type );
            };
        },

        linkTypeSelectCommit: function( linkTypeSelect ) {
            linkTypeSelect.commit = function( data ) {
                data.type = this.getValue();

                if( data.type === 'page' ) {
                    data.type = 'url';

                    var dialog = this.getDialog();
                    var pageUrl = dialog.getValueOf( 'info', 'page' );
                    var urlParts = [];
                    var protocol = 'http://';   // default
                    var splitter = '://';

                    if( pageUrl.indexOf( splitter ) > -1 ) {
                        urlParts = pageUrl.split( splitter );
                        protocol = urlParts[ 0 ] + splitter;

                        dialog.setValueOf( 'info', 'url', urlParts[ 1 ] );
                    } else {
                        dialog.setValueOf( 'info', 'url', pageUrl );
                    }

                    dialog.setValueOf( 'info', 'protocol', protocol );
                }
            };
        },

        _addPagesToSelectElement: function( that, dfd ) {
            $.post(
                scc_data.ajax_url,
                {
                    'action': 'swcreator_get_page_list',
                    'ajax_nonce': scc_data.ajax_nonce,
                    'id': scc_data.page_id
                }
            ).done(
                function( pages ) {
                    var pageList = [];
                    var builder = function( wpPages, indent ) {
                        $.each( wpPages, function( index, page ) {
                            if( page.menu ) {
                                builder( page.menu, indent + '-' );
                            } else {
                                page.title = indent + page.title;

                                pageList.push( page );
                            }
                        } );
                    };

                    builder( pages, '' );

                    $.each( pageList, function( index, page ) {
                        that.add( page.title, page.value );
                    } );

                    dfd.resolve();
                }
            );
        }
    } );

    return new LinkType();
} );
swifty.define( 'js/components/editor_ckeditor/ckeditor_helpers/ckeditor_helper_setup_event_handlers',[
    'jquery',
    'swiftylib/evt',
    'swiftylib/compute',
    './ckeditor_helper_link_type'
], function(
    $, evt, Compute, editorLinkType
) {
    

    return function() {
        var self = this;
        var instance = self.instance;

        self.lastCopyPaste = null;

        // This fix will prevent multiple pastes when CTRL+V is hold down a bit longer.
        self.pasteOccured = new Compute( null );
        self.pasteOccured.bind( 'change', function( ev, newVal, oldVal ) {
            if( oldVal && newVal && oldVal.name === 'paste' && newVal.name === 'paste' ) {
                newVal.stop();
                // Reset after 1 second. For cases where the keyup might not be triggerd correctly.
                // Some people were not able to do multiple ctrl-v at all.
                setTimeout( function() {
                    self.pasteOccured( null );
                }, 1000 );
            }
        } );

        // When paste Dialog is shown we will allow the next paste.
        instance.on( 'pasteDialog', function( evt ) {
            self.pasteOccured( null );
        } );

        instance.on( 'pluginsLoaded', self.onPluginsLoadedHandler, self );
        instance.on( 'contentDom', self.onContentDomHandler, self );
        instance.on( 'instanceReady', self.onInstanceReadyHandler, self );

        instance.on( 'setData', function( ev ) {
            if( $.trim( ev.data.dataValue ) === '' ) {
                ev.data.dataValue = '<p></p>';
            }
        } );

        instance.on( 'insertElement', function( ev ) {
            var elName = ev.data.getName();
            var rows, row, nrOfRows, cols, col, nrOfCols, colWidth;

            if( elName.toLowerCase() === 'table' ) {
                rows = ev.data.find( 'tbody' ).getItem( 0 ).getChildren();   // Is a nodeList of table rows
                nrOfRows = rows.count();
                nrOfCols = rows.getItem( 0 ).getChildren().count();
                colWidth = Math.floor( ( 100 / nrOfCols ) * 10000 ) / 10000;   // 4 decimals

                for( var i = 0; i < nrOfRows; i++ ) {
                    row = rows.getItem( i );
                    cols = row.getChildren();   // Is a nodeList of table columns

                    for( var j = 0; j < nrOfCols; j++ ) {
                        col = cols.getItem( j );
                        col.setAttribute( 'width', colWidth + '%' );
                    }
                }

            }
        }, null, null, 1 );   // Priority < 10 gets called before insertion.

        instance.on( 'selectionChange', function( /*ev*/ ) {
            self.unlockSelection();
        } );

        /**
         * Check for widget in paste, prevent pasting into widgets
         */
        instance.on( 'paste', function( evt ) {
            var data = evt.data,
                // Prevent XSS attacks.
                tempDoc = document.implementation.createHTMLDocument( '' ),
                temp = new CKEDITOR.dom.element( tempDoc.body ),
                spans;

            // Without this isReadOnly will not work properly.
            temp.data( 'cke-editable', 1 );

            temp.appendHtml( data.dataValue );

            // only when there is a widget in the paste data
            var widgetInData = temp.find( 'div.cke_widget_wrapper' );
            if( widgetInData.count() > 0 ) {
                // remove drag span uit
                spans = temp.find( 'span.cke_widget_drag_handler_container' );
                $( spans.$ ).remove();

                // this is also called with drag drop, but then the insert position is handled differently
                if( ( ( data.method !== 'drop' ) && self.isCurrentInsertPositionInWidget() ) ) {
                    evt.stop(); // we don't let editor to paste data
                }

                // when we have just cutted the date then we know there is no issue with duplicates, otherwise create
                // new ids
                if( self.lastCopyPaste !== 'cut' ) {

                    self.replaceIds( temp );
                }
                data.dataValue = temp.getHtml();
            }

            self.pasteOccured( evt );
        } );

        instance.on( 'afterPaste', function() {
            // after drag drop we make columns readonly again
            $( '.swc_grid_column' ).attr( 'contenteditable', 'false' );
        } );

        CKEDITOR.on( 'dialogDefinition', function( ev ) {
            if( ev.editor.name === instance.name ) {
                var definition = ev.data.definition;
                var infoTab = definition.getContents( 'info' );

                if( ev.data.name === 'table' ) {
                    infoTab.get( 'txtWidth' )['default'] = '100%';   // Set default width to 100%
                }

                if( ev.data.name === 'link' ) {
                    var linkTypeSelect = infoTab.get( 'linkType' );   // The link type select box.

                    // Add the UI that is shown when the user selects our new link type option from the select box.
                    editorLinkType.insertNewLinkType( linkTypeSelect, infoTab );

                    // Show or hide our controls, when the user picks a new link type in the select box.
                    editorLinkType.linkTypeSelectOnChange( linkTypeSelect, ev.editor );

                    // When the link type select box is initialized with a value.
                    editorLinkType.linkTypeSelectSetup( linkTypeSelect );

                    // When the link type select box is supposed to save its value.
                    editorLinkType.linkTypeSelectCommit( linkTypeSelect );
                }
            }
        } );

        // Prevent CTRL+A select all outside of text assets. This solution should work on all browsers.
        $( window ).bind( 'keydown', function( event ) {
            if( event.ctrlKey || event.metaKey ) {
                switch( String.fromCharCode( event.which ).toLowerCase() ) {
                    case 'a':
                        event.preventDefault();
                        break;
                }
            }
        } );
    };

} );
swifty.define( 'js/components/editor_ckeditor/ckeditor_helpers/ckeditor_helper_cogs',[
    'jquery'
], function(
    $
) {
    

    return function( self, ckDragHandlerImage, $dragHandlerImage, allowDrag ) {
        // var clicking = false;
        // var move = 0;
        //
        // // Remove all the event listeners on this element.
        //
        // ckDragHandlerImage.removeAllListeners();
        //
        // $dragHandlerImage.on( 'mousedown', function( /*ev*/ ) {
        //     clicking = true;
        // } );
        //
        // $dragHandlerImage.on( 'mouseup', function( /*ev*/ ) {
        //     move = 0;
        // } );
        //
        // $( document ).on( 'mouseup', function( /*ev*/ ) {
        //     clicking = false;
        // } );
        //
        // $dragHandlerImage.on( 'mousemove', mouseMoveHandler );
        //
        // function mouseMoveHandler() {
        //     if( clicking === false ) {
        //         return;
        //     }
        //
        //     move++;
        //
        //     if( move > 5 && allowDrag === 1 ) {
        //
        //         // before drag drop we make columns editable
        //         $( '.swc_grid_column' ).attr( 'contenteditable', 'true' );
        //
        //         onBlockWidgetDrag();
        //         $dragHandlerImage.off( 'mousemove' );
        //         move = 0;
        //     }
        // }
        //
        // // We need to make sure there is something in the column after dragging an asset away.
        // // Check if asset will be dragged outside the current column, if so make sure there is something left in it
        // self.checkEmptyColumn = function( target ) {
        //     var self = this;
        //     var $sourceColumns = $( self.element.$ ).closest( '.swc_grid_column' );
        //     if( $sourceColumns.length === 1 ) {
        //         // Do we need to check if sourceColumn will be empty after drop?
        //         var $targetColumns = $( target.$ ).closest( '.swc_grid_column' );
        //         if( ( $targetColumns.length === 0 ) || ( $sourceColumns[0] !== $targetColumns[0] ) ) {
        //             if( $sourceColumns[0].childElementCount === 1 ) {
        //                 var $ptag = $( '<p><br><p>' );
        //                 $sourceColumns.append( $ptag );
        //             }
        //         }
        //     }
        // };
        //
        // // Copied onBlockWidgetDrag from CKEditor / widget / plugin.js.
        // // We need to override the mousedown event on the draghandler.
        // // Changed: 'this' -> 'self'
        // // Added: var sender = ( evt && evt.sender ) ? evt.sender : ckDragHandlerImage;
        // // Changed: evt.sender -> sender
        // // Added: relations filter by using relations2
        // function onBlockWidgetDrag( evt ) {
        //     // Swifty code: We use onBlockWidgetDrag in mouseMoveHandler above without the evt parameter.
        //     var sender = ( evt && evt.sender ) ? evt.sender : ckDragHandlerImage;
        //
        //     var finder = self.repository.finder,
        //         locator = self.repository.locator,
        //         liner = self.repository.liner,
        //         editor = self.editor,
        //         editable = editor.editable(),
        //         listeners = [],
        //         sorted = [];
        //
        //     // Mark dragged widget for repository#finder.
        //     self.repository._.draggedWidget = self;
        //
        //     // Harvest all possible relations and display some closest.
        //     var relations2 = finder.greedySearch(),
        //         relations = {};
        //
        //     // Ignore divs grid system
        //     $.each( relations2, function( index, item ) {
        //         var add = true;
        //
        //         // no drag into text asset
        //         var $text_asset = $( item.element.$ ).parents( '.swc_text' );
        //         if( $text_asset.length > 0 ) {
        //             add = false;
        //         } else {
        //             // only drag to columns when in grid, column should be a direct parent
        //             var $column = $( item.element.$ ).closest( '.swc_grid_row' );
        //             if( $column.length > 0 ) {
        //                 if( ! $( item.element.$.parentElement ).hasClass( 'swc_grid_column' ) ) {
        //                     add = false;
        //                 }
        //             }
        //         }
        //
        //         if( add ) {
        //             relations[ index ] = item;
        //         }
        //     } );
        //
        //     var buffer = CKEDITOR.tools.eventsBuffer( 50, function() {
        //             locations = locator.locate( relations );
        //
        //             // There's only a single line displayed for D&D.
        //             sorted = locator.sort( y, 1 );
        //
        //             if( sorted.length ) {
        //                 liner.prepare( relations, locations );
        //                 liner.placeLine( sorted[0] );
        //                 liner.cleanup();
        //             }
        //         } ),
        //
        //         locations, y;
        //
        //     // Let's have the "dragging cursor" over entire editable.
        //     editable.addClass( 'cke_widget_dragging' );
        //
        //     // Cache mouse position so it is re-used in events buffer.
        //     listeners.push( editable.on( 'mousemove', function( evt ) {
        //         y = evt.data.$.clientY;
        //         buffer.input();
        //     } ) );
        //
        //     // Fire drag start as it happens during the native D&D.
        //     //editor.fire( 'dragstart', { target: evt.sender } );
        //     editor.fire( 'dragstart', { target: sender } );
        //
        //     function onMouseUp() {
        //         var l;
        //
        //         buffer.reset();
        //
        //         // Stop observing events.
        //         while( ( l = listeners.pop() ) ) {
        //             l.removeListener();
        //         }
        //
        //         //onBlockWidgetDrop.call( self, sorted, evt.sender );
        //         onBlockWidgetDrop.call( self, sorted, sender );
        //     }
        //
        //     // Mouseup means "drop". This is when the widget is being detached
        //     // from DOM and placed at range determined by the line (location).
        //     listeners.push( editor.document.once( 'mouseup', onMouseUp, self ) );
        //
        //     // Prevent calling 'onBlockWidgetDrop' twice in the inline editor.
        //     // `removeListener` does not work if it is called at the same time event is fired.
        //     if ( !editable.isInline() ) {
        //         // Mouseup may occur when user hovers the line, which belongs to
        //         // the outer document. This is, of course, a valid listener too.
        //         listeners.push( CKEDITOR.document.once( 'mouseup', onMouseUp, self ) );
        //     }
        // }
        //
        // // Copied onBlockWidgetDrop from CKEditor / widget / plugin.js.
        // // We need to override the mousedown event on the draghandler.
        // // Changed: 'this' into 'self'
        // // Added: $dragHandlerImage.on( 'mousemove', mouseMoveHandler );
        // // Added: checkEmptyColumn call
        // function onBlockWidgetDrop( sorted, dragTarget ) {
        //     var finder = self.repository.finder,
        //         liner = self.repository.liner,
        //         editor = self.editor,
        //         editable = self.editor.editable();
        //
        //     if( !CKEDITOR.tools.isEmpty( liner.visible ) ) {
        //         // Retrieve range for the closest location.
        //         var dropRange = finder.getRange( sorted[0] );
        //
        //         // Focus widget (it could lost focus after mousedown+mouseup)
        //         // and save this state as the one where we want to be taken back when undoing.
        //         self.focus();
        //
        //         // Swifty code: test for empty column
        //         self.checkEmptyColumn( dropRange.startContainer );
        //
        //         // Drag range will be set in the drop listener.
        //         editor.fire( 'drop', {
        //             dropRange: dropRange,
        //             target: dropRange.startContainer
        //         } );
        //     }
        //
        //     // Clean-up custom cursor for editable.
        //     editable.removeClass( 'cke_widget_dragging' );
        //
        //     // Clean-up all remaining lines.
        //     liner.hideVisible();
        //
        //     // Clean-up drag & drop.
        //     editor.fire( 'dragend', { target: dragTarget } );
        //
        //     // Swifty code: attach the mousemove event handler again.
        //     $dragHandlerImage.on( 'mousemove', mouseMoveHandler );
        // }
    }

} );
swifty.define( 'js/components/editor_ckeditor/ckeditor_helpers/ckeditor_helper_resizeicon',[
    'jquery',
    'swiftylib/i18n/__',
    'js/diverse/utils',
    'swiftylib/evt'
], function(
    $, __, Utils, evt
) {
    

    // Handles resize icon for assets and text widget

    return function( self, ckDragHandlerImage, $dragHandlerImage, $dragHandlerContainer ) {

        var wrapper = self.wrapper;
        // When the mouse enters an asset the resize icon is shown on top of the asset

        $( wrapper.$ ).on( 'mouseenter', function( el/*, ev*/ ) {
            // do not show the resize icon when the edit icon is hidden, this solves a difficulty that
            // we should not create a extra asset instance for storing the resized width while the edit
            // panel is open
            if( $dragHandlerContainer.hasClass( 'swc_hide_asset_icon' ) ) {
                return;
            }

            var $editorWrapper = $( el.currentTarget );
            // we do not want inline assets which are span
            var $assetWrapper = $editorWrapper.children( 'div.swc_asset, div.swc_text' );
            if( $assetWrapper.length !== 1) {
                return;
            }

            // Do not show the resize icon when advanced ui mode is not advanced and the asset is not inside a text asset.
            if( $assetWrapper.closest( '.swc_text' ).length <= 0 ) {
                return;
            }

            var cssFloat = $assetWrapper.css( 'float' );

            var assetType = $assetWrapper.attr( 'data-asset_type' );
            var $assetContainer = $editorWrapper.find( '.swc_asset_cntnt' );

            var $widthContainer = $assetWrapper;

            var data = $.parseJSON( Utils.atou( $assetContainer.attr( 'data-asset_data' ) ) );
            if( data && data.swc_position ) {
                if( data.swc_position === 'center' ) {
                    $widthContainer = $assetContainer;
                    cssFloat = 'none';
                } else if( ( + data.swc_width ) === 100 ) {
                    cssFloat = 'none';
                } else {
                    cssFloat = data.swc_position;
                }
            }

            var $iconWrapper;
            var $icon;
            var startPos;
            var startWidth;

            // Add the resize icon to the asset

            if( $assetWrapper.find( '.swc_asset_resizer_icon_wrapper' ).length ) {
                $assetWrapper.find( '> div > .swc_asset_resizer_icon_wrapper' ).removeClass( 'swc_will_remove' );
            } else {
                $assetWrapper.prepend(
                    '<span ' +
                    'class="swc_asset_resizer_icon_wrapper cke_reset cke_widget_drag_handler_container" ' +
                    'contenteditable="false" ' +
                    'title="' + __( 'Click and drag to resize' ) + '" ' +
                    '>' +
                    '<i class="fa fa-arrows-h" contenteditable="false"></i>' +
                    '</span>'
                );
            }

            $iconWrapper = $assetWrapper.find( '.swc_asset_resizer_icon_wrapper' );
            $icon = $iconWrapper.find( '.fa' );

            // Handle the resizing of the asset via it's resize icon

            $icon.mousecapture( {
                'down': function( ev ) {
                    startPos = ev.pageX;
                    $dragHandlerContainer.addClass( 'swc_hide_asset_icon' );
                    $('body').addClass('swc_resize');
                },
                'move': function( ev ) {
                    var diff = startPos - ev.pageX;
                    var multiFactor = 2;

                    if( cssFloat === 'right' ) {
                        multiFactor = 1;
                    } else if( cssFloat === 'left' ) {
                        multiFactor = -1;
                    }

                    var newPercent = Math.ceil( 100 * ( startWidth + diff * multiFactor ) / $widthContainer.offsetParent().width() );

                    newPercent = Math.max( newPercent, 10 );
                    newPercent = Math.min( newPercent, 100 );

                    $widthContainer.css( 'width', newPercent + '%' );

                    if ( assetType === 'swifty_slider' || assetType === 'swifty_slideshow' ) {
                        evt( 'resize_slides', {}, $assetContainer );
                    }
                },
                'up': function() {
                    $dragHandlerContainer.removeClass( 'swc_hide_asset_icon' );
                    $icon.remove();
                    $('body').removeClass('swc_resize');

                    // send to server
                    evt(
                        'swifty_editor_asset_dialog',
                        {
                            'el': $assetContainer,
                            'mod': 'icon_resized',
                            'inline': self.inline,
                            'init_css': false
                        }
                    );
                }
            } );

            var css = {};
            var doCss = true;
            var posObj = {
                my: 'top',
                at: 'bottom+4',
                of: $assetWrapper,
                collision: 'none'
            };

            if( !cssFloat || cssFloat === 'none' || cssFloat === 'right' ) {
                css.left = 0;

                // It doesn't fit
                if( $assetWrapper.outerHeight() < $iconWrapper.outerHeight() ) {
                    doCss = false;
                    $iconWrapper.position( posObj );
                } else {
                    css.bottom = 0; // '2px';
                }
            } else if( cssFloat === 'left' ) {
                css.right = 0;

                // It doesn't fit
                if( $assetWrapper.outerHeight() < $iconWrapper.outerHeight() ) {
                    doCss = false;
                    $iconWrapper.position( posObj );
                } else if( $assetWrapper.outerHeight() > $iconWrapper.outerHeight() &&
                    $assetWrapper.outerHeight() < 2 * $iconWrapper.outerHeight()
                ) {
                    // No room for 2 buttons, place at the other side
                    css.bottom = 0; // '2px';
                } else {
                    css.left = 'auto';
                    css.right = 0;
                    css.bottom = 0; // '2px';
                }
            }

            if( doCss ) {
                $iconWrapper.css( css );
            }

            // remember for drag resize
            startWidth = $widthContainer.width();

            return false;
        } );

        // Remove resize icon when leaving the asset

        $( wrapper.$ ).on( 'mouseleave', function( /* el, ev*/ ) {
            $( wrapper.$ ).find( '> div > .swc_asset_resizer_icon_wrapper' ).addClass( 'swc_will_remove' );
            setTimeout( function() {
                $( wrapper.$ ).find( '.swc_will_remove' ).remove();
            }, 1000 );
        } );
    };
} );

swifty.define( 'js/components/editor_ckeditor/ckeditor_helpers/ckeditor_helper_cogicon',[
    'jquery',
    'swiftylib/i18n/__',
    'swiftylib/evt',
], function(
    $, __, evt
) {
    

    // Handles cog icon for assets and text widgets and rows,

    function addCogs( self, ckDragHandlerImage, $dragHandlerImage, $dragHandlerContainer, asType, $wrapper, isLocked ) {

        var $textWrapper = $wrapper.closest( '.swc_text' );
        var $wrapper2 = $textWrapper.parent();
        if( $wrapper2.length > 0 ) {
            var locked = $textWrapper.hasClass( 'swc_locked' );
            var childIsLocked = ( locked && ( ! scc_data.swifty_edit_locked ) );
            addCogs( self, ckDragHandlerImage, $dragHandlerImage, $dragHandlerContainer, 'text', $wrapper2, childIsLocked );
        }

        var $rowWrapper = $wrapper.closest( '.swc_grid_row' );
        $wrapper2 = $rowWrapper.parent();
        if( $wrapper2.length > 0 ) {
            var locked = $rowWrapper.hasClass( 'swc_locked' );
            var childIsLocked = ( locked && ( ! scc_data.swifty_edit_locked ) );
            addCogs( self, ckDragHandlerImage, $dragHandlerImage, $dragHandlerContainer, 'row', $wrapper2, childIsLocked );
        }

        // Do not show the cog icon when the edit icon is hidden.
        if( $dragHandlerContainer.hasClass( 'swc_hide_asset_icon' ) ) {
            return;
        }

        var $editorWrapper = $wrapper;
        var $assetWrapper = $editorWrapper.find( 'div.swc_grid_row, div.swc_asset, div.swc_text' ).first();
        var $assetWrapperCK = $assetWrapper.parent();

        var locked = $assetWrapper.hasClass( 'swc_locked' );

        // Add the cog icon to the asset

        if( $assetWrapperCK.find( '.swc_asset_cog_icon_wrapper' ).length ) {
            $assetWrapperCK.find( '> .swc_asset_cog_icon_wrapper, > .swc_asset_any_icon_wrapper, > .swc_asset_adv_icons_wrapper' ).removeClass( 'swc_will_remove' );
        } else {
            var dragData = {};

            var $handler = $( getGuiIcon(
                'swc_asset_cog_icon_wrapper' + ( asType === 'row' ? ' swc_asset_cog_icon_row_wrapper' : '' ),
                // ( scc_data.swifty_gui_mode === 'advanced' ? '&#xe013;' : 'fa-cog' ),
                ( isLocked ? 'fa-lock' : 'fa-cog' ),
                ( isLocked ? '' : __( 'Click for options or drag to move' ) ), 0 )
            ).prependTo( $assetWrapperCK );

            var xOffsetTransform = 0;
            var yOffsetTransform = 0;
            if( typeof  swifty_parseMatrix === 'function' ) {
                // For scroll moving assets place the cog icons at the original position.
                var mx = swifty_parseMatrix( getComputedStyle( $assetWrapper[0], null ).transform );
                xOffsetTransform = mx.m41;
                yOffsetTransform = mx.m42;
            }

            $handler.position( {
                my: ( asType === 'row' ) ? 'right bottom-1' : 'right top',
                at: 'right-' + xOffsetTransform + ' top-' + yOffsetTransform,
                of: $assetWrapper,
                collision: 'none'
            } );

            evt( 'get_asset_name', {
                'el': $assetWrapper.find( '> .swc_asset_cntnt' ),
                'inline': false
            } ).then( function( name ) {
                if( asType === 'row' ) {
                    name = __( 'Columns' );
                }

                var $title = $( '<span class="swc_asset_title_icons_wrapper">' + name.toLowerCase() + '</span>' ).appendTo( $handler );

                $title.position( {
                    my: 'left',
                    at: 'right',
                    of: $handler,
                    collision: 'none'
                } );
            } );

            var posHandler = getElPos( $handler );

            // Make sure cog icons do not overlap.
            $( '.swc_asset_cog_icon_wrapper' ).not( $handler ).each( function( ii, el ) {
                var $el = $( el );
                var pos = getElPos( $el );

                if( posHandler.x < pos.x + pos.w && posHandler.x + posHandler.w > pos.x ) {
                    if( posHandler.y < pos.y + pos.h && posHandler.y + posHandler.h > pos.y ) {
                        $handler.position( {
                            my: 'top',
                            at: 'bottom+1',
                            of: $el,
                            collision: 'none'
                        } );
                    }
                }
            } );

            // Add extra icons in advanced gui mode
            var $advGuiWrapper = null;
            if( ( scc_data.swifty_gui_mode === 'advanced' ) && ! isLocked ) {
                $advGuiWrapper = $( '<span class="swc_asset_adv_icons_wrapper swc_asset_any_icon_wrapper swc_nopluscollision">' + getAdvGuiIcons( locked ) + '</span>' ).appendTo( $assetWrapperCK.find( '> .swc_asset_cog_icon_wrapper' ) );

                // Force the width of the wrapper. Otherwise they will wrap vertically.
                $advGuiWrapper.attr( 'style', 'width: ' + ( $advGuiWrapper.find( '.swc_asset_any_icon_wrapper' ).length * 33 ) + 'px !important;' );

                $advGuiWrapper.position( {
                    my: 'right',
                    at: 'left',
                    of: $handler,
                    collision: 'none'
                } );

                $advGuiWrapper.find( '.swc_asset_edit_icon_wrapper' ).on( 'click', function( /*ev*/ ) {
                    clickedIcon( 'edit', self, $( this ), asType );
                } );
                $advGuiWrapper.find( '.swc_asset_move_icon_wrapper' ).on( 'click', function( /*ev*/ ) {
                    clickedIcon( 'move', self, $( this ), asType );
                } );
                $advGuiWrapper.find( '.swc_asset_delete_icon_wrapper' ).on( 'click', function( /*ev*/ ) {
                    clickedIcon( 'delete', self, $( this ), asType );
                } );
                $advGuiWrapper.find( '.swc_asset_lock_icon_wrapper' ).on( 'click', function( /*ev*/ ) {
                    clickedIcon( 'lock', self, $( this ), asType );
                } );
                $advGuiWrapper.find( '.swc_asset_unlock_icon_wrapper' ).on( 'click', function( /*ev*/ ) {
                    clickedIcon( 'unlock', self, $( this ), asType );
                } );
                $advGuiWrapper.find( '.swc_asset_copy_icon_wrapper' ).on( 'click', function( /*ev*/ ) {
                    clickedIcon( 'copy', self, $( this ), asType );
                } );
            }

            if( isLocked ) {
                $handler.on( 'click', function( /*ev*/ ) {
                    clickedIcon( 'locked', self, $( this ), asType );
                } );
            } else {
                // Open the asset panel when the cog icon is clicked.
                $handler.on( 'click', function( /*ev*/ ) {
                    clickedIcon( 'main', self, $( this ), asType );
                } );

                $handler.draggable( {
                    cursorAt: { right: 0, top: 0 },
                    cursor: 'move',
                    delay: 100,
                    distance: 5,
                    opacity: 0.6,
                    zIndex: 999999,
                    appendTo: $( '.swc_page_cntnt.cke_editable' ),
                    helper: function() {
                        var pos = getElPos( $assetWrapper );
                        var $el = $assetWrapper.clone();
                        $el.addClass( 'swc_drag_ori_placeholder' );

                        // Replace video asset contents, because theay are too intensive to drag.
                        $el.find( '.swc_video_wrapper' ).replaceWith(
                            '<span class="swc_video_drag_wrapper">' + __( 'Video' ) + '</span>' );

                        var hMax = 200;
                        var hGradient = 100;
                        var h2 = pos.h;
                        if( h2 > hMax ) {
                            h2 = hMax;
                        }

                        $el = $( '<div></div>' ).append( $el );

                        var html = '<div class="swc_drag_helper" style="width: ' + pos.w + 'px; height: ' + h2 + 'px;">' +
                            '<svg style="width: ' + pos.w + 'px; height: ' + h2 + 'px;">' +
                            '  <defs>' +
                            '    <mask id="swc_drag_mask123" maskUnits="userSpaceOnUse" maskContentUnits="userSpaceOnUse">' +
                            '      <linearGradient id="swc_drag_gradient123" gradientUnits="objectBoundingBox" x2="0" y2="1">' +
                            '        <stop stop-color="white" stop-opacity="1" offset="0" />' +
                            '        <stop stop-color="white" stop-opacity="0" offset="1" />' +
                            '      </linearGradient>';
                        if( pos.h > hMax ) {
                            html += '      <rect x="0" y="0" width="' + pos.w + 'px" height="' + ( h2 - hGradient ) + 'px" fill="rgb(255,255,255)" />' +
                                '      <rect x="0" y="' + ( h2 - hGradient ) + '" width="' + pos.w + 'px" height="' + hGradient + 'px" fill="url(#swc_drag_gradient123)" />';
                        } else {
                            html += '      <rect x="0" y="0" width="' + pos.w + 'px" height="' + h2 + 'px" fill="rgb(255,255,255)" />';
                        }
                        html += '    </mask>' +
                            '  </defs>' +
                            '  <foreignObject width="100%" height="100%" style="mask: url(#swc_drag_mask123);">' +
                            $el.html();
                        '  </foreignObject>' +
                        '</svg>' +
                        '</div>';

                        $el = $( html );

                        dragData = {};
                        dragData.width = pos.w;

                        $assetWrapper.addClass( 'swc_drag_drag_hide' );
                        $el.addClass( 'swc_drag_drag_placeholder' );

                        return $el;
                    },
                    start: function( /*event, ui*/ ) {
                        $( 'body' ).addClass( 'swc_no_editor_hovers' );

                        // Fix for browsers not setting the drag cursor correctly (because of iframe?)
                        $( '*' ).addClass( 'swc_fix_cursor_move' );

                    },
                    stop: function( /*event, ui*/ ) {
                        $( 'body' ).removeClass( 'swc_no_editor_hovers' );

                        // Fix for browsers not setting the drag cursor correctly (because of iframe?)
                        $( '*' ).removeClass( 'swc_fix_cursor_move' );

                        $assetWrapper.removeClass( 'swc_drag_drag_hide' );

                        if( $( '.swc_drag_insert_placeholder' ).length > 0 ) {
                            $( '.swc_drag_helper' ).remove();

                            evt(
                                'swifty_editor_change_asset_location',
                                {
                                    '$assetWrapper': $assetWrapper,
                                    '$placeholder': $( '.swc_drag_insert_placeholder' )
                                }
                            );
                        }
                    },
                    drag: function( event, ui ) {
                        var xOffset = ui.offset.left;
                        var yOffset = ui.offset.top;
                        var x = xOffset + dragData.width;
                        var y = yOffset;

                        var $elOver = null;
                        var modeOver = 'prev';

                        if( asType === 'row' ) {
                            var posSet = 0;
                            $( '.swc_page_cntnt.cke_editable' ).find( '.swc_grid_row' ).not( '.swc_drag_ori_placeholder' ).not( '.swc_drag_drag_hide' ).each( function( ii, el ) {
                                var $el = $( el );
                                var pos = getElPos( $el );
                                if( y >= pos.y + pos.h / 2 ) {
                                    $elOver = $el.parent();
                                    modeOver = 'next';
                                    posSet ++;
                                }
                                if( posSet === 0 ) {
                                    $elOver = $( '.swc_page_cntnt.cke_editable' );
                                    modeOver = 'prepend';
                                }
                            } );
                        } else {
                            $( '.swc_page_cntnt.cke_editable' ).find( '.swc_grid_column, .swc_asset, .swc_text' ).not( '.swc_drag_ori_placeholder' ).not( '.swc_drag_drag_hide' ).each( function( ii, el ) {
                                var $el = $( el );
                                var pos = getElPos( $el );
                                if( x >= pos.x && x < pos.x + pos.w ) {
                                    if( y >= pos.y && y < pos.y + pos.h ) {
                                        if( $el.hasClass( 'swc_text' ) ) {
                                            var posSet = 0;
                                            $el.find( '> .swc_asset_cntnt > *' ).not( '.swc_drag_ori_placeholder' ).not( '.swc_drag_drag_hide' ).each( function( ii, el ) {
                                                var $el2 = $( el );
                                                var pos2 = getElPos( $el2 );
                                                if( y >= pos2.y + pos2.h / 2 ) {
                                                    $elOver = $el2;
                                                    modeOver = 'next';
                                                    posSet ++;
                                                }
                                            } );
                                            if( posSet === 0 ) {
                                                $elOver = $el.find( '.swc_asset_cntnt' );
                                                modeOver = 'prepend';
                                            }
                                            // Mouse over the top 5px of the text asset will move the asset above the text asset instead of inside.
                                            if( y < pos.y + 5 ) {
                                                $elOver = $el.closest( '.swc_grid_column' );
                                                modeOver = 'prepend';
                                            }
                                            // Mouse over the bottom 5px of the text asset will move the asset below the text asset instead of inside.
                                            if( y > pos.y + pos.h - 5 ) {
                                                $elOver = $el;
                                                modeOver = 'next';
                                            }
                                        }
                                        if( $el.hasClass( 'swc_grid_column' ) ) {
                                            var posSet = 0;
                                            $el.find( '> .cke_widget_wrapper > .swc_asset, > .cke_widget_wrapper > .swc_text' ).not( '.swc_drag_ori_placeholder' ).not( '.swc_drag_drag_hide' ).each( function( ii, el ) {
                                                var $el2 = $( el );
                                                var pos2 = getElPos( $el2 );
                                                if( y >= pos2.y + pos2.h / 2 ) {
                                                    $elOver = $el2.parent();
                                                    modeOver = 'next';
                                                    posSet ++;
                                                }
                                            } );
                                            if( posSet === 0 ) {
                                                $elOver = $el;
                                                modeOver = 'prepend';
                                            }
                                        }
                                    }
                                }
                            } );
                        }

                        if( $elOver ) {
                            var $oldPlaceholder = $( '.swc_drag_insert_placeholder' );
                            var $placeholder = $( '<div class="swc_drag_insert_placeholder"></div>' );

                            if( modeOver === 'prepend' ) {
                                if( ! $elOver.children().first().hasClass( 'swc_drag_insert_placeholder' ) ) {
                                    $placeholder.prependTo( $elOver );
                                    $oldPlaceholder.remove();
                                }
                            } else if( modeOver === 'next' ) {
                                if( ! $elOver.next().hasClass( 'swc_drag_insert_placeholder' ) ) {
                                    $placeholder.insertAfter( $elOver );
                                    $oldPlaceholder.remove();
                                }
                            } else {
                                if( ! $elOver.prev().hasClass( 'swc_drag_insert_placeholder' ) ) {
                                    $placeholder.insertBefore( $elOver );
                                    $oldPlaceholder.remove();
                                }
                            }
                        } else {
                            $( '.swc_drag_insert_placeholder' ).remove();
                        }
                    }
                } );
            }
        }
    }

    function getElPos( $el ) {
        var pos = {};

        var offset = $el.offset();
        pos.x = offset.left;
        pos.y = offset.top;
        pos.w = $el.outerWidth( false );
        pos.h = $el.outerHeight( false );

        return pos;
    }

    function getGuiIcon( cls, icon, title, divider ) {
        var html = '<span ' +
        'class="' + cls + ' swc_asset_any_icon_wrapper cke_reset cke_widget_drag_handler_container' +
        ( divider === 1 ? ' swc_nopluscollision' : '' ) +
        ( scc_data.swifty_gui_mode === 'advanced' ? ' swc_asset_adv_icon_wrapper' : '' ) +
        '" ' +
        'contenteditable="false" ' +
        'title="' + title + '" ' +
        '>' +
        ( icon.substr( 0, 3 ) !== 'fa-' ? '<div class="swc_icon" contenteditable="false"><span aria-hidden="true" contenteditable="false">' + icon + '</span></div>'
            : '<i class="fa ' + icon + '" contenteditable="false"></i>' ) +
        '</span>';
        
        if( divider === 1 ) {
            html += '<span class="swc_icon_wr_divider"></span>';
        }
        
        return html;
    }

    function getAdvGuiIcons( locked ) {
        var html = '';

        if( scc_data.swifty_change_lock ) {
            if( locked ) {
                html += getGuiIcon( 'swc_asset_unlock_icon_wrapper', 'fa-lock', '', 1 );
            } else {
                html += getGuiIcon( 'swc_asset_lock_icon_wrapper', 'fa-unlock', '', 1 );
            }
        }

        html += getGuiIcon( 'swc_asset_delete_icon_wrapper', '&#xe00b;', '', 1 );
        html += getGuiIcon( 'swc_asset_copy_icon_wrapper', 'fa-copy', '', 1 );
        html += getGuiIcon( 'swc_asset_move_icon_wrapper', '&#xe013;', '', 1 );
        // html += getGuiIcon( 'swc_asset_edit_icon_wrapper', '&#xe03f;', '', 1 );

        return html;
    }

    function clickedIcon( mod, self, $clickEl, asType ) {

        // Hide resizer when opening panel.
        $( '.swc_asset_resizer_icon_wrapper' ).remove();

        if( asType === 'row' ) {
            var $el = $clickEl.closest( '.cke_widget_wrapper' ).find( '.swc_grid_row' );

            if( $clickEl.hasClass( 'swc_hide_asset_icon' ) ) {
                return;
            }

            $( '.swc_asset_cog_icon_wrapper, .swc_asset_any_icon_wrapper, .swc_asset_adv_icons_wrapper' ).remove();

            // Open the row panel.
            if( mod === 'main' && scc_data.swifty_gui_mode !== 'advanced' ) {
                evt(
                    'swifty_editor_row_dialog',
                    {
                        '$row': $el,
                        'mod': 'icon_clicked',
                        'inline': self.inline
                    }
                );
            } else if(  mod === 'main' && scc_data.swifty_gui_mode === 'advanced' ) {
                // evt( 'swifty_editor_row_move_dialog', { '$row': $el } );
                evt( 'swifty_editor_row_edit_dialog', { '$row': $el } );
            } else if( mod === 'edit' ) {
                evt( 'swifty_editor_row_edit_dialog', { '$row': $el } );
            } else if( mod === 'move' ) {
                evt( 'swifty_editor_row_move_dialog', { '$row': $el } );
            } else if( mod === 'delete' ) {
                evt( 'swifty_editor_row_delete_dialog', { '$row': $el } );
            } else if( mod === 'lock' ) {
                evt( 'swifty_editor_row_lock', { '$row': $el, 'locked': true } );
            } else if( mod === 'unlock' ) {
                evt( 'swifty_editor_row_lock', { '$row': $el, 'locked': false } );
            } else if( mod === 'copy' ) {
                evt( 'swifty_editor_row_copy', { '$row': $el } );
            } else if( mod === 'locked' ) {
                evt( 'swifty_editor_row_locked', {} );
            }
        } else {
            var $el = $clickEl.closest( '.cke_widget_wrapper' ).children( '.swc_text, .swc_asset' ).children( '.swc_asset_cntnt' );

            if( $clickEl.hasClass( 'swc_hide_asset_icon' ) ) {
                return;
            }

            $( '.swc_asset_cog_icon_wrapper, .swc_asset_any_icon_wrapper, .swc_asset_adv_icons_wrapper' ).remove();

            // Open the asset panel
            if( mod === 'main' && scc_data.swifty_gui_mode !== 'advanced' ) {
                evt(
                    'swifty_editor_asset_dialog',
                    {
                        'el': $el,
                        'mod': 'icon_clicked',
                        'inline': self.inline,
                        'init_css': false
                    }
                );
            } else if(  mod === 'main' && scc_data.swifty_gui_mode === 'advanced' ) {
                // evt( 'swifty_editor_asset_move_dialog', { 'el': $el } );
                evt( 'swifty_editor_asset_edit_dialog', { 'el': $el } );
            } else if( mod === 'edit' ) {
                evt( 'swifty_editor_asset_edit_dialog', { 'el': $el } );
            } else if( mod === 'move' ) {
                evt( 'swifty_editor_asset_move_dialog', { 'el': $el } );
            } else if( mod === 'delete' ) {
                evt( 'swifty_editor_asset_delete_dialog', { 'el': $el } );
            } else if( mod === 'lock' ) {
                evt( 'swifty_editor_asset_lock', { 'el': $el, 'locked': true } );
            } else if( mod === 'unlock' ) {
                evt( 'swifty_editor_asset_lock', { 'el': $el, 'locked': false } );
            } else if( mod === 'copy' ) {
                evt( 'swifty_editor_asset_copy', { 'el': $el } );
            } else if( mod === 'locked' ) {
                evt( 'swifty_editor_asset_locked', {} );
            }
        }
    }

    return function( self, ckDragHandlerImage, $dragHandlerImage, $dragHandlerContainer, asType, isLocked ) {
        var $wrapper = $( self.wrapper.$ );

        // When the mouse enters an asset the cog icon is shown on top of the asset.
        $wrapper.on( 'mouseenter', function( /*el, ev*/ ) {
            addCogs( self, ckDragHandlerImage, $dragHandlerImage, $dragHandlerContainer, asType, $wrapper, isLocked );
        } );

        // Remove cog icon when leaving the asset.
        $wrapper.on( 'mouseleave', function( /* el, ev*/ ) {
            $wrapper.find( '> .swc_asset_cog_icon_wrapper, > .swc_asset_any_icon_wrapper, > .swc_asset_adv_icons_wrapper' ).addClass( 'swc_will_remove' );
            setTimeout( function() {
                $wrapper.find( '.swc_will_remove' ).remove();
            }, 1000 );
        } );
    }
} );

swifty.define( 'js/components/editor_ckeditor/ckeditor_helpers/ckeditor_helper_plusicon',[
    'jquery',
    'swiftylib/i18n/__',
    'swiftylib/evt'
], function(
    $, __, evt
) {
    

    // Handles plus icon for assets and text widget

    var pTagEventsAdded = 0;

    return function( self, $dragHandlerContainer ) {

        if( pTagEventsAdded === 0 ) {
            var pSelector = '.swc_text > .swc_asset_cntnt > p, .swc_text > .swc_asset_cntnt > * > p';

            // Add + icons to all p tags of text assets on hover.
            // Live binded to future p elements.
            $( '.swc_page_cntnt.cke_editable' ).on( 'mouseenter', pSelector, function( ev ) {
                if( $( 'body' ).hasClass( 'swc_no_editor_hovers' ) ) {
                    return;
                }

                // Do not show the plus icon when the edit icon is hidden.
                if( $dragHandlerContainer.hasClass( 'swc_hide_asset_icon' ) ) {
                    return;
                }

                var $editorWrapper = $( ev.currentTarget );
                var $textWrapper = $editorWrapper.closest( 'div.swc_text' );
                var $assetWrapper = $editorWrapper.closest( 'div.swc_grid_column' );
                var $rowWrapper = $assetWrapper.closest( '.swc_grid_row' );
                $assetWrapper = $rowWrapper.parent();

                // Only show paragraph + icons when:
                // 1. text asset is 100%
                // 2. only 1 column in the row
                // 3. there are at least 2 paragraphs in the text asset.
                if( $textWrapper[ 0 ].style.width !== '100%' ) {
                    return;
                }
                if( $rowWrapper.find( '.swc_grid_column' ).length > 1 ) {
                    return;
                }
                if( $textWrapper.find( '> .swc_asset_cntnt > p, > .swc_asset_cntnt > * > p' ).length <= 1 ) {
                    return;
                }

                var locked = $textWrapper.hasClass( 'swc_locked' );
                if( ! locked || scc_data.swifty_edit_locked ) {

                    if( $editorWrapper.find( '> .swc_asset_p_plus_icon_wrapper' ).length ) {
                        $editorWrapper.find( '> .swc_asset_p_plus_icon_wrapper' ).removeClass( 'swc_will_remove' );
                    } else {
                        $editorWrapper.append( getPlusIconHtml( 'swc_asset_p_plus_icon_wrapper' ) );

                        var $iconWrapper = $editorWrapper.find( '.swc_asset_p_plus_icon_wrapper' );
                        var $icon = $iconWrapper.find( '.fa' );

                        $icon.on( 'click', function( /*ev*/ ) {
                            evt( 'set_paragraph_range_for_insert', {
                                '$p': $editorWrapper
                            } ).done( function() {
                                evt( 'add_content_panel', { 'allowance': 'insize_text_asset' } );
                            } );
                        } );

                        var left = 0;
                        var top = 0;
                        var leftMoved = 0;
                        var topMoved = 1;
                        var leftChanged = 1;
                        var $elsCheck = $editorWrapper.closest( '.swc_text' ).find( '.swc_asset' ).add( '.swc_asset_any_icon_wrapper' ).not( $iconWrapper ).not( '.swc_nopluscollision' ).not( '.swc_asset_p_plus_icon_wrapper' );

                        var posTextAsset = getElPos( $editorWrapper.closest( '.swc_text' ) );

                        // Position the + icon. Make sure it does not overlap.

                        while( leftChanged > 0 || topMoved > 0 ) {
                            leftChanged = 0;

                            $iconWrapper.position( {
                                my: 'right center',
                                at: 'right-' + left + ' center' + ( top >= 0 ? '+' + top : top ),
                                of: $editorWrapper,
                                collision: 'none'
                            } );

                            var posHandler = getElPos( $iconWrapper );

                            // Try to fit the + icon inside the text asset (not overlapping it's top or bottom border).
                            if( topMoved === 1 ) {
                                topMoved = 0;
                                if( posHandler.y < posTextAsset.y ) {
                                    top = posTextAsset.y - posHandler.y;
                                    topMoved = 2;
                                } else if( posHandler.y + posHandler.h > posTextAsset.y + posTextAsset.h ) {
                                    top = ( posTextAsset.y + posTextAsset.h ) - ( posHandler.y + posHandler.h );
                                    topMoved = 2;
                                }
                            } else {
                                topMoved = 0;
                            }

                            // Make sure + icons does not overlap with other icons and assets.
                            $elsCheck.each( function( ii, el ) {
                                var $el = $( el );
                                var pos = getElPos( $el );

                                if( posHandler.x < pos.x + pos.w && posHandler.x + posHandler.w > pos.x ) {
                                    if( posHandler.y < pos.y + pos.h && posHandler.y + posHandler.h > pos.y ) {
                                        if( posHandler.x + posHandler.w - pos.x - left > 0 ) {
                                            left += posHandler.x + posHandler.w - pos.x - left;
                                        }
                                        left ++;
                                        leftMoved = 1;
                                        if( left < $editorWrapper.width() - 32 ) {
                                            leftChanged = 1;
                                        }
                                    }
                                }
                            } );

                            if( leftChanged == 0 && leftMoved > 0 ) {
                                left += 2;
                                leftMoved = 0;
                                leftChanged = 1;
                            }
                        }
                    }
                }
            } );
            $( '.swc_page_cntnt.cke_editable' ).on( 'mouseleave', pSelector, function( ev ) {
                $( ev.currentTarget ).find( '.swc_asset_p_plus_icon_wrapper' ).addClass( 'swc_will_remove' );
                setTimeout( function() {
                    $( ev.currentTarget ).find( '.swc_will_remove' ).remove();
                }, 200 );
            } );

            pTagEventsAdded = 1;
        }

        var $wrapper = $( self.wrapper.$ );

        // When the mouse enters an column the plus icon is shown on top of the column

        $wrapper.on( 'mouseenter', function( el/*, ev*/ ) {
            //// do not show the plus icon when the edit icon is hidden, this solves a difficulty that
            //// we should not create a extra asset instance for storing the resized width while the edit
            //// panel is open
            if( $dragHandlerContainer.hasClass( 'swc_hide_asset_icon' ) ) {
                return;
            }

            var $editorWrapper = $( el.currentTarget );
            var $assetWrapper = $editorWrapper.find( 'div.swc_grid_column' );
            if( $assetWrapper.length <= 0 ) {
                // Find the closest parent column, if exists.
                $assetWrapper = $editorWrapper.closest( '.swc_grid_column' );
            }
            var $assetWrapperColumn = $assetWrapper;
            $assetWrapper = $assetWrapper.closest( '.swc_grid_row' ).parent();
            if( $assetWrapper.length !== 1 ) {
                return;
            }

            // Add the plus icon to the column.
            var appended = 0;
            if( ! $assetWrapper.find( '.swc_asset_plus_icon_wrapper' ).length ) {
                $assetWrapper.append( getPlusIconHtml( 'swc_asset_plus_icon_wrapper' ) );
                appended = 1;
            }

            var $iconWrapper = $assetWrapper.find( '.swc_asset_plus_icon_wrapper' );
            var $icon = $iconWrapper.find( '.fa' );

            var $row = $assetWrapperColumn.closest( '.swc_grid_row' );
            var bottom = 0;
            if( parseInt( $row.css( 'padding-bottom' ), 10 ) > 0 ) {
                bottom -= parseInt( $row.css( 'padding-bottom' ), 10 );
            }

            var left = $assetWrapperColumn.width() / 2;
            left += $assetWrapperColumn.offset().left - $row.offset().left;

            $iconWrapper.position( {
                my: 'center center',
                at: 'left+' + left + ' bottom+' + bottom,
                of: $row,
                collision: 'none'
            } );

            $icon.data( 'column', $assetWrapperColumn );

            if( appended == 1 ) {
                $icon.on( 'click', function( /*ev*/ ) {
                    var $column = $( this ).data( 'column' );

                    var $rowWrapper = $column.closest( 'div.swc_grid_row' ).first();
                    var locked = $rowWrapper.hasClass( 'swc_locked' );

                    //evt( 'reset_panel_stack', { 'left': true } );
                    evt( 'add_content_panel', { 'in_grid': true, '$column': $column, 'locked': locked } );
                } );
            }

            // Remove plus icon when leaving the asset

            $assetWrapper.on( 'mouseleave', function( /* el, ev*/ ) {
                $wrapper.find( '> .swc_asset_plus_icon_wrapper' ).addClass( 'swc_will_remove' );
                setTimeout( function() {
                    $wrapper.find( '.swc_will_remove' ).remove();
                }, 1000 );
            } );
        } );
    };

    function getElPos( $el ) {
        var pos = {};

        var offset = $el.offset();
        pos.x = offset.left;
        pos.y = offset.top;
        pos.w = $el.outerWidth( false );
        pos.h = $el.outerHeight( false );

        return pos;
    }

    function getPlusIconHtml( cls ) {
        return '<span ' +
        'class="' + cls + ' swc_asset_any_icon_wrapper cke_reset cke_widget_drag_handler_container" ' +
        'contenteditable="false" ' +
        'title="' + __( 'Click to add content' ) + '" ' +
        '>' +
        '<i class="fa fa-plus" contenteditable="false"></i>' +
        '</span>';
    }
} );

swifty.define( 'js/components/editor_ckeditor/ckeditor_helpers/ckeditor_helper_move_asset',[
    'jquery'
], function(
    $
) {
    

    return function( opts ) {
        if( !opts ) {
            return;
        }

        var curWidgetObj = this.getWidget( this.getWidgetIdAssetBased( opts.$asset ) );
        var curWidget = curWidgetObj.wrapper;
        var curTable = this.getTableOrRowOrCell( curWidget, 'table' );
        var items, nrOfItems, curPos, newPos, curCell, nrOfColumns;
        var curGridColumn = this.getGridRowOrColumn( curWidget, 'swc_grid_column' );
        var nearestTableOrGrid = this.getTableOrGrid( curWidget );
        var isMoveHandled = false;

        if( curWidget && opts.move ) {
            switch( opts.move ) {
                case 'up':
                case 'down':
                    if( curTable ) {   // Asset inside a table
                        curWidget[ opts.move === 'up' ? 'insertBefore' : 'insertAfter' ]( curTable );
                    } else {
                        var textAsset = this.getAscendantTextAsset( curWidget );
                        var nodeList = null;

                        if( textAsset ) {   // Widget is inside a text asset.
                            nodeList = this.getRootElements( textAsset );
                        } else {   // Widget is inside a column.
                            nodeList = this.getRootElements( curGridColumn );
                        }

                        var gridRows = this.getGridRows();
                        var curGridRow = this.getGridRowOrColumn( curWidget, 'swc_grid_row' );   // The current row
                        var nrOfRows = gridRows.count();
                        var curRowPos = this.getCurPos( curGridRow, gridRows );

                        items = this.getParagraphAndWidgetElements();   // NodeList of P and widget elements.
                        nrOfItems = nodeList.count();

                        if( nrOfItems > 0 ) {   // One or more first level elements
                            curPos = this.getCurPos( curWidget, nodeList );

                            if( ( opts.move === 'up' && curPos > 0 ) ||
                                ( opts.move === 'down' && curPos < nrOfItems - 1 )
                            ) {
                                newPos = this.getNewPos( opts.move, curPos );
                                var newNode = nodeList.getItem( newPos );

                                // Text assets can't move inside text assets. Here the newNode is the text asset
                                // including the widget wrapper.
                                if( this.isTextAsset( newNode ) && ! this.isTextAsset( curWidget ) ) {
                                    var textNodes = this.getRootElements( newNode );
                                    var nrOfNodes = textNodes.count();

                                    if( opts.move === 'up' ) {
                                        curWidget.insertAfter( textNodes.getItem( nrOfNodes - 1 ) );
                                    } else {
                                        curWidget.insertBefore( textNodes.getItem( 0 ) );
                                    }
                                } else {
                                    curWidget[ opts.move === 'up' ? 'insertBefore' : 'insertAfter' ]( newNode );
                                }
                            } else if(  // Widget is the first or last item.
                                ( opts.move === 'up' && curPos === 0 ) ||
                                ( opts.move === 'down' && curPos === nrOfItems - 1 )
                            ) {
                                if( textAsset ) {
                                    // Text asset without the widget wrapper, so we need to get the parent.
                                    curWidget[ opts.move === 'up' ? 'insertBefore' : 'insertAfter' ]( textAsset.getParent() );
                                } else {   // Check if the widget can be moved to another row.
                                    var newRowIndex = null;

                                    // Widget is not in the first row and can be moved to the row above the current row.
                                    if( opts.move === 'up' && curRowPos > 0 ) {
                                        newRowIndex = curRowPos - 1;
                                    }

                                    // Widget is not in the last row and can be moved to the row below the current row.
                                    if( opts.move === 'down' && curRowPos < nrOfRows - 1 ) {
                                        newRowIndex = curRowPos + 1;
                                    }

                                    // Widget can be moved to another row.
                                    if( newRowIndex !== null ) {
                                        var newRow = gridRows.getItem( newRowIndex );
                                        var gridColumns = this.getGridColumnsFromRow( newRow );
                                        
                                        nrOfColumns = gridColumns.count();

                                        // When move is up, we insert into the last column, otherwise the first column.
                                        var newColumn = gridColumns.getItem(
                                            opts.move === 'up' ? nrOfColumns - 1 : 0
                                        );

                                        if( newColumn ) {
                                            // Widget is added as last element in the column when moving up.
                                            if( opts.move === 'up' ) {
                                                curWidget.appendTo( newColumn );
                                            } else {   // Widget is added as first element in the column when moving down.
                                                var firstNode = newColumn.getFirst();

                                                if( firstNode ) {
                                                    curWidget.insertBefore( firstNode );
                                                } else {
                                                    curWidget.appendTo( newColumn );
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    break;
                case 'left':
                case 'right':
                    if( curTable && ( curTable.equals( nearestTableOrGrid ) ) ) {   // Asset inside a table
                        curWidget[ opts.move === 'left' ? 'insertBefore' : 'insertAfter' ]( curTable );

                        isMoveHandled = true;
                    } else if( curGridColumn && ( curGridColumn.equals( nearestTableOrGrid ) ) ) {
                        // asset lives in grid, we are moving to another column
                        var curRow = this.getGridRowOrColumn( curWidget, 'swc_grid_row' );   // The current row
                        var columns = curRow.find( 'div.swc_grid_column' );   // Is a nodeList of columns in row
                        
                        nrOfColumns = columns.count();

                        curCell = this.getGridRowOrColumn( curWidget, 'swc_grid_column' );
                        curPos = this.getCurPos( curCell, columns );

                        if( nrOfColumns > 1 ) {   // More than 1 grid column
                            if( ( opts.move === 'left' && curPos > 0 ) ||
                                ( opts.move === 'right' && curPos < nrOfColumns - 1 )
                            ) {
                                this.moveToNewColum(
                                    opts.move,
                                    curWidget,
                                    this.getNewPos( opts.move, curPos ),
                                    columns
                                );
                            }
                        }
                        isMoveHandled = true;
                    }

                    if( ! isMoveHandled ) {   // Asset inside a paragraph
                        items = this.getParagraphAndWidgetElements();   // NodeList of P and widget elements.
                        nrOfItems = items.count();
                        curPos = this.getCurPos( curWidget, items );

                        var floating = curWidget.getFirst().getComputedStyle( 'float' );

                        if( opts.move === 'left' ) {
                            if( this.isWidgetElement( items.getItem( curPos - 1 ) ) ) {
                                if( floating === 'right' ) {
                                    this.triggerSetPositionEvent( curWidget.getChild( 0 ).$, opts.move );
                                } else {
                                    curWidget.insertBefore( items.getItem( curPos - 1 ) );
                                }
                            } else {
                                this.triggerSetPositionEvent( curWidget.getChild( 0 ).$, opts.move );
                            }
                        }

                        if( opts.move === 'right' ) {
                            if( this.isWidgetElement( items.getItem( curPos + 1 ) ) ) {
                                curWidget.insertAfter( items.getItem( curPos + 1 ) );
                            } else {
                                this.triggerSetPositionEvent( curWidget.getChild( 0 ).$, opts.move );
                            }
                        }
                    }

                    break;
                default:
                    return;
            }
            curWidget.scrollIntoView();

            this.contentModfied();
        }
    }

} );
swifty.define( 'js/components/editor_ckeditor/ckeditor_helpers/ckeditor_helper_instance_ready_handler',[
    'jquery',
    'swiftylib/evt'
], function(
    $, evt
) {
    

    return function( ev ) {
        var self = this;
        var editor = ev.editor;
        var commands = editor.commands;

        self.$toolbar = $( '#cke_' + self.instance.name ).children( '.cke_inner' );

        self.$toolbar.find( '.cke_toolbar' )
            .eq( 1 )
            .css( 'width', '100%' )
            .find( 'a:last' )
            .css( 'float', 'right' );

        if( self.sticky_editor ) {
            commands.hideEditor && commands.hideEditor.enable();
        } else {
            commands.hideEditor && commands.hideEditor.disable();

            self.toggleToolbarVisibility( false );
        }

        // some changes for the generated html
        editor.dataProcessor.writer.lineBreakChars = '\n';

        var noIndentsNoBreaks = {
            indent: false,
            breakBeforeOpen: false,
            breakAfterOpen: false,
            breakBeforeClose: false,
            breakAfterClose: false
        };

        $.each( CKEDITOR.dtd, function ( index ) {
            editor.dataProcessor.writer.setRules( index, noIndentsNoBreaks );
        } );

        // go to the last position in the editor (and make sure the focus is working as expected)
        var range = editor.createRange();
        range.moveToElementEditEnd( range.root );
        editor.getSelection().selectRanges( [ range ] );

        editor.on( 'blur', self.onBlurHandler, self );

        var html = editor.getData();

        evt(
            'swifty_editor_before_init',
            {
                'content': html
            }
        );

        // Hide empty div's in contact forms which are used to do a clear: both; CKeditor is adding br tags to them
        // which result in 4 extra empty lines in the form
        var $forms = $('.swc_asset_swifty_contact_form > .swc_asset_cntnt' );
        $.each( $forms, function( i, formcontent ) {
            $( formcontent ) .find( 'div:not([id]):has(br) br' ).hide();
        } );

        // we need to know when the paste was used for cutting
        editor.editable().on( 'cut', function( evt ) {
            self.lastCopyPaste = 'cut';
        } );

        // we need to know when the past was used for copying
        editor.editable().on( 'copy', function( evt ) {
            self.lastCopyPaste = 'copy';
        } );

        if ( editor.contextMenu ) {
            editor.contextMenu.addListener( function( /*element, selection, path*/ ) {
                editor.contextMenu.items = $.grep( editor.contextMenu.items, function ( item /*, i*/ ) {
                    return ( item.name !== 'editdiv' && item.name !== 'removediv' );
                } );
            } );
        }

        // show tooltip when empty html or when there is a text asset without any text and when there is no asset on the 
        // page
        var $assets = editor.editable().find( '.swc_asset' );
        if( ( $assets.$.length === 0 ) &&
            ( ( $.trim( html ) === '' ) ||
              ( ( $.trim( $( editor.container.$ ).text() ) === '' ) &&  ( /swifty_text/.test(html)  ) ) )
            ) {
            evt( 'show_page_setup' );
        }

        evt( 'show_main_menu' );
    };

} );
swifty.define( 'js/components/editor_ckeditor/ckeditor_helpers/ckeditor_helper_setup_insert',[
    'jquery',
    'can',
    'swiftylib/evt'
], function(
    $, can, evt
) {
    

    return function() {
        var self = this;

        // Replace widget with html code
        // opts.html html code of new widget
        // opts.$element node of widget wrapper
        // after replacement swifty_checkImages will be run.
        can.bind.call( window, 'evt_swc_replace_asset', function( ev, opts, dfd ) {

            if(opts && opts.html && opts.$element ) {

                // select widget that will be replaced
                self.instance.getSelection().selectElement( new CKEDITOR.dom.node( opts.$element[0] ) );

                evt( 'add_asset_to_content', {
                    'html': opts.html,
                    'widget_class': opts.widget_class,
                    'insert_class': null,
                    'inline': false,
                    'takeSnapshot': true,
                    'only_insert_at_root': false,
                    'force_html_insert': false
                } ).then( function() {

                    // remove original widget
                    opts.$element.remove();

                    evt( 'add_exec', { 'fn': 'swifty_check_inserts' } );
                    setTimeout( function() {
                        evt( 'add_exec', { 'fn': 'swifty_check_inserts' } );
                    }, 1000 );
                    dfd.resolve();
                } );
            }
        } );

        can.bind.call( window, 'evt_swc_add_asset_to_content', function( ev, opts, dfd ) {
            var $newEl;

            self.destroySingle( 'tooltip' );

            self.swifty_insert_content = true;

            try {
                if( opts.takeSnapshot ) {
                    self.lastUndoImage = null;
                    self.undoImageStack = null;

                    self.instance.fire( 'saveSnapshot' );

                    if( self.instance && self.instance.undoManager ) {
                        // This should work, but returns null.
                        //self.lastUndoImage = self.instance.undoManager.getNextImage( false );
                        // Instead grab the 'image' from the snapshots stack directly.
                        if( self.instance.undoManager.snapshots.length ) {
                            self.lastUndoImage = self.instance.undoManager.snapshots[self.instance.undoManager.snapshots.length - 1]
                        }
                        // We do a few tricks here with the snapshot stack because we could not find a better way.
                        self.undoImageStack = $.extend( true, [], self.instance.undoManager.snapshots );
                    }

                    self.instance.fire( 'lockSnapshot', { dontUpdate: true } );
                }

                if( opts.$column ) {
                    // Remove empty p tags from column, there should be only asset divs here, p tag with text will be replaced
                    // with text asset on next render
                    $( opts.$column ).children( 'p' ).each( function() {
                        var $this = $( this );
                        if( $this.html().replace( /\s|&nbsp;|<br>/g, '' ).length === 0 ) {
                            $this.remove();
                        }
                    } );

                    self.appendHtmlToColumn( opts.$column, opts.html );
                } else {
                    if( ! opts.inline ) {
                        if( opts.is_preset ) {
                            var presetNode = self.appendHtmlToSelector( opts.html );

                            $newEl = $( presetNode.$ );

                            setTimeout( function() {
                                $newEl.find( '.swc_grid_row' ).addClass( 'swc_glowing' );

                                setTimeout( function() {
                                    $newEl.find( '.swc_grid_row' ).removeClass( 'swc_glowing' );
                                }, 3000 );
                            }, 1 );
                        } else {
                            var selectedEl = self.setAssetInsertPosition( opts.only_insert_at_root, opts.force_html_insert );
                            if( selectedEl ) {
                                // this does almost the same as insertHtml, but allows us to insert just before a node
                                // without the range problems
                                var widgetnode = CKEDITOR.dom.element.createFromHtml( opts.html );
                                widgetnode.insertBefore( selectedEl );
                                self.instance.widgets.initOn( widgetnode, opts.widget_class );
                            } else {
                                self.instance.insertHtml( opts.html );
                            }
                        }
                    } else {
                        self.instance.insertHtml( opts.html );
                    }
                }

                if( opts.insert_class ) {
                    var $el = $( 'body' ).find( '.' + opts.insert_class );

                    setTimeout( function() {
                        if( $el.hasClass( 'swc_asset' ) ) {
                            $el.addClass( 'swc_glowing' );
                            setTimeout( function() {
                                $el.removeClass( 'swc_glowing' );
                            }, 4000 );
                        }
                    }, 1 );

                    if( ! opts.inline ) {
                        var $td = $el.closest( 'td' );
                        var contentEl = self.getContentElement();

                        // Asset is inserted inside a table cell within the content element
                        if( $td && $td.length && $( contentEl.$ ).find( $td ).length ) {
                            var $widgetEl = $el.parent();
                            // Get child elements in table cell ( exclude the widget element )
                            var $tdChildren = $td.children().not( $widgetEl );

                            // No child elements exist AND no text inside the table cell
                            if( $tdChildren && ! $tdChildren.length && $td.text() === '' ) {
                                $widgetEl.after( '&#8203;' );   // Adds a zero-width space after the widget element
                            }
                        }
                    }
                    if( ! $el.hasClass( 'swc_text' ) ) {
                        evt(
                            'swifty_editor_asset_inserted',
                            {
                                'el': $el
                            }
                        );

                    }

                    $el.removeClass( '.' + opts.insert_class ).addClass( 'swc_asset_state_ins_updating' );
                    if( $el.hasClass( 'swc_text' ) ) {
                        // This timout is needed because the slide down effect of the previous panel (.swc_panel_animate_out)
                        // takes 400 ms (done in css - transition) to complete. After that the Text edit panel will slide up.
                        setTimeout( function() {
                            self.openEditAfterInsert( $el, opts.inline, true );
                        }, 500 );
                    }
                    self.setCursor( { '$asset': $el } );

                    $newEl = $el;
                }

                if( opts.takeSnapshot ) {
                    self.instance.fire( 'unlockSnapshot' );
                    self.instance.fire( 'saveSnapshot' );
                }

                setTimeout( function() {
                    dfd.resolve( $newEl );
                }, 100 );
            } finally {
                self.swifty_insert_content = false;
            }
        } );

        can.bind.call( window, 'evt_swc_add_row_to_content', function( ev, opts, dfd ) {

            self.destroySingle( 'tooltip' );

            var $row = null;

            self.swifty_insert_content = true;
            try {
                self.appendHtmlToSelector( opts.html );

                $row = $( 'body' ).find( '.' + opts.insert_class );

                setTimeout( function() {
                    $row.find( '.swc_grid_colwrapper' ).addClass( 'swc_glowing' );
                    setTimeout( function() {
                        $row.find( '.swc_grid_colwrapper' ).removeClass( 'swc_glowing' );
                    }, 3000 );
                }, 1 );

                $row.removeClass( '.' + opts.insert_class );
            } finally {
                self.swifty_insert_content = false;
            }
            dfd.resolve( $row );
        } );

        // Insert a new column in a row
        can.bind.call( window, 'evt_swc_add_columns_to_row', function( ev, opts, dfd ) {
            // Find the right row
            $.each( self.instance.widgets.instances, function( ii, instance ) {
                if( $( instance.element.$ ).is( opts.$row ) ) {
                    // Insert the column and make sure CKeditor initializes it as a widget
                    instance.element.appendHtml( opts.html );
                    $( instance.element.$ ).children( 'p' ).remove();
                    var count = instance.element.getChildCount();
                    for( var i = 0; i < count; i++ ) {
                        var column = instance.element.getChild( i ).findOne( '.swc_grid_column' );
                        if( column ) {
                            self.instance.widgets.initOn( column, 'swc_grid_column' );
                        }
                    }
                    dfd.resolve();
                }
            } );
        } );

        // Make sure all widgets like rows and columns are correct in CKeditor.
        // Is for instance used when a column is removed from the dom via jQuery.
        can.bind.call( window, 'evt_swc_swifty_editor_check_widgets', function( ev, opts, dfd ) {
            self.instance.widgets.checkWidgets();
            dfd.resolve();
        } );

        // is the current insertion location in a grid or table?
        can.bind.call( window, 'evt_swc_is_current_insert_position_in_table_or_grid', function( ev, opts, dfd ) {
            dfd.resolve( self.isCurrentInsertPositionInTableOrGrid() );
        } );

        // Helper for probe
        can.bind.call( window, 'evt_swc_probe_simulate', function( ev, opts ) {
            $( ( '.cke_editable:first' ) ).focus().simulate( opts.cmd, opts.data );

            self.instance.fire( 'change' );
        } );
        can.bind.call( window, 'evt_swc_probe_ck_bold', function( /*ev, opts*/ ) {
            self.instance.execCommand( 'bold' );

            self.instance.fire( 'change' );
        } );
        //can.bind.call( window, 'evt_swc_probe_ck_remove_prev_char', function( /*ev, opts*/ ) {
        //    var range = self.instance.createRange();
        //    //range.moveToElementEditEnd( self.getContentElement().find( 'p' ).getItem( 0 ) );
        //    range.moveToElementEditStart( self.getContentElement().find( 'h2' ).getItem( 0 ) );
        //    //range.moveToElementEditablePosition( self.getContentElement().find( 'h2' ).getItem( 0 ), false );
        //    self.instance.getSelection().selectRanges( [ range ] );
        //    //range.select();
        //
        //    var startNode = self.getContentElement().find( 'p' ).getItem( 0 );
        //
        //    //var txt = startNode.getText();
        //    var txt = startNode.getHtml();
        //    //txt = txt.substr( 0, txt.length - 2 );
        //    txt = txt.replace( 'Q', '' );
        //    startNode.setHtml( txt );
        //
        //    //range.select();
        //    //range.selectNodeContents( startNode );
        //    //range.deleteContents();
        //    //self.instance.insertHtml( txt );
        //
        //    self.instance.fire( 'change' );
        //} );
        can.bind.call( window, 'evt_swc_probe_ck_select_first_el', function( ev, opts ) {
            // var focusManager = new CKEDITOR.focusManager( self.instance );
            // focusManager.focus();
            self.instance.focus();

            // Find the first text node that can be edited and is not empty.

            self.instance.execCommand( 'selectAll' );
            var range = self.instance.getSelection().getRanges()[ 0 ];
            var walker = new CKEDITOR.dom.walker( range );
            var node;
            var nodeWithContent = null;
            while ( ( node = walker.next() ) ) {
                if( ! node.isReadOnly() ) {
                    var tag = $( node.$ ).prop( 'tagName' );
                    if( tag ) {
                        tag = tag.toLowerCase();
                        if( tag === 'p' || tag === 'h1' || tag === 'h2' || tag === 'h3' || tag === 'h4' || tag === 'h5' || tag === 'h6' ) {
                            if( ! nodeWithContent && $( node.$ ).text().length > 0 ) {
                                nodeWithContent = node;
                            }
                        }
                    }
                }
            }

            range = self.instance.createRange();
            range.moveToElementEditStart( nodeWithContent );
            range.selectNodeContents( nodeWithContent );
            self.instance.getSelection().selectRanges( [ range ] );

            self.instance.fire( 'change' );
         } );
    };

} );
swifty.define( 'js/components/editor_ckeditor/ckeditor_helpers/ckeditor_helper_setup_asset_widget',[
    'jquery',
    'can',
    'swiftylib/evt'
], function(
    $, can, evt
) {
    

    return function() {
        var self = this;
        var instance = self.instance;

        // Insert new asset html (received from server) into the editor (replacing existing widget content)
        can.bind.call( window, 'evt_swc_new_asset_content_received', function( ev, opts ) {
            $.each( instance.widgets.instances, function( ii, widget ) {
                if( $( widget.element.$ ).is( $( opts.container ) ) ) {
                    // Replace the whole content (inner) wrapper by the new content
                    widget.element.setHtml( opts.html );

                    // If a newer version is still being fetched from the server, re-add the refresh spinner.
                    if( parseInt( opts.refreshnr, 10 ) < parseInt( $( opts.container ).attr( 'data-swc_refreshnr' ), 10 ) ) {
                        self.addRefreshSpinner( opts );
                    }

                    // Set the new style tag to the outer wrapper (the out wrapper is not replaced upon new content)
                    $( widget.element.$ ).attr( 'style', opts.style );

                    // Set the new css classes to the outer wrapper (without removing the existing classes, which might by added by CKEditor) (the out wrapper is not replaced upon new content)
                    var classes = opts.classes.split( ' ' );
                    $.each( classes, function( ii, cls ) {
                        $( widget.element.$ ).addClass( cls );
                    } );

                    //editor.fire( 'change' );
                    instance.fire( 'saveSnapshot' ); // Create undo point and trigger change (autosave)

                    self.openEditAfterInsert( widget.element.$, widget.inline );
                }
            } );
        } );

        // Show spinner while refreshing asset from server
        can.bind.call( window, 'evt_swc_asset_reload_from_server_queued', function( ev, opts ) {
            self.addRefreshSpinner( opts );
            $( opts.container ).attr( 'data-swc_refreshnr', opts.refreshnr );
        } );
    }

} );
swifty.define( 'js/components/editor_ckeditor/ckeditor_helpers/ckeditor_helper_seperate',[
    'jquery',
    './ckeditor_helper_setup_event_handlers',
    './ckeditor_helper_cogs',
    './ckeditor_helper_resizeicon',
    './ckeditor_helper_cogicon',
    './ckeditor_helper_plusicon',
    './ckeditor_helper_move_asset',
    './ckeditor_helper_instance_ready_handler',
    './ckeditor_helper_setup_insert',
    './ckeditor_helper_setup_asset_widget'
], function(
    $, setupEventHandlers, cogsIconFunctionality, resizeIconFunctionality, cogIconFunctionality, plusIconFunctionality,
    moveAssetFunctionality, onInstanceReadyHandler, setupInsert, setupAssetWidget
) {
    

    return function( comp ) {
        comp.setupEventHandlers=setupEventHandlers;
        comp.addCogsIconFunctionality = cogsIconFunctionality;
        comp.addResizeIconFunctionality = resizeIconFunctionality;
        comp.addCogIconFunctionality = cogIconFunctionality;
        comp.addPlusIconFunctionality = plusIconFunctionality;
        comp.moveAsset = moveAssetFunctionality;
        comp.onInstanceReadyHandler = onInstanceReadyHandler;
        comp.setupInsert = setupInsert;
        comp.setupAssetWidget = setupAssetWidget;
    }

} );
swifty.define( 'js/components/editor_ckeditor/ckeditor_helpers/ckeditor_helper_mouse',[
    'jquery'
], function(
    $
) {
    

    return function() {

        // mousecapture, see http://benanne.net/misc/jquery-plugins/mousecapture/demo.html
        // captures the mouse after mousedown until mouseup

        $.fn.mousecapture = function(params) {
            var $doc = $( document );

            this.each( function() {
                var $this = $( this );
                var sharedData = {};

                $this.mousedown( function( e ) {
                    // mousemove
                    var moveHandler;

                    if( params.move ) {
                        moveHandler = function( e ) {
                            params.move.call( $this, e, sharedData );
                        };

                        $doc.mousemove( moveHandler );
                    }

                    // mouseup
                    var upHandler;

                    var unbind = function() {
                        if( params.move ) {
                            $doc.unbind( 'mousemove', moveHandler );
                        }

                        $doc.unbind( 'mouseup', upHandler );
                    };

                    if( params.up ) {
                        upHandler = function( e ) {
                            unbind();
                            return params.up.call( $this, e, sharedData );
                        };
                    } else {
                        upHandler = unbind;
                    }

                    $doc.mouseup( upHandler );

                    // mousedown
                    return params.down.call( $this, e, sharedData );
                } );
            } );

            return this;
        };

    }

} );
swifty.define( 'js/components/editor_ckeditor/ckeditor_helpers/ckeditor_helper_asset',[
    'jquery',
    'swiftylib/i18n/__',
    'js/diverse/utils',
    'swiftylib/evt',
    './ckeditor_helper_mouse'
], function(
    $, __, Utils, evt, mouseFunctionality
) {
    

    return function( component ) {

        mouseFunctionality();

        // Plugin is registered on global CKEDITOR (needs to be done only once).
        // It stays registered, even when the editor instance is destroyed.
        if( !CKEDITOR.plugins.registered.swc_asset ) {
            CKEDITOR.plugins.add( 'swc_asset', {
                requires: 'widget',

                init: function( editor ) {
                    // Placement over icon that shows when you hover over a widget
                    CKEDITOR.plugins.widget.prototype.updateDragHandlerPosition = CKEDITOR.tools.override(
                        CKEDITOR.plugins.widget.prototype.updateDragHandlerPosition, function( /*original*/ ) {
                            return function() {
                                // Below is copied (and adapted) code from CKEditor original source, and slightly changed
                                var editor = this.editor,
                                    domElement = this.element.$,
                                    isGridElement = $( domElement ).attr( 'data-widget' ) === 'swc_grid_row',
                                    oldPos = this._.dragHandlerOffset,
                                    newPos;

                                // image widgets are inline, and the container uses a span instead of div
                                if( domElement.parentElement && domElement.parentElement.nodeName === 'SPAN') {
                                    domElement = domElement.parentElement;
                                    newPos = {
                                        x: 0 + domElement.offsetWidth - 32,
                                        y: 0 - ( isGridElement ? 32 : 0 )
                                    };
                                } else {
                                    newPos = {
                                        x: domElement.offsetLeft + domElement.offsetWidth - 32,
                                        y: domElement.offsetTop - ( isGridElement ? 32 : 0 )
                                    };
                                }
                                newPos.x = newPos.x - 1;

                                if( oldPos && newPos.x === oldPos.x && newPos.y === oldPos.y ) {
                                    return;
                                }

                                // We need to make sure that dirty state is not changed (#11487).
                                var initialDirty = editor.checkDirty();

                                editor.fire( 'lockSnapshot' );
                                this.dragHandlerContainer.setStyles( {
                                    top: newPos.y + 'px',
                                    left: newPos.x + 'px',
                                    display: 'block'
                                } );
                                editor.fire( 'unlockSnapshot' );
                                !initialDirty && editor.resetDirty();

                                this._.dragHandlerOffset = newPos;
                                // End of copied code

                                // original.call( this ); // No need to call the original code, as it's included above.
                            };
                        }
                    );

                    editor.widgets.add( 'swc_asset', {
                        //editables: {
                        //    title: {
                        //        selector: '.su-box-title',
                        //        allowedContent: 'br strong em'
                        //    },
                        //    content: {
                        //        selector: '.su-box-content',
                        //        allowedContent: 'p br ul ol li strong em'
                        //    }
                        //},

                        //allowedContent:
                        //    //'div(!swc_asset); div(!swc_asset_cntnt); div(!su-box); div(!su-box-title); div(!su-box-content)',
                        //    'div[*]',

                        //requiredContent: 'div(swc_asset)',

                        upcast: function( element ) {
                            return ( element.name === 'div' || element.name === 'span' ) && element.hasClass( 'swc_asset' );
                        },

                        downcast: function( element ) {
                            var isBlock = element.name.toLowerCase() === 'div';
                            var elName = isBlock ? 'swifty_block_replacer' : 'swifty_inline_replacer';
                            var newElement = new CKEDITOR.htmlParser.element( elName );
                            var firstChild = element.getFirst();

                            if( firstChild ) {
                                var html = '';
                                var attrs = firstChild.attributes;

                                if( attrs && attrs['data-asset_data'] ) {
                                    attrs = $.parseJSON( Utils.atou( attrs['data-asset_data'] ) );

                                    $.each( attrs, function( key, val ) {
                                        if( key !== 'swc_shortcode' && key !== 'content' && key !== 'swc_shortcode_status' ) {
                                            if( parseFloat( key ) === key >>> 0 ) {  // Is this a integer?
                                                html += ' ' + val;
                                            } else {
                                                // Trick to prevent enters messing up shortcode data.
                                                if( typeof val === 'string' ) {
                                                    val = val.replace( /\n/g, '_=EnTEr=-' );
                                                }

                                                html += ' ' + key + '=_=QUoTe=-' + val + '_=QUoTe=-';
                                            }
                                        }
                                    } );

                                    html = '[' + attrs.swc_shortcode + html + ']';

                                    if( attrs.content ) {
                                        attrs.content = attrs.content.replace( /\n/g, '_=EnTEr=-' );
                                        html += '<!--keep_swifty_content_start-->' + attrs.content + '<!--keep_swifty_content_end-->';
                                    }

                                    var force_close_tag = component.forceShortcodeCloseTags[ attrs.swc_shortcode ] ? component.forceShortcodeCloseTags[ attrs.swc_shortcode ] : false;

                                    if( attrs.content || force_close_tag ) {
                                        html += '[/' + attrs.swc_shortcode + ']';
                                    }

                                    newElement.setHtml( html );
                                }
                            }

                            return newElement;
                        },

                        init: function() {
                            var self = this;
                            var wrapper = self.wrapper;
                            var $dragHandlerContainer = $( wrapper.$ ).find( '> .cke_widget_drag_handler_container' );
                            var $dragHandlerImage = $dragHandlerContainer.find( 'img' );
                            var ckDragHandlerImage = wrapper.find( '> .cke_widget_drag_handler_container img' ).getItem( 0 );

                            $( wrapper.$ ).css( 'clear', $( wrapper.$ ).find( '> .swc_asset' ).css( 'clear' ) );

                            var $assetWrapper = $( wrapper.$ ).find( 'div.swc_asset' ).first();
                            var locked = $assetWrapper.hasClass( 'swc_locked' );
                            if( ! locked || scc_data.swifty_edit_locked ) {
                                component.addResizeIconFunctionality( self, ckDragHandlerImage, $dragHandlerImage, $dragHandlerContainer );
                                component.addCogIconFunctionality( self, ckDragHandlerImage, $dragHandlerImage, $dragHandlerContainer, 'asset', false );
                                component.addPlusIconFunctionality( self, $dragHandlerContainer );
                            } else {
                                component.addCogIconFunctionality( self, ckDragHandlerImage, $dragHandlerImage, $dragHandlerContainer, 'asset', true );
                            }
                            // Add our own asset icon to the CK drag handle.
                            $dragHandlerContainer.prepend( '<i class="fa fa-cog" style="padding-left: 3px;"></i>' );
                            // Hide the CK drag handle.
                            $dragHandlerContainer.addClass( 'cke_widget_drag_handler_container_swc_hidden' );

                            // // Open the asset panel when the CK drag handle is clicked
                            //
                            // $dragHandlerImage.on( 'click', function( /*ev*/ ) {
                            //     var $el = $( this ).closest( '.cke_widget_wrapper' ).find( '.swc_asset_cntnt' );
                            //
                            //     if( $( this ).hasClass( 'swc_hide_asset_icon' ) ) {
                            //         return false;
                            //     }
                            //
                            //     // hide resizer when opening panel
                            //     $( '.swc_asset_resizer_icon_wrapper' ).remove();
                            //     $( '.swc_asset_cog_icon_wrapper, .swc_asset_any_icon_wrapper, .swc_asset_adv_icons_wrapper' ).remove();
                            //
                            //     // Open the asset panel
                            //     evt(
                            //         'swifty_editor_asset_dialog',
                            //         {
                            //             'el': $el,
                            //             'mod': 'icon_clicked',
                            //             'inline': self.inline,
                            //             'init_css': false
                            //         }
                            //     );
                            // } );

                            //component.addCogsIconFunctionality( self, ckDragHandlerImage, $dragHandlerImage, 1 );

                            // prevent delete and backspace
                            component.setupWidgetKeyDeletion( self );
                        }
                    } );
                }
            } );
        }


    };

} );
swifty.define( 'js/components/editor_ckeditor/ckeditor_helpers/ckeditor_helper_image',[
    'jquery',
    'swiftylib/i18n/__',
    'swiftylib/evt'
], function(
    $, __, evt
) {
    

    return function( component ) {

        if( !CKEDITOR.plugins.registered.swc_image ) {
            CKEDITOR.plugins.add( 'swc_image', {
                requires: 'widget',

                beforeInit: function( editor ) {

                    var fileTools = CKEDITOR.fileTools;

                    editor.on( 'paste__', function( evt ) {
                        // For performance reason do not parse data if it does contain img tag.
                        if( ! evt.data.dataValue.match( /<img/i ) ) {
                            return;
                        }

                        var data = evt.data,
                        // Prevent XSS attacks.
                            tempDoc = document.implementation.createHTMLDocument( '' ),
                            temp = new CKEDITOR.dom.element( tempDoc.body ),
                            imgs, img, i;

                        var getLocation = function (href) {
                            var location = document.createElement('a');
                            location.href = href;
                            // IE doesn't populate all link properties when setting .href with a relative URL,
                            // however .href will return an absolute URL which then can be used on itself
                            // to populate these additional fields.
                            if (location.host === '') {
                                location.href = location.href;
                            }
                            return location;
                        }

                        // Without this isReadOnly will not works properly.
                        temp.data( 'cke-editable', 1 );

                        temp.appendHtml( data.dataValue );

                        imgs = temp.find( 'img' );

                        for ( i = 0; i < imgs.count(); i++ ) {
                            img = imgs.getItem( i );

                            // Image should not contain src=data:...
                            var src = img.getAttribute( 'src' );
                            var isDataInSrc = src && src.substring( 0, 5 ) === 'data:',
                                isRealObject = img.data( 'cke-realelement' ) === null;


                            // We are not uploading images in non-editable blocs and fake objects (#13003).
                            if ( ( getLocation( src ).hostname !== scc_data.domain ) && !isDataInSrc && isRealObject && !img.data( 'cke-upload-id' ) && !img.isReadOnly( 1 ) ) {
                                var loader = editor.uploadRepository.create( null );
                                loader.loadAndUpload( src );

                                fileTools.markElement( img, 'uploadimage', loader.id );

                                fileTools.bindNotifications( editor, loader );
                            }
                        }
                        data.dataValue = temp.getHtml();
                    } );
                },

                init: function( editor ) {
                    editor.widgets.add( 'swc_image', {

                        allowedContent:  {
                            img: {
                                attributes: '!src,alt,width,height'
                            },
                            figure: true,
                            figcaption: true
                        },

                        requiredContent: 'img[src,alt]',

                        parts: {
                            image: 'img',
                            caption: 'figcaption'
                        },

                        upcast: function( element ) {
                            var image;
                            // #11110 Don't initialize on pasted fake objects.
                            if ( element.attributes[ 'data-cke-realelement' ] ) {
                                return;
                            }
                            if( element.name === 'figure' ) {
                                image = element.getFirst( 'img' ) || element.getFirst( 'a' ).getFirst( 'img' );
                            } else if ( ( element.name === 'img' ) || (( element.name === 'a' ) && ( element.children.length === 1 && element.getFirst( 'img' ) ) ) ) {
                                image = element.name === 'a' ? element.children[ 0 ] : element;
                            }

                            if ( !image ) {
                                return;
                            }

                            // data URIs are not convertible
                            var imageSrc;
                            if( imageSrc = image.attributes.src ) {
                                if( imageSrc.substring( 0, 5 ) === 'data:' ) {
                                    return;
                                }
                            }

                            return true;
                        },

                        downcast: function( element ) {
                            return element;
                        },

                        init: function() {
                            var self = this;
                            var wrapper = self.wrapper;
                            var $dragHandlerContainer = $( wrapper.$ ).find( '> .cke_widget_drag_handler_container' );
                            var ckDragHandlerImage = wrapper.find( '> .cke_widget_drag_handler_container img' ).getItem( 0 );
                            var $dragHandlerImage = $dragHandlerContainer.find( 'img' );

                            // remove drag and drop text
                            $dragHandlerImage.attr( 'title', '' );

                            // Add our own asset icon to the CK drag handle
                            $dragHandlerContainer.prepend( '<i class="fa fa-cog" style="padding-left: 3px;"></i>' );

                            // Open the row panel when the CK drag handle is clicked
                            $dragHandlerImage.on( 'click', function( /*ev*/ ) {
                                var $el = $( this ).closest( '.cke_widget_wrapper' );

                                if( $( this ).hasClass( 'swc_hide_asset_icon' ) ) {
                                    return false;
                                }

                                // Open the row panel
                                evt(
                                    'swifty_editor_image_dialog',
                                    {
                                        '$image_wrapper': $el
                                    }
                                );
                            } );

                            component.addCogsIconFunctionality( self, ckDragHandlerImage, $dragHandlerImage, 0 );
                        }
                    } );
                }
            } );
        }
    };
} );
swifty.define( 'js/components/editor_ckeditor/ckeditor_helpers/ckeditor_helper_row',[
    'jquery',
    'swiftylib/i18n/__',
    'swiftylib/evt'
], function(
    $, __, evt
) {
    

    return function( component ) {

        if( !CKEDITOR.plugins.registered.swc_grid_row ) {
            CKEDITOR.plugins.add( 'swc_grid_row', {
                requires: 'widget',

                init: function( editor ) {
                    editor.widgets.add( 'swc_grid_row', {
                        editables: {
                            content: {
                                selector: '.swc_grid_row'
                            }
                        },

                        upcast: function( element ) {
                            return element.name === 'div' && element.hasClass( 'swc_grid_row' );
                        },

                        downcast: function( element ) {
                            var attrString = '';
                            var attrs = element.attributes;

                            if( attrs && attrs['data-grid_data'] ) {
                                attrs = $.parseJSON( attrs['data-grid_data'] );

                                $.each( attrs, function( key, val ) {
                                    if( key !== 'content' ) {
                                        // Trick to prevent enters messing up shortcode data.
                                        val = val.replace( /\n/g, '_=EnTEr=-' );

                                        attrString += ' ' + key + '=_=QUoTe=-' + val + '_=QUoTe=-';
                                    }
                                } );

                                element.name = 'swifty_grid_row_replacer';
                                element.attributes = {
                                    'data-grid-row-shortcode_data': attrString
                                };
                            }

                            return element;
                        },

                        init: function() {
                            var self = this;
                            var wrapper = self.wrapper;
                            var $dragHandlerContainer = $( wrapper.$ ).find( '> .cke_widget_drag_handler_container' );
                            var ckDragHandlerImage = wrapper.find( '> .cke_widget_drag_handler_container img' ).getItem( 0 );
                            var $dragHandlerImage = $dragHandlerContainer.find( 'img' );

                            // Disable editable when widget is ready.
                            self.on( 'ready', function() {
                                self.editables.content.$.setAttribute( 'contenteditable', 'false' );
                            } );

                            // remove drag and drop text
                            $dragHandlerImage.attr( 'title', '' );

                            var $rowWrapper = $( wrapper.$ ).find( 'div.swc_grid_row' ).first();
                            var locked = $rowWrapper.hasClass( 'swc_locked' );
                            var isLocked = ( locked && ( ! scc_data.swifty_edit_locked ) );
                            component.addCogIconFunctionality( self, ckDragHandlerImage, $dragHandlerImage, $dragHandlerContainer, 'row', isLocked );
                            // Add our own asset icon to the CK drag handle.
                            $dragHandlerContainer.prepend( '<i class="fa fa-cog" style="padding-left: 3px;"></i>' );
                            // Hide the CK drag handle.
                            $dragHandlerContainer.addClass( 'cke_widget_drag_handler_container_swc_hidden' );

                            // Open the row panel when the CK drag handle is clicked

                            $dragHandlerImage.on( 'click', function( /*ev*/ ) {
                                var $el = $( this ).closest( '.cke_widget_wrapper' ).find( '.swc_grid_row' );

                                if( $( this ).hasClass( 'swc_hide_asset_icon' ) ) {
                                    return false;
                                }

                                // Open the row panel
                                evt(
                                    'swifty_editor_row_dialog',
                                    {
                                        '$row': $el,
                                        'mod': 'icon_clicked',
                                        'inline': self.inline
                                    }
                                );
                            } );

                            //component.addCogsIconFunctionality( self, ckDragHandlerImage, $dragHandlerImage, 0 );

                            // prevent delete and backspace
                            component.setupWidgetKeyDeletion( self );
                        }
                    } );
                }
            } );
        }

    }

} );
swifty.define( 'js/components/editor_ckeditor/ckeditor_helpers/ckeditor_helper_column',[
    'jquery',
    'swiftylib/i18n/__',
    'swiftylib/evt'
], function(
    $, __, evt
) {
    

    return function( component ) {

        if( !CKEDITOR.plugins.registered.swc_grid_column ) {
            CKEDITOR.plugins.add( 'swc_grid_column', {
                requires: 'widget',

                init: function( editor ) {
                    editor.widgets.add( 'swc_grid_column', {
                        editables: {
                            content: {
                                selector: '.swc_grid_column'
                            }
                        },

                        upcast: function( element ) {
                            return element.name === 'div' && element.hasClass( 'swc_grid_column' );
                        },

                        downcast: function( element ) {
                            var attrString = '';
                            var attrs = element.attributes;

                            if( attrs && attrs['data-grid_data'] ) {
                                attrs = $.parseJSON( attrs['data-grid_data'] );

                                $.each( attrs, function( key, val ) {
                                    if( key !== 'content' ) {
                                        // Trick to prevent enters messing up shortcode data.
                                        val = val.replace( /\n/g, '_=EnTEr=-' );

                                        attrString += ' ' + key + '=_=QUoTe=-' + val + '_=QUoTe=-';
                                    }
                                } );

                                element.name = 'swifty_grid_column_replacer';
                                element.attributes = {
                                    'data-grid-column-shortcode_data': attrString
                                };
                            }

                            return element;
                        },

                        init: function() {
                            var self = this;
                            var wrapper = self.wrapper;
                            var $dragHandlerContainer = $( wrapper.$ ).find( '> .cke_widget_drag_handler_container' );
                            var ckDragHandlerImage = wrapper.find( '> .cke_widget_drag_handler_container img' ).getItem( 0 );
                            var $dragHandlerImage = $dragHandlerContainer.find( 'img' );

                            // disable editable when widget is ready
                            self.on( 'ready', function() {
                                self.editables.content.$.setAttribute( 'contenteditable', 'false' );
                            } );

                            var $rowWrapper = $( wrapper.$ ).closest( 'div.swc_grid_row' ).first();
                            var locked = $rowWrapper.hasClass( 'swc_locked' );

                            if( ! locked || scc_data.swifty_edit_locked ) {
                                component.addPlusIconFunctionality( self, $dragHandlerContainer );
                            }

                            // Hide the CK drag handle for columns

                            $dragHandlerContainer.addClass( 'swc_hide_icon' );

                            component.addCogsIconFunctionality( self, ckDragHandlerImage, $dragHandlerImage, 0 );

                            // prevent delete and backspace
                            component.setupWidgetKeyDeletion( self );
                        }
                    } );
                }
            } );
        }

    }

} );
swifty.define( 'js/components/editor_ckeditor/ckeditor_helpers/ckeditor_helper_text',[
    'jquery',
    'swiftylib/i18n/__',
    'js/diverse/utils',
    'swiftylib/evt'
], function(
    $, __, Utils, evt
) {
    

    return function( component ) {

        if( !CKEDITOR.plugins.registered.swc_text ) {
            CKEDITOR.plugins.add( 'swc_text', {
                requires: 'widget',

                init: function( editor ) {
                    editor.widgets.add( 'swc_text', {
                        editables: {
                            content: {
                                selector: '.swc_asset_cntnt'
                            }
                        },

                        upcast: function( element ) {
                            return element.name === 'div' && element.hasClass( 'swc_text' );
                        },

                        downcast: function( element ) {
                            var attrString = '';

                            var firstChild = element.getFirst();
                            if( firstChild ) {
                                element = firstChild;
                                var attrs = element.attributes;

                                if( attrs && attrs['data-asset_data'] ) {
                                    attrs = $.parseJSON( Utils.atou( attrs['data-asset_data'] ) );

                                    $.each( attrs, function( key, val ) {
                                        if( key !== 'content' ) {
                                            // Trick to prevent enters messing up shortcode data.
                                            val = val.replace( /\n/g, '_=EnTEr=-' );

                                            attrString += ' ' + key + '=_=QUoTe=-' + val + '_=QUoTe=-';
                                        }
                                    } );

                                    element.name = 'swifty_text_replacer';
                                    element.attributes = {
                                        'data-text_data': attrString
                                    };

                                    // Replace the text-asset content by the content of the .swc_asset_cntnt wrapper,
                                    // where containing assets are correctly downcast.
                                    // I would prefer a method that does not convert to dom and back,
                                    // because this could potentionaly change the html details or order of attributes,
                                    // but could not yet find a better solution.

                                    var html = this.editables.content.getData(); // This gets the downcasted content.
                                    // Remove the .swc_asset_cntnt wrapper.
                                    var $html = $( html );
                                    if( ! $html.hasClass( 'swc_asset_cntnt' ) ) {
                                        var $html2 = $html.find( '.swc_asset_cntnt' );
                                        if( $html2.length > 0 ) {
                                            $html = $html2;
                                        }
                                    }
                                    if( $html.length > 0 ) {
                                        // Ignore comment node.
                                        if( ( $html.length !== 1) || ( $html[0].nodeType !== CKEDITOR.NODE_COMMENT ) ) {
                                            element.setHtml( $html.html() );
                                        }
                                    }
                                }
                            }

                            return element;
                        },

                        init: function() {
                            var self = this;
                            var wrapper = self.wrapper;
                            var $dragHandlerContainer = $( wrapper.$ ).find( '> .cke_widget_drag_handler_container' );
                            var ckDragHandlerImage = wrapper.find( '> .cke_widget_drag_handler_container img' ).getItem( 0 );
                            var $dragHandlerImage = $dragHandlerContainer.find( 'img' );

                            $( wrapper.$ ).css( 'clear', $( wrapper.$ ).find( '> .swc_text' ).css( 'clear' ) );

                            var $assetWrapper = $( wrapper.$ ).find( 'div.swc_text' ).first();
                            var locked = $assetWrapper.hasClass( 'swc_locked' );
                            if( ! locked || scc_data.swifty_edit_locked ) {
                                component.addCogIconFunctionality( self, ckDragHandlerImage, $dragHandlerImage, $dragHandlerContainer, 'text', false );
                                component.addPlusIconFunctionality( self, $dragHandlerContainer );
                            } else {
                                component.addCogIconFunctionality( self, ckDragHandlerImage, $dragHandlerImage, $dragHandlerContainer, 'text', true );
                                // disable editable when widget is ready
                                self.on( 'ready', function() {
                                    self.editables.content.$.setAttribute( 'contenteditable', 'false' );
                                } );
                            }
                            // Add our own asset icon to the CK drag handle.
                            $dragHandlerContainer.prepend( '<i class="fa fa-cog" style="padding-left: 3px;"></i>' );
                            // Hide the CK drag handle.
                            $dragHandlerContainer.addClass( 'cke_widget_drag_handler_container_swc_hidden' );

                            // // Open the asset panel when the CK drag handle is clicked
                            // $dragHandlerImage.on( 'click', function( /*ev*/ ) {
                            //     var $el = $( this ).closest( '.cke_widget_wrapper' ).find( '.swc_text' );
                            //
                            //     if( $( this ).hasClass( 'swc_hide_asset_icon' ) ) {
                            //         return false;
                            //     }
                            //
                            //     // hide resizer when opening panel
                            //     $( '.swc_asset_resizer_icon_wrapper' ).remove();
                            //
                            //     // Open the asset panel
                            //     evt(
                            //         'swifty_editor_asset_dialog',
                            //         {
                            //             'el': $el,
                            //             'mod': 'icon_clicked',
                            //             'inline': self.inline,
                            //             'init_css': false
                            //         }
                            //     );
                            // } );

                            //component.addCogsIconFunctionality( self, ckDragHandlerImage, $dragHandlerImage, 1 );
                        }
                    } );
                }
            } );
        }

    }

} );
swifty.define( 'js/components/editor_ckeditor/ckeditor_helpers/ckeditor_helper_widgets',[
    'jquery',
    './ckeditor_helper_asset',
    './ckeditor_helper_image',
    './ckeditor_helper_row',
    './ckeditor_helper_column',
    './ckeditor_helper_text'
], function(
    $, assetFunctionality, imageFunctionality, rowFunctionality, columnFunctionality, textFunctionality
) {
    

    return function( component ) {
        assetFunctionality( component );
        imageFunctionality( component );
        rowFunctionality( component );
        columnFunctionality( component );
        textFunctionality( component );
    };

} );
swifty.define('js/libs/mout/src/time/now',[],function () {

    /**
     * Get current time in miliseconds
     */
    function now(){
        // yes, we defer the work to another function to allow mocking it
        // during the tests
        return now.get();
    }

    now.get = (typeof Date.now === 'function')? Date.now : function(){
        return +(new Date());
    };

    return now;

});

swifty.define('js/libs/mout/src/function/throttle',['../time/now'], function (now) {

    /**
     */
    function throttle(fn, delay){
        var context, timeout, result, args,
            diff, prevCall = 0;
        function delayed(){
            prevCall = now();
            timeout = null;
            result = fn.apply(context, args);
        }
        function throttled(){
            context = this;
            args = arguments;
            diff = delay - (now() - prevCall);
            if (diff <= 0) {
                clearTimeout(timeout);
                delayed();
            } else if (! timeout) {
                timeout = setTimeout(delayed, diff);
            }
            return result;
        }
        throttled.cancel = function(){
            clearTimeout(timeout);
        };
        return throttled;
    }

    return throttle;

});

/*! jQuery UI - v1.11.4 - 2016-04-12
* http://jqueryui.com
* Includes: core.js, widget.js, mouse.js, position.js, draggable.js, droppable.js
* Copyright jQuery Foundation and other contributors; Licensed MIT */

(function( factory ) {
	if ( typeof swifty.define === 'function' && swifty.define.amd ) {

		// AMD. Register as an anonymous module.
		swifty.define('js/libs/jquery-ui',[ "jquery" ], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {
/*!
 * jQuery UI Core 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/ui-core/
 */


// $.ui might exist from components with no dependencies, e.g., $.ui.position
$.ui = $.ui || {};

$.extend( $.ui, {
	version: "1.11.4",

	keyCode: {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		LEFT: 37,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	}
});

// plugins
$.fn.extend({
	scrollParent: function( includeHidden ) {
		var position = this.css( "position" ),
			excludeStaticParent = position === "absolute",
			overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
			scrollParent = this.parents().filter( function() {
				var parent = $( this );
				if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
					return false;
				}
				return overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) + parent.css( "overflow-x" ) );
			}).eq( 0 );

		return position === "fixed" || !scrollParent.length ? $( this[ 0 ].ownerDocument || document ) : scrollParent;
	},

	uniqueId: (function() {
		var uuid = 0;

		return function() {
			return this.each(function() {
				if ( !this.id ) {
					this.id = "ui-id-" + ( ++uuid );
				}
			});
		};
	})(),

	removeUniqueId: function() {
		return this.each(function() {
			if ( /^ui-id-\d+$/.test( this.id ) ) {
				$( this ).removeAttr( "id" );
			}
		});
	}
});

// selectors
function focusable( element, isTabIndexNotNaN ) {
	var map, mapName, img,
		nodeName = element.nodeName.toLowerCase();
	if ( "area" === nodeName ) {
		map = element.parentNode;
		mapName = map.name;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
			return false;
		}
		img = $( "img[usemap='#" + mapName + "']" )[ 0 ];
		return !!img && visible( img );
	}
	return ( /^(input|select|textarea|button|object)$/.test( nodeName ) ?
		!element.disabled :
		"a" === nodeName ?
			element.href || isTabIndexNotNaN :
			isTabIndexNotNaN) &&
		// the element and all of its ancestors must be visible
		visible( element );
}

function visible( element ) {
	return $.expr.filters.visible( element ) &&
		!$( element ).parents().addBack().filter(function() {
			return $.css( this, "visibility" ) === "hidden";
		}).length;
}

$.extend( $.expr[ ":" ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo(function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		}) :
		// support: jQuery <1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		},

	focusable: function( element ) {
		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" ),
			isTabIndexNaN = isNaN( tabIndex );
		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
	}
});

// support: jQuery <1.8
if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
	$.each( [ "Width", "Height" ], function( i, name ) {
		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
				if ( border ) {
					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
				}
			});
			return size;
		}

		$.fn[ "inner" + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ "inner" + name ].call( this );
			}

			return this.each(function() {
				$( this ).css( type, reduce( this, size ) + "px" );
			});
		};

		$.fn[ "outer" + name] = function( size, margin ) {
			if ( typeof size !== "number" ) {
				return orig[ "outer" + name ].call( this, size );
			}

			return this.each(function() {
				$( this).css( type, reduce( this, size, true, margin ) + "px" );
			});
		};
	});
}

// support: jQuery <1.8
if ( !$.fn.addBack ) {
	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
	$.fn.removeData = (function( removeData ) {
		return function( key ) {
			if ( arguments.length ) {
				return removeData.call( this, $.camelCase( key ) );
			} else {
				return removeData.call( this );
			}
		};
	})( $.fn.removeData );
}

// deprecated
$.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );

$.fn.extend({
	focus: (function( orig ) {
		return function( delay, fn ) {
			return typeof delay === "number" ?
				this.each(function() {
					var elem = this;
					setTimeout(function() {
						$( elem ).focus();
						if ( fn ) {
							fn.call( elem );
						}
					}, delay );
				}) :
				orig.apply( this, arguments );
		};
	})( $.fn.focus ),

	disableSelection: (function() {
		var eventType = "onselectstart" in document.createElement( "div" ) ?
			"selectstart" :
			"mousedown";

		return function() {
			return this.bind( eventType + ".ui-disableSelection", function( event ) {
				event.preventDefault();
			});
		};
	})(),

	enableSelection: function() {
		return this.unbind( ".ui-disableSelection" );
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( "zIndex", zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length && elem[ 0 ] !== document ) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css( "position" );
				if ( position === "absolute" || position === "relative" || position === "fixed" ) {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
					value = parseInt( elem.css( "zIndex" ), 10 );
					if ( !isNaN( value ) && value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	}
});

// $.ui.plugin is deprecated. Use $.widget() extensions instead.
$.ui.plugin = {
	add: function( module, option, set ) {
		var i,
			proto = $.ui[ module ].prototype;
		for ( i in set ) {
			proto.plugins[ i ] = proto.plugins[ i ] || [];
			proto.plugins[ i ].push( [ option, set[ i ] ] );
		}
	},
	call: function( instance, name, args, allowDisconnected ) {
		var i,
			set = instance.plugins[ name ];

		if ( !set ) {
			return;
		}

		if ( !allowDisconnected && ( !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) ) {
			return;
		}

		for ( i = 0; i < set.length; i++ ) {
			if ( instance.options[ set[ i ][ 0 ] ] ) {
				set[ i ][ 1 ].apply( instance.element, args );
			}
		}
	}
};


/*!
 * jQuery UI Widget 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/jQuery.widget/
 */


var widget_uuid = 0,
	widget_slice = Array.prototype.slice;

$.cleanData = (function( orig ) {
	return function( elems ) {
		var events, elem, i;
		for ( i = 0; (elem = elems[i]) != null; i++ ) {
			try {

				// Only trigger remove when necessary to save time
				events = $._data( elem, "events" );
				if ( events && events.remove ) {
					$( elem ).triggerHandler( "remove" );
				}

			// http://bugs.jquery.com/ticket/8235
			} catch ( e ) {}
		}
		orig( elems );
	};
})( $.cleanData );

$.widget = function( name, base, prototype ) {
	var fullName, existingConstructor, constructor, basePrototype,
		// proxiedPrototype allows the provided prototype to remain unmodified
		// so that it can be used as a mixin for multiple widgets (#8876)
		proxiedPrototype = {},
		namespace = name.split( "." )[ 0 ];

	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};
	// extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,
		// copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),
		// track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	});

	basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = (function() {
			var _super = function() {
					return base.prototype[ prop ].apply( this, arguments );
				},
				_superApply = function( args ) {
					return base.prototype[ prop ].apply( this, args );
				};
			return function() {
				var __super = this._super,
					__superApply = this._superApply,
					returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		})();
	});
	constructor.prototype = $.widget.extend( basePrototype, {
		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	});

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
		});
		// remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );

	return constructor;
};

$.widget.extend = function( target ) {
	var input = widget_slice.call( arguments, 1 ),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :
						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );
				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = widget_slice.call( arguments, 1 ),
			returnValue = this;

		if ( isMethodCall ) {
			this.each(function() {
				var methodValue,
					instance = $.data( this, fullName );
				if ( options === "instance" ) {
					returnValue = instance;
					return false;
				}
				if ( !instance ) {
					return $.error( "cannot call methods on " + name + " prior to initialization; " +
						"attempted to call method '" + options + "'" );
				}
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
					return $.error( "no such method '" + options + "' for " + name + " widget instance" );
				}
				methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue && methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			});
		} else {

			// Allow multiple hashes to be passed on init
			if ( args.length ) {
				options = $.widget.extend.apply( null, [ options ].concat(args) );
			}

			this.each(function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} );
					if ( instance._init ) {
						instance._init();
					}
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",
	options: {
		disabled: false,

		// callbacks
		create: null
	},
	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = widget_uuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			});
			this.document = $( element.style ?
				// element within the document
				element.ownerDocument :
				// element is window or document
				element.document || element );
			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
		}

		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this._create();
		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},
	_getCreateOptions: $.noop,
	_getCreateEventData: $.noop,
	_create: $.noop,
	_init: $.noop,

	destroy: function() {
		this._destroy();
		// we can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.unbind( this.eventNamespace )
			.removeData( this.widgetFullName )
			// support: jquery <1.6.3
			// http://bugs.jquery.com/ticket/9413
			.removeData( $.camelCase( this.widgetFullName ) );
		this.widget()
			.unbind( this.eventNamespace )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetFullName + "-disabled " +
				"ui-state-disabled" );

		// clean up events and states
		this.bindings.unbind( this.eventNamespace );
		this.hoverable.removeClass( "ui-state-hover" );
		this.focusable.removeClass( "ui-state-focus" );
	},
	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key,
			parts,
			curOption,
			i;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {
			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( arguments.length === 1 ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( arguments.length === 1 ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				.toggleClass( this.widgetFullName + "-disabled", !!value );

			// If the widget is becoming disabled, then nothing is interactive
			if ( value ) {
				this.hoverable.removeClass( "ui-state-hover" );
				this.focusable.removeClass( "ui-state-focus" );
			}
		}

		return this;
	},

	enable: function() {
		return this._setOptions({ disabled: false });
	},
	disable: function() {
		return this._setOptions({ disabled: true });
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement,
			instance = this;

		// no suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// no element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				// allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^([\w:-]*)\s*(.*)$/ ),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
			if ( selector ) {
				delegateElement.delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},

	_off: function( element, eventName ) {
		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) +
			this.eventNamespace;
		element.unbind( eventName ).undelegate( eventName );

		// Clear the stack to avoid memory leaks (#10056)
		this.bindings = $( this.bindings.not( element ).get() );
		this.focusable = $( this.focusable.not( element ).get() );
		this.hoverable = $( this.hoverable.not( element ).get() );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-hover" );
			},
			mouseleave: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-hover" );
			}
		});
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-focus" );
			},
			focusout: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-focus" );
			}
		});
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}
		var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;
		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}
		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;
		if ( options.delay ) {
			element.delay( options.delay );
		}
		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue(function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			});
		}
	};
});

var widget = $.widget;


/*!
 * jQuery UI Mouse 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/mouse/
 */


var mouseHandled = false;
$( document ).mouseup( function() {
	mouseHandled = false;
});

var mouse = $.widget("ui.mouse", {
	version: "1.11.4",
	options: {
		cancel: "input,textarea,button,select,option",
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var that = this;

		this.element
			.bind("mousedown." + this.widgetName, function(event) {
				return that._mouseDown(event);
			})
			.bind("click." + this.widgetName, function(event) {
				if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
					$.removeData(event.target, that.widgetName + ".preventClickEvent");
					event.stopImmediatePropagation();
					return false;
				}
			});

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.unbind("." + this.widgetName);
		if ( this._mouseMoveDelegate ) {
			this.document
				.unbind("mousemove." + this.widgetName, this._mouseMoveDelegate)
				.unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
		}
	},

	_mouseDown: function(event) {
		// don't let more than one widget handle mouseStart
		if ( mouseHandled ) {
			return;
		}

		this._mouseMoved = false;

		// we may have missed mouseup (out of window)
		(this._mouseStarted && this._mouseUp(event));

		this._mouseDownEvent = event;

		var that = this,
			btnIsLeft = (event.which === 1),
			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if (!this.mouseDelayMet) {
			this._mouseDelayTimer = setTimeout(function() {
				that.mouseDelayMet = true;
			}, this.options.delay);
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted = (this._mouseStart(event) !== false);
			if (!this._mouseStarted) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko & Opera)
		if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
			$.removeData(event.target, this.widgetName + ".preventClickEvent");
		}

		// these delegates are required to keep context
		this._mouseMoveDelegate = function(event) {
			return that._mouseMove(event);
		};
		this._mouseUpDelegate = function(event) {
			return that._mouseUp(event);
		};

		this.document
			.bind( "mousemove." + this.widgetName, this._mouseMoveDelegate )
			.bind( "mouseup." + this.widgetName, this._mouseUpDelegate );

		event.preventDefault();

		mouseHandled = true;
		return true;
	},

	_mouseMove: function(event) {
		// Only check for mouseups outside the document if you've moved inside the document
		// at least once. This prevents the firing of mouseup in the case of IE<9, which will
		// fire a mousemove event if content is placed under the cursor. See #7778
		// Support: IE <9
		if ( this._mouseMoved ) {
			// IE mouseup check - mouseup happened when mouse was out of window
			if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {
				return this._mouseUp(event);

			// Iframe mouseup check - mouseup occurred in another document
			} else if ( !event.which ) {
				return this._mouseUp( event );
			}
		}

		if ( event.which || event.button ) {
			this._mouseMoved = true;
		}

		if (this._mouseStarted) {
			this._mouseDrag(event);
			return event.preventDefault();
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted =
				(this._mouseStart(this._mouseDownEvent, event) !== false);
			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
		}

		return !this._mouseStarted;
	},

	_mouseUp: function(event) {
		this.document
			.unbind( "mousemove." + this.widgetName, this._mouseMoveDelegate )
			.unbind( "mouseup." + this.widgetName, this._mouseUpDelegate );

		if (this._mouseStarted) {
			this._mouseStarted = false;

			if (event.target === this._mouseDownEvent.target) {
				$.data(event.target, this.widgetName + ".preventClickEvent", true);
			}

			this._mouseStop(event);
		}

		mouseHandled = false;
		return false;
	},

	_mouseDistanceMet: function(event) {
		return (Math.max(
				Math.abs(this._mouseDownEvent.pageX - event.pageX),
				Math.abs(this._mouseDownEvent.pageY - event.pageY)
			) >= this.options.distance
		);
	},

	_mouseDelayMet: function(/* event */) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function(/* event */) {},
	_mouseDrag: function(/* event */) {},
	_mouseStop: function(/* event */) {},
	_mouseCapture: function(/* event */) { return true; }
});


/*!
 * jQuery UI Position 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/position/
 */

(function() {

$.ui = $.ui || {};

var cachedScrollbarWidth, supportsOffsetFractions,
	max = Math.max,
	abs = Math.abs,
	round = Math.round,
	rhorizontal = /left|center|right/,
	rvertical = /top|center|bottom/,
	roffset = /[\+\-]\d+(\.[\d]+)?%?/,
	rposition = /^\w+/,
	rpercent = /%$/,
	_position = $.fn.position;

function getOffsets( offsets, width, height ) {
	return [
		parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
		parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
	];
}

function parseCss( element, property ) {
	return parseInt( $.css( element, property ), 10 ) || 0;
}

function getDimensions( elem ) {
	var raw = elem[0];
	if ( raw.nodeType === 9 ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: 0, left: 0 }
		};
	}
	if ( $.isWindow( raw ) ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
		};
	}
	if ( raw.preventDefault ) {
		return {
			width: 0,
			height: 0,
			offset: { top: raw.pageY, left: raw.pageX }
		};
	}
	return {
		width: elem.outerWidth(),
		height: elem.outerHeight(),
		offset: elem.offset()
	};
}

$.position = {
	scrollbarWidth: function() {
		if ( cachedScrollbarWidth !== undefined ) {
			return cachedScrollbarWidth;
		}
		var w1, w2,
			div = $( "<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>" ),
			innerDiv = div.children()[0];

		$( "body" ).append( div );
		w1 = innerDiv.offsetWidth;
		div.css( "overflow", "scroll" );

		w2 = innerDiv.offsetWidth;

		if ( w1 === w2 ) {
			w2 = div[0].clientWidth;
		}

		div.remove();

		return (cachedScrollbarWidth = w1 - w2);
	},
	getScrollInfo: function( within ) {
		var overflowX = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-x" ),
			overflowY = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-y" ),
			hasOverflowX = overflowX === "scroll" ||
				( overflowX === "auto" && within.width < within.element[0].scrollWidth ),
			hasOverflowY = overflowY === "scroll" ||
				( overflowY === "auto" && within.height < within.element[0].scrollHeight );
		return {
			width: hasOverflowY ? $.position.scrollbarWidth() : 0,
			height: hasOverflowX ? $.position.scrollbarWidth() : 0
		};
	},
	getWithinInfo: function( element ) {
		var withinElement = $( element || window ),
			isWindow = $.isWindow( withinElement[0] ),
			isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9;
		return {
			element: withinElement,
			isWindow: isWindow,
			isDocument: isDocument,
			offset: withinElement.offset() || { left: 0, top: 0 },
			scrollLeft: withinElement.scrollLeft(),
			scrollTop: withinElement.scrollTop(),

			// support: jQuery 1.6.x
			// jQuery 1.6 doesn't support .outerWidth/Height() on documents or windows
			width: isWindow || isDocument ? withinElement.width() : withinElement.outerWidth(),
			height: isWindow || isDocument ? withinElement.height() : withinElement.outerHeight()
		};
	}
};

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
		target = $( options.of ),
		within = $.position.getWithinInfo( options.within ),
		scrollInfo = $.position.getScrollInfo( within ),
		collision = ( options.collision || "flip" ).split( " " ),
		offsets = {};

	dimensions = getDimensions( target );
	if ( target[0].preventDefault ) {
		// force left top to allow flipping
		options.at = "left top";
	}
	targetWidth = dimensions.width;
	targetHeight = dimensions.height;
	targetOffset = dimensions.offset;
	// clone to reuse original targetOffset later
	basePosition = $.extend( {}, targetOffset );

	// force my and at to have valid horizontal and vertical positions
	// if a value is missing or invalid, it will be converted to center
	$.each( [ "my", "at" ], function() {
		var pos = ( options[ this ] || "" ).split( " " ),
			horizontalOffset,
			verticalOffset;

		if ( pos.length === 1) {
			pos = rhorizontal.test( pos[ 0 ] ) ?
				pos.concat( [ "center" ] ) :
				rvertical.test( pos[ 0 ] ) ?
					[ "center" ].concat( pos ) :
					[ "center", "center" ];
		}
		pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
		pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

		// calculate offsets
		horizontalOffset = roffset.exec( pos[ 0 ] );
		verticalOffset = roffset.exec( pos[ 1 ] );
		offsets[ this ] = [
			horizontalOffset ? horizontalOffset[ 0 ] : 0,
			verticalOffset ? verticalOffset[ 0 ] : 0
		];

		// reduce to just the positions without the offsets
		options[ this ] = [
			rposition.exec( pos[ 0 ] )[ 0 ],
			rposition.exec( pos[ 1 ] )[ 0 ]
		];
	});

	// normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	if ( options.at[ 0 ] === "right" ) {
		basePosition.left += targetWidth;
	} else if ( options.at[ 0 ] === "center" ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[ 1 ] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[ 1 ] === "center" ) {
		basePosition.top += targetHeight / 2;
	}

	atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
	basePosition.left += atOffset[ 0 ];
	basePosition.top += atOffset[ 1 ];

	return this.each(function() {
		var collisionPosition, using,
			elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseCss( this, "marginLeft" ),
			marginTop = parseCss( this, "marginTop" ),
			collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) + scrollInfo.width,
			collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) + scrollInfo.height,
			position = $.extend( {}, basePosition ),
			myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

		if ( options.my[ 0 ] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[ 0 ] === "center" ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[ 1 ] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[ 1 ] === "center" ) {
			position.top -= elemHeight / 2;
		}

		position.left += myOffset[ 0 ];
		position.top += myOffset[ 1 ];

		// if the browser doesn't support fractions, then round for consistent results
		if ( !supportsOffsetFractions ) {
			position.left = round( position.left );
			position.top = round( position.top );
		}

		collisionPosition = {
			marginLeft: marginLeft,
			marginTop: marginTop
		};

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[ i ] ] ) {
				$.ui.position[ collision[ i ] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
					my: options.my,
					at: options.at,
					within: within,
					elem: elem
				});
			}
		});

		if ( options.using ) {
			// adds feedback as second argument to using callback, if present
			using = function( props ) {
				var left = targetOffset.left - position.left,
					right = left + targetWidth - elemWidth,
					top = targetOffset.top - position.top,
					bottom = top + targetHeight - elemHeight,
					feedback = {
						target: {
							element: target,
							left: targetOffset.left,
							top: targetOffset.top,
							width: targetWidth,
							height: targetHeight
						},
						element: {
							element: elem,
							left: position.left,
							top: position.top,
							width: elemWidth,
							height: elemHeight
						},
						horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
						vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
					};
				if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
					feedback.horizontal = "center";
				}
				if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
					feedback.vertical = "middle";
				}
				if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
					feedback.important = "horizontal";
				} else {
					feedback.important = "vertical";
				}
				options.using.call( this, props, feedback );
			};
		}

		elem.offset( $.extend( position, { using: using } ) );
	});
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
				outerWidth = within.width,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = withinOffset - collisionPosLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
				newOverRight;

			// element is wider than within
			if ( data.collisionWidth > outerWidth ) {
				// element is initially over the left side of within
				if ( overLeft > 0 && overRight <= 0 ) {
					newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
					position.left += overLeft - newOverRight;
				// element is initially over right side of within
				} else if ( overRight > 0 && overLeft <= 0 ) {
					position.left = withinOffset;
				// element is initially over both left and right sides of within
				} else {
					if ( overLeft > overRight ) {
						position.left = withinOffset + outerWidth - data.collisionWidth;
					} else {
						position.left = withinOffset;
					}
				}
			// too far left -> align with left edge
			} else if ( overLeft > 0 ) {
				position.left += overLeft;
			// too far right -> align with right edge
			} else if ( overRight > 0 ) {
				position.left -= overRight;
			// adjust based on position and margin
			} else {
				position.left = max( position.left - collisionPosLeft, position.left );
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
				outerHeight = data.within.height,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = withinOffset - collisionPosTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
				newOverBottom;

			// element is taller than within
			if ( data.collisionHeight > outerHeight ) {
				// element is initially over the top of within
				if ( overTop > 0 && overBottom <= 0 ) {
					newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
					position.top += overTop - newOverBottom;
				// element is initially over bottom of within
				} else if ( overBottom > 0 && overTop <= 0 ) {
					position.top = withinOffset;
				// element is initially over both top and bottom of within
				} else {
					if ( overTop > overBottom ) {
						position.top = withinOffset + outerHeight - data.collisionHeight;
					} else {
						position.top = withinOffset;
					}
				}
			// too far up -> align with top
			} else if ( overTop > 0 ) {
				position.top += overTop;
			// too far down -> align with bottom edge
			} else if ( overBottom > 0 ) {
				position.top -= overBottom;
			// adjust based on position and margin
			} else {
				position.top = max( position.top - collisionPosTop, position.top );
			}
		}
	},
	flip: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.left + within.scrollLeft,
				outerWidth = within.width,
				offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = collisionPosLeft - offsetLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === "left" ?
					data.targetWidth :
					data.at[ 0 ] === "right" ?
						-data.targetWidth :
						0,
				offset = -2 * data.offset[ 0 ],
				newOverRight,
				newOverLeft;

			if ( overLeft < 0 ) {
				newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
				if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
					position.left += myOffset + atOffset + offset;
				}
			} else if ( overRight > 0 ) {
				newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
				if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
					position.left += myOffset + atOffset + offset;
				}
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.top + within.scrollTop,
				outerHeight = within.height,
				offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = collisionPosTop - offsetTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
				top = data.my[ 1 ] === "top",
				myOffset = top ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					data.at[ 1 ] === "bottom" ?
						-data.targetHeight :
						0,
				offset = -2 * data.offset[ 1 ],
				newOverTop,
				newOverBottom;
			if ( overTop < 0 ) {
				newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
				if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {
					position.top += myOffset + atOffset + offset;
				}
			} else if ( overBottom > 0 ) {
				newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
				if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {
					position.top += myOffset + atOffset + offset;
				}
			}
		}
	},
	flipfit: {
		left: function() {
			$.ui.position.flip.left.apply( this, arguments );
			$.ui.position.fit.left.apply( this, arguments );
		},
		top: function() {
			$.ui.position.flip.top.apply( this, arguments );
			$.ui.position.fit.top.apply( this, arguments );
		}
	}
};

// fraction support test
(function() {
	var testElement, testElementParent, testElementStyle, offsetLeft, i,
		body = document.getElementsByTagName( "body" )[ 0 ],
		div = document.createElement( "div" );

	//Create a "fake body" for testing based on method used in jQuery.support
	testElement = document.createElement( body ? "div" : "body" );
	testElementStyle = {
		visibility: "hidden",
		width: 0,
		height: 0,
		border: 0,
		margin: 0,
		background: "none"
	};
	if ( body ) {
		$.extend( testElementStyle, {
			position: "absolute",
			left: "-1000px",
			top: "-1000px"
		});
	}
	for ( i in testElementStyle ) {
		testElement.style[ i ] = testElementStyle[ i ];
	}
	testElement.appendChild( div );
	testElementParent = body || document.documentElement;
	testElementParent.insertBefore( testElement, testElementParent.firstChild );

	div.style.cssText = "position: absolute; left: 10.7432222px;";

	offsetLeft = $( div ).offset().left;
	supportsOffsetFractions = offsetLeft > 10 && offsetLeft < 11;

	testElement.innerHTML = "";
	testElementParent.removeChild( testElement );
})();

})();

var position = $.ui.position;


/*!
 * jQuery UI Draggable 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/draggable/
 */


$.widget("ui.draggable", $.ui.mouse, {
	version: "1.11.4",
	widgetEventPrefix: "drag",
	options: {
		addClasses: true,
		appendTo: "parent",
		axis: false,
		connectToSortable: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		grid: false,
		handle: false,
		helper: "original",
		iframeFix: false,
		opacity: false,
		refreshPositions: false,
		revert: false,
		revertDuration: 500,
		scope: "default",
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		snap: false,
		snapMode: "both",
		snapTolerance: 20,
		stack: false,
		zIndex: false,

		// callbacks
		drag: null,
		start: null,
		stop: null
	},
	_create: function() {

		if ( this.options.helper === "original" ) {
			this._setPositionRelative();
		}
		if (this.options.addClasses){
			this.element.addClass("ui-draggable");
		}
		if (this.options.disabled){
			this.element.addClass("ui-draggable-disabled");
		}
		this._setHandleClassName();

		this._mouseInit();
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === "handle" ) {
			this._removeHandleClassName();
			this._setHandleClassName();
		}
	},

	_destroy: function() {
		if ( ( this.helper || this.element ).is( ".ui-draggable-dragging" ) ) {
			this.destroyOnClear = true;
			return;
		}
		this.element.removeClass( "ui-draggable ui-draggable-dragging ui-draggable-disabled" );
		this._removeHandleClassName();
		this._mouseDestroy();
	},

	_mouseCapture: function(event) {
		var o = this.options;

		this._blurActiveElement( event );

		// among others, prevent a drag on a resizable-handle
		if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
			return false;
		}

		//Quit if we're not on a valid handle
		this.handle = this._getHandle(event);
		if (!this.handle) {
			return false;
		}

		this._blockFrames( o.iframeFix === true ? "iframe" : o.iframeFix );

		return true;

	},

	_blockFrames: function( selector ) {
		this.iframeBlocks = this.document.find( selector ).map(function() {
			var iframe = $( this );

			return $( "<div>" )
				.css( "position", "absolute" )
				.appendTo( iframe.parent() )
				.outerWidth( iframe.outerWidth() )
				.outerHeight( iframe.outerHeight() )
				.offset( iframe.offset() )[ 0 ];
		});
	},

	_unblockFrames: function() {
		if ( this.iframeBlocks ) {
			this.iframeBlocks.remove();
			delete this.iframeBlocks;
		}
	},

	_blurActiveElement: function( event ) {
		var document = this.document[ 0 ];

		// Only need to blur if the event occurred on the draggable itself, see #10527
		if ( !this.handleElement.is( event.target ) ) {
			return;
		}

		// support: IE9
		// IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
		try {

			// Support: IE9, IE10
			// If the <body> is blurred, IE will switch windows, see #9520
			if ( document.activeElement && document.activeElement.nodeName.toLowerCase() !== "body" ) {

				// Blur any element that currently has focus, see #4261
				$( document.activeElement ).blur();
			}
		} catch ( error ) {}
	},

	_mouseStart: function(event) {

		var o = this.options;

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		this.helper.addClass("ui-draggable-dragging");

		//Cache the helper size
		this._cacheHelperProportions();

		//If ddmanager is used for droppables, set the global draggable
		if ($.ui.ddmanager) {
			$.ui.ddmanager.current = this;
		}

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Store the helper's css position
		this.cssPosition = this.helper.css( "position" );
		this.scrollParent = this.helper.scrollParent( true );
		this.offsetParent = this.helper.offsetParent();
		this.hasFixedAncestor = this.helper.parents().filter(function() {
				return $( this ).css( "position" ) === "fixed";
			}).length > 0;

		//The element's absolute position on the page minus margins
		this.positionAbs = this.element.offset();
		this._refreshOffsets( event );

		//Generate the original position
		this.originalPosition = this.position = this._generatePosition( event, false );
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Set a containment if given in the options
		this._setContainment();

		//Trigger event + callbacks
		if (this._trigger("start", event) === false) {
			this._clear();
			return false;
		}

		//Recache the helper size
		this._cacheHelperProportions();

		//Prepare the droppable offsets
		if ($.ui.ddmanager && !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(this, event);
		}

		// Reset helper's right/bottom css if they're set and set explicit width/height instead
		// as this prevents resizing of elements with right/bottom set (see #7772)
		this._normalizeRightBottom();

		this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position

		//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStart(this, event);
		}

		return true;
	},

	_refreshOffsets: function( event ) {
		this.offset = {
			top: this.positionAbs.top - this.margins.top,
			left: this.positionAbs.left - this.margins.left,
			scroll: false,
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset()
		};

		this.offset.click = {
			left: event.pageX - this.offset.left,
			top: event.pageY - this.offset.top
		};
	},

	_mouseDrag: function(event, noPropagation) {
		// reset any necessary cached properties (see #5009)
		if ( this.hasFixedAncestor ) {
			this.offset.parent = this._getParentOffset();
		}

		//Compute the helpers position
		this.position = this._generatePosition( event, true );
		this.positionAbs = this._convertPositionTo("absolute");

		//Call plugins and callbacks and use the resulting position if something is returned
		if (!noPropagation) {
			var ui = this._uiHash();
			if (this._trigger("drag", event, ui) === false) {
				this._mouseUp({});
				return false;
			}
			this.position = ui.position;
		}

		this.helper[ 0 ].style.left = this.position.left + "px";
		this.helper[ 0 ].style.top = this.position.top + "px";

		if ($.ui.ddmanager) {
			$.ui.ddmanager.drag(this, event);
		}

		return false;
	},

	_mouseStop: function(event) {

		//If we are using droppables, inform the manager about the drop
		var that = this,
			dropped = false;
		if ($.ui.ddmanager && !this.options.dropBehaviour) {
			dropped = $.ui.ddmanager.drop(this, event);
		}

		//if a drop comes from outside (a sortable)
		if (this.dropped) {
			dropped = this.dropped;
			this.dropped = false;
		}

		if ((this.options.revert === "invalid" && !dropped) || (this.options.revert === "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
			$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
				if (that._trigger("stop", event) !== false) {
					that._clear();
				}
			});
		} else {
			if (this._trigger("stop", event) !== false) {
				this._clear();
			}
		}

		return false;
	},

	_mouseUp: function( event ) {
		this._unblockFrames();

		//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStop(this, event);
		}

		// Only need to focus if the event occurred on the draggable itself, see #10527
		if ( this.handleElement.is( event.target ) ) {
			// The interaction is over; whether or not the click resulted in a drag, focus the element
			this.element.focus();
		}

		return $.ui.mouse.prototype._mouseUp.call(this, event);
	},

	cancel: function() {

		if (this.helper.is(".ui-draggable-dragging")) {
			this._mouseUp({});
		} else {
			this._clear();
		}

		return this;

	},

	_getHandle: function(event) {
		return this.options.handle ?
			!!$( event.target ).closest( this.element.find( this.options.handle ) ).length :
			true;
	},

	_setHandleClassName: function() {
		this.handleElement = this.options.handle ?
			this.element.find( this.options.handle ) : this.element;
		this.handleElement.addClass( "ui-draggable-handle" );
	},

	_removeHandleClassName: function() {
		this.handleElement.removeClass( "ui-draggable-handle" );
	},

	_createHelper: function(event) {

		var o = this.options,
			helperIsFunction = $.isFunction( o.helper ),
			helper = helperIsFunction ?
				$( o.helper.apply( this.element[ 0 ], [ event ] ) ) :
				( o.helper === "clone" ?
					this.element.clone().removeAttr( "id" ) :
					this.element );

		if (!helper.parents("body").length) {
			helper.appendTo((o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo));
		}

		// http://bugs.jqueryui.com/ticket/9446
		// a helper function can return the original element
		// which wouldn't have been set to relative in _create
		if ( helperIsFunction && helper[ 0 ] === this.element[ 0 ] ) {
			this._setPositionRelative();
		}

		if (helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css("position"))) {
			helper.css("position", "absolute");
		}

		return helper;

	},

	_setPositionRelative: function() {
		if ( !( /^(?:r|a|f)/ ).test( this.element.css( "position" ) ) ) {
			this.element[ 0 ].style.position = "relative";
		}
	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj === "string") {
			obj = obj.split(" ");
		}
		if ($.isArray(obj)) {
			obj = { left: +obj[0], top: +obj[1] || 0 };
		}
		if ("left" in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ("right" in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ("top" in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ("bottom" in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_isRootNode: function( element ) {
		return ( /(html|body)/i ).test( element.tagName ) || element === this.document[ 0 ];
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		var po = this.offsetParent.offset(),
			document = this.document[ 0 ];

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if (this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if ( this._isRootNode( this.offsetParent[ 0 ] ) ) {
			po = { top: 0, left: 0 };
		}

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
		};

	},

	_getRelativeOffset: function() {
		if ( this.cssPosition !== "relative" ) {
			return { top: 0, left: 0 };
		}

		var p = this.element.position(),
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );

		return {
			top: p.top - ( parseInt(this.helper.css( "top" ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollTop() : 0 ),
			left: p.left - ( parseInt(this.helper.css( "left" ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollLeft() : 0 )
		};

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.element.css("marginLeft"), 10) || 0),
			top: (parseInt(this.element.css("marginTop"), 10) || 0),
			right: (parseInt(this.element.css("marginRight"), 10) || 0),
			bottom: (parseInt(this.element.css("marginBottom"), 10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var isUserScrollable, c, ce,
			o = this.options,
			document = this.document[ 0 ];

		this.relativeContainer = null;

		if ( !o.containment ) {
			this.containment = null;
			return;
		}

		if ( o.containment === "window" ) {
			this.containment = [
				$( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
				$( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,
				$( window ).scrollLeft() + $( window ).width() - this.helperProportions.width - this.margins.left,
				$( window ).scrollTop() + ( $( window ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment === "document") {
			this.containment = [
				0,
				0,
				$( document ).width() - this.helperProportions.width - this.margins.left,
				( $( document ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment.constructor === Array ) {
			this.containment = o.containment;
			return;
		}

		if ( o.containment === "parent" ) {
			o.containment = this.helper[ 0 ].parentNode;
		}

		c = $( o.containment );
		ce = c[ 0 ];

		if ( !ce ) {
			return;
		}

		isUserScrollable = /(scroll|auto)/.test( c.css( "overflow" ) );

		this.containment = [
			( parseInt( c.css( "borderLeftWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingLeft" ), 10 ) || 0 ),
			( parseInt( c.css( "borderTopWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingTop" ), 10 ) || 0 ),
			( isUserScrollable ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) -
				( parseInt( c.css( "borderRightWidth" ), 10 ) || 0 ) -
				( parseInt( c.css( "paddingRight" ), 10 ) || 0 ) -
				this.helperProportions.width -
				this.margins.left -
				this.margins.right,
			( isUserScrollable ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) -
				( parseInt( c.css( "borderBottomWidth" ), 10 ) || 0 ) -
				( parseInt( c.css( "paddingBottom" ), 10 ) || 0 ) -
				this.helperProportions.height -
				this.margins.top -
				this.margins.bottom
		];
		this.relativeContainer = c;
	},

	_convertPositionTo: function(d, pos) {

		if (!pos) {
			pos = this.position;
		}

		var mod = d === "absolute" ? 1 : -1,
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );

		return {
			top: (
				pos.top	+																// The absolute mouse position
				this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top * mod -										// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) ) * mod)
			),
			left: (
				pos.left +																// The absolute mouse position
				this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) ) * mod)
			)
		};

	},

	_generatePosition: function( event, constrainPosition ) {

		var containment, co, top, left,
			o = this.options,
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] ),
			pageX = event.pageX,
			pageY = event.pageY;

		// Cache the scroll
		if ( !scrollIsRootNode || !this.offset.scroll ) {
			this.offset.scroll = {
				top: this.scrollParent.scrollTop(),
				left: this.scrollParent.scrollLeft()
			};
		}

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		// If we are not dragging yet, we won't check for options
		if ( constrainPosition ) {
			if ( this.containment ) {
				if ( this.relativeContainer ){
					co = this.relativeContainer.offset();
					containment = [
						this.containment[ 0 ] + co.left,
						this.containment[ 1 ] + co.top,
						this.containment[ 2 ] + co.left,
						this.containment[ 3 ] + co.top
					];
				} else {
					containment = this.containment;
				}

				if (event.pageX - this.offset.click.left < containment[0]) {
					pageX = containment[0] + this.offset.click.left;
				}
				if (event.pageY - this.offset.click.top < containment[1]) {
					pageY = containment[1] + this.offset.click.top;
				}
				if (event.pageX - this.offset.click.left > containment[2]) {
					pageX = containment[2] + this.offset.click.left;
				}
				if (event.pageY - this.offset.click.top > containment[3]) {
					pageY = containment[3] + this.offset.click.top;
				}
			}

			if (o.grid) {
				//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
				top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
				pageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
				pageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

			if ( o.axis === "y" ) {
				pageX = this.originalPageX;
			}

			if ( o.axis === "x" ) {
				pageY = this.originalPageY;
			}
		}

		return {
			top: (
				pageY -																	// The absolute mouse position
				this.offset.click.top	-												// Click offset (relative to the element)
				this.offset.relative.top -												// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
				( this.cssPosition === "fixed" ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) )
			),
			left: (
				pageX -																	// The absolute mouse position
				this.offset.click.left -												// Click offset (relative to the element)
				this.offset.relative.left -												// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
				( this.cssPosition === "fixed" ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) )
			)
		};

	},

	_clear: function() {
		this.helper.removeClass("ui-draggable-dragging");
		if (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
			this.helper.remove();
		}
		this.helper = null;
		this.cancelHelperRemoval = false;
		if ( this.destroyOnClear ) {
			this.destroy();
		}
	},

	_normalizeRightBottom: function() {
		if ( this.options.axis !== "y" && this.helper.css( "right" ) !== "auto" ) {
			this.helper.width( this.helper.width() );
			this.helper.css( "right", "auto" );
		}
		if ( this.options.axis !== "x" && this.helper.css( "bottom" ) !== "auto" ) {
			this.helper.height( this.helper.height() );
			this.helper.css( "bottom", "auto" );
		}
	},

	// From now on bulk stuff - mainly helpers

	_trigger: function( type, event, ui ) {
		ui = ui || this._uiHash();
		$.ui.plugin.call( this, type, [ event, ui, this ], true );

		// Absolute position and offset (see #6884 ) have to be recalculated after plugins
		if ( /^(drag|start|stop)/.test( type ) ) {
			this.positionAbs = this._convertPositionTo( "absolute" );
			ui.offset = this.positionAbs;
		}
		return $.Widget.prototype._trigger.call( this, type, event, ui );
	},

	plugins: {},

	_uiHash: function() {
		return {
			helper: this.helper,
			position: this.position,
			originalPosition: this.originalPosition,
			offset: this.positionAbs
		};
	}

});

$.ui.plugin.add( "draggable", "connectToSortable", {
	start: function( event, ui, draggable ) {
		var uiSortable = $.extend( {}, ui, {
			item: draggable.element
		});

		draggable.sortables = [];
		$( draggable.options.connectToSortable ).each(function() {
			var sortable = $( this ).sortable( "instance" );

			if ( sortable && !sortable.options.disabled ) {
				draggable.sortables.push( sortable );

				// refreshPositions is called at drag start to refresh the containerCache
				// which is used in drag. This ensures it's initialized and synchronized
				// with any changes that might have happened on the page since initialization.
				sortable.refreshPositions();
				sortable._trigger("activate", event, uiSortable);
			}
		});
	},
	stop: function( event, ui, draggable ) {
		var uiSortable = $.extend( {}, ui, {
			item: draggable.element
		});

		draggable.cancelHelperRemoval = false;

		$.each( draggable.sortables, function() {
			var sortable = this;

			if ( sortable.isOver ) {
				sortable.isOver = 0;

				// Allow this sortable to handle removing the helper
				draggable.cancelHelperRemoval = true;
				sortable.cancelHelperRemoval = false;

				// Use _storedCSS To restore properties in the sortable,
				// as this also handles revert (#9675) since the draggable
				// may have modified them in unexpected ways (#8809)
				sortable._storedCSS = {
					position: sortable.placeholder.css( "position" ),
					top: sortable.placeholder.css( "top" ),
					left: sortable.placeholder.css( "left" )
				};

				sortable._mouseStop(event);

				// Once drag has ended, the sortable should return to using
				// its original helper, not the shared helper from draggable
				sortable.options.helper = sortable.options._helper;
			} else {
				// Prevent this Sortable from removing the helper.
				// However, don't set the draggable to remove the helper
				// either as another connected Sortable may yet handle the removal.
				sortable.cancelHelperRemoval = true;

				sortable._trigger( "deactivate", event, uiSortable );
			}
		});
	},
	drag: function( event, ui, draggable ) {
		$.each( draggable.sortables, function() {
			var innermostIntersecting = false,
				sortable = this;

			// Copy over variables that sortable's _intersectsWith uses
			sortable.positionAbs = draggable.positionAbs;
			sortable.helperProportions = draggable.helperProportions;
			sortable.offset.click = draggable.offset.click;

			if ( sortable._intersectsWith( sortable.containerCache ) ) {
				innermostIntersecting = true;

				$.each( draggable.sortables, function() {
					// Copy over variables that sortable's _intersectsWith uses
					this.positionAbs = draggable.positionAbs;
					this.helperProportions = draggable.helperProportions;
					this.offset.click = draggable.offset.click;

					if ( this !== sortable &&
							this._intersectsWith( this.containerCache ) &&
							$.contains( sortable.element[ 0 ], this.element[ 0 ] ) ) {
						innermostIntersecting = false;
					}

					return innermostIntersecting;
				});
			}

			if ( innermostIntersecting ) {
				// If it intersects, we use a little isOver variable and set it once,
				// so that the move-in stuff gets fired only once.
				if ( !sortable.isOver ) {
					sortable.isOver = 1;

					// Store draggable's parent in case we need to reappend to it later.
					draggable._parent = ui.helper.parent();

					sortable.currentItem = ui.helper
						.appendTo( sortable.element )
						.data( "ui-sortable-item", true );

					// Store helper option to later restore it
					sortable.options._helper = sortable.options.helper;

					sortable.options.helper = function() {
						return ui.helper[ 0 ];
					};

					// Fire the start events of the sortable with our passed browser event,
					// and our own helper (so it doesn't create a new one)
					event.target = sortable.currentItem[ 0 ];
					sortable._mouseCapture( event, true );
					sortable._mouseStart( event, true, true );

					// Because the browser event is way off the new appended portlet,
					// modify necessary variables to reflect the changes
					sortable.offset.click.top = draggable.offset.click.top;
					sortable.offset.click.left = draggable.offset.click.left;
					sortable.offset.parent.left -= draggable.offset.parent.left -
						sortable.offset.parent.left;
					sortable.offset.parent.top -= draggable.offset.parent.top -
						sortable.offset.parent.top;

					draggable._trigger( "toSortable", event );

					// Inform draggable that the helper is in a valid drop zone,
					// used solely in the revert option to handle "valid/invalid".
					draggable.dropped = sortable.element;

					// Need to refreshPositions of all sortables in the case that
					// adding to one sortable changes the location of the other sortables (#9675)
					$.each( draggable.sortables, function() {
						this.refreshPositions();
					});

					// hack so receive/update callbacks work (mostly)
					draggable.currentItem = draggable.element;
					sortable.fromOutside = draggable;
				}

				if ( sortable.currentItem ) {
					sortable._mouseDrag( event );
					// Copy the sortable's position because the draggable's can potentially reflect
					// a relative position, while sortable is always absolute, which the dragged
					// element has now become. (#8809)
					ui.position = sortable.position;
				}
			} else {
				// If it doesn't intersect with the sortable, and it intersected before,
				// we fake the drag stop of the sortable, but make sure it doesn't remove
				// the helper by using cancelHelperRemoval.
				if ( sortable.isOver ) {

					sortable.isOver = 0;
					sortable.cancelHelperRemoval = true;

					// Calling sortable's mouseStop would trigger a revert,
					// so revert must be temporarily false until after mouseStop is called.
					sortable.options._revert = sortable.options.revert;
					sortable.options.revert = false;

					sortable._trigger( "out", event, sortable._uiHash( sortable ) );
					sortable._mouseStop( event, true );

					// restore sortable behaviors that were modfied
					// when the draggable entered the sortable area (#9481)
					sortable.options.revert = sortable.options._revert;
					sortable.options.helper = sortable.options._helper;

					if ( sortable.placeholder ) {
						sortable.placeholder.remove();
					}

					// Restore and recalculate the draggable's offset considering the sortable
					// may have modified them in unexpected ways. (#8809, #10669)
					ui.helper.appendTo( draggable._parent );
					draggable._refreshOffsets( event );
					ui.position = draggable._generatePosition( event, true );

					draggable._trigger( "fromSortable", event );

					// Inform draggable that the helper is no longer in a valid drop zone
					draggable.dropped = false;

					// Need to refreshPositions of all sortables just in case removing
					// from one sortable changes the location of other sortables (#9675)
					$.each( draggable.sortables, function() {
						this.refreshPositions();
					});
				}
			}
		});
	}
});

$.ui.plugin.add("draggable", "cursor", {
	start: function( event, ui, instance ) {
		var t = $( "body" ),
			o = instance.options;

		if (t.css("cursor")) {
			o._cursor = t.css("cursor");
		}
		t.css("cursor", o.cursor);
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;
		if (o._cursor) {
			$("body").css("cursor", o._cursor);
		}
	}
});

$.ui.plugin.add("draggable", "opacity", {
	start: function( event, ui, instance ) {
		var t = $( ui.helper ),
			o = instance.options;
		if (t.css("opacity")) {
			o._opacity = t.css("opacity");
		}
		t.css("opacity", o.opacity);
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;
		if (o._opacity) {
			$(ui.helper).css("opacity", o._opacity);
		}
	}
});

$.ui.plugin.add("draggable", "scroll", {
	start: function( event, ui, i ) {
		if ( !i.scrollParentNotHidden ) {
			i.scrollParentNotHidden = i.helper.scrollParent( false );
		}

		if ( i.scrollParentNotHidden[ 0 ] !== i.document[ 0 ] && i.scrollParentNotHidden[ 0 ].tagName !== "HTML" ) {
			i.overflowOffset = i.scrollParentNotHidden.offset();
		}
	},
	drag: function( event, ui, i  ) {

		var o = i.options,
			scrolled = false,
			scrollParent = i.scrollParentNotHidden[ 0 ],
			document = i.document[ 0 ];

		if ( scrollParent !== document && scrollParent.tagName !== "HTML" ) {
			if ( !o.axis || o.axis !== "x" ) {
				if ( ( i.overflowOffset.top + scrollParent.offsetHeight ) - event.pageY < o.scrollSensitivity ) {
					scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;
				} else if ( event.pageY - i.overflowOffset.top < o.scrollSensitivity ) {
					scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;
				}
			}

			if ( !o.axis || o.axis !== "y" ) {
				if ( ( i.overflowOffset.left + scrollParent.offsetWidth ) - event.pageX < o.scrollSensitivity ) {
					scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;
				} else if ( event.pageX - i.overflowOffset.left < o.scrollSensitivity ) {
					scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;
				}
			}

		} else {

			if (!o.axis || o.axis !== "x") {
				if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				} else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
				}
			}

			if (!o.axis || o.axis !== "y") {
				if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				} else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
				}
			}

		}

		if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(i, event);
		}

	}
});

$.ui.plugin.add("draggable", "snap", {
	start: function( event, ui, i ) {

		var o = i.options;

		i.snapElements = [];

		$(o.snap.constructor !== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap).each(function() {
			var $t = $(this),
				$o = $t.offset();
			if (this !== i.element[0]) {
				i.snapElements.push({
					item: this,
					width: $t.outerWidth(), height: $t.outerHeight(),
					top: $o.top, left: $o.left
				});
			}
		});

	},
	drag: function( event, ui, inst ) {

		var ts, bs, ls, rs, l, r, t, b, i, first,
			o = inst.options,
			d = o.snapTolerance,
			x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

		for (i = inst.snapElements.length - 1; i >= 0; i--){

			l = inst.snapElements[i].left - inst.margins.left;
			r = l + inst.snapElements[i].width;
			t = inst.snapElements[i].top - inst.margins.top;
			b = t + inst.snapElements[i].height;

			if ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains( inst.snapElements[ i ].item.ownerDocument, inst.snapElements[ i ].item ) ) {
				if (inst.snapElements[i].snapping) {
					(inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
				}
				inst.snapElements[i].snapping = false;
				continue;
			}

			if (o.snapMode !== "inner") {
				ts = Math.abs(t - y2) <= d;
				bs = Math.abs(b - y1) <= d;
				ls = Math.abs(l - x2) <= d;
				rs = Math.abs(r - x1) <= d;
				if (ts) {
					ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top;
				}
				if (bs) {
					ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top;
				}
				if (ls) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left;
				}
				if (rs) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left;
				}
			}

			first = (ts || bs || ls || rs);

			if (o.snapMode !== "outer") {
				ts = Math.abs(t - y1) <= d;
				bs = Math.abs(b - y2) <= d;
				ls = Math.abs(l - x1) <= d;
				rs = Math.abs(r - x2) <= d;
				if (ts) {
					ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top;
				}
				if (bs) {
					ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top;
				}
				if (ls) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left;
				}
				if (rs) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left;
				}
			}

			if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
				(inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
			}
			inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

		}

	}
});

$.ui.plugin.add("draggable", "stack", {
	start: function( event, ui, instance ) {
		var min,
			o = instance.options,
			group = $.makeArray($(o.stack)).sort(function(a, b) {
				return (parseInt($(a).css("zIndex"), 10) || 0) - (parseInt($(b).css("zIndex"), 10) || 0);
			});

		if (!group.length) { return; }

		min = parseInt($(group[0]).css("zIndex"), 10) || 0;
		$(group).each(function(i) {
			$(this).css("zIndex", min + i);
		});
		this.css("zIndex", (min + group.length));
	}
});

$.ui.plugin.add("draggable", "zIndex", {
	start: function( event, ui, instance ) {
		var t = $( ui.helper ),
			o = instance.options;

		if (t.css("zIndex")) {
			o._zIndex = t.css("zIndex");
		}
		t.css("zIndex", o.zIndex);
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;

		if (o._zIndex) {
			$(ui.helper).css("zIndex", o._zIndex);
		}
	}
});

var draggable = $.ui.draggable;


/*!
 * jQuery UI Droppable 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/droppable/
 */


$.widget( "ui.droppable", {
	version: "1.11.4",
	widgetEventPrefix: "drop",
	options: {
		accept: "*",
		activeClass: false,
		addClasses: true,
		greedy: false,
		hoverClass: false,
		scope: "default",
		tolerance: "intersect",

		// callbacks
		activate: null,
		deactivate: null,
		drop: null,
		out: null,
		over: null
	},
	_create: function() {

		var proportions,
			o = this.options,
			accept = o.accept;

		this.isover = false;
		this.isout = true;

		this.accept = $.isFunction( accept ) ? accept : function( d ) {
			return d.is( accept );
		};

		this.proportions = function( /* valueToWrite */ ) {
			if ( arguments.length ) {
				// Store the droppable's proportions
				proportions = arguments[ 0 ];
			} else {
				// Retrieve or derive the droppable's proportions
				return proportions ?
					proportions :
					proportions = {
						width: this.element[ 0 ].offsetWidth,
						height: this.element[ 0 ].offsetHeight
					};
			}
		};

		this._addToManager( o.scope );

		o.addClasses && this.element.addClass( "ui-droppable" );

	},

	_addToManager: function( scope ) {
		// Add the reference and positions to the manager
		$.ui.ddmanager.droppables[ scope ] = $.ui.ddmanager.droppables[ scope ] || [];
		$.ui.ddmanager.droppables[ scope ].push( this );
	},

	_splice: function( drop ) {
		var i = 0;
		for ( ; i < drop.length; i++ ) {
			if ( drop[ i ] === this ) {
				drop.splice( i, 1 );
			}
		}
	},

	_destroy: function() {
		var drop = $.ui.ddmanager.droppables[ this.options.scope ];

		this._splice( drop );

		this.element.removeClass( "ui-droppable ui-droppable-disabled" );
	},

	_setOption: function( key, value ) {

		if ( key === "accept" ) {
			this.accept = $.isFunction( value ) ? value : function( d ) {
				return d.is( value );
			};
		} else if ( key === "scope" ) {
			var drop = $.ui.ddmanager.droppables[ this.options.scope ];

			this._splice( drop );
			this._addToManager( value );
		}

		this._super( key, value );
	},

	_activate: function( event ) {
		var draggable = $.ui.ddmanager.current;
		if ( this.options.activeClass ) {
			this.element.addClass( this.options.activeClass );
		}
		if ( draggable ){
			this._trigger( "activate", event, this.ui( draggable ) );
		}
	},

	_deactivate: function( event ) {
		var draggable = $.ui.ddmanager.current;
		if ( this.options.activeClass ) {
			this.element.removeClass( this.options.activeClass );
		}
		if ( draggable ){
			this._trigger( "deactivate", event, this.ui( draggable ) );
		}
	},

	_over: function( event ) {

		var draggable = $.ui.ddmanager.current;

		// Bail if draggable and droppable are same element
		if ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] === this.element[ 0 ] ) {
			return;
		}

		if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {
			if ( this.options.hoverClass ) {
				this.element.addClass( this.options.hoverClass );
			}
			this._trigger( "over", event, this.ui( draggable ) );
		}

	},

	_out: function( event ) {

		var draggable = $.ui.ddmanager.current;

		// Bail if draggable and droppable are same element
		if ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] === this.element[ 0 ] ) {
			return;
		}

		if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {
			if ( this.options.hoverClass ) {
				this.element.removeClass( this.options.hoverClass );
			}
			this._trigger( "out", event, this.ui( draggable ) );
		}

	},

	_drop: function( event, custom ) {

		var draggable = custom || $.ui.ddmanager.current,
			childrenIntersection = false;

		// Bail if draggable and droppable are same element
		if ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] === this.element[ 0 ] ) {
			return false;
		}

		this.element.find( ":data(ui-droppable)" ).not( ".ui-draggable-dragging" ).each(function() {
			var inst = $( this ).droppable( "instance" );
			if (
				inst.options.greedy &&
				!inst.options.disabled &&
				inst.options.scope === draggable.options.scope &&
				inst.accept.call( inst.element[ 0 ], ( draggable.currentItem || draggable.element ) ) &&
				$.ui.intersect( draggable, $.extend( inst, { offset: inst.element.offset() } ), inst.options.tolerance, event )
			) { childrenIntersection = true; return false; }
		});
		if ( childrenIntersection ) {
			return false;
		}

		if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {
			if ( this.options.activeClass ) {
				this.element.removeClass( this.options.activeClass );
			}
			if ( this.options.hoverClass ) {
				this.element.removeClass( this.options.hoverClass );
			}
			this._trigger( "drop", event, this.ui( draggable ) );
			return this.element;
		}

		return false;

	},

	ui: function( c ) {
		return {
			draggable: ( c.currentItem || c.element ),
			helper: c.helper,
			position: c.position,
			offset: c.positionAbs
		};
	}

});

$.ui.intersect = (function() {
	function isOverAxis( x, reference, size ) {
		return ( x >= reference ) && ( x < ( reference + size ) );
	}

	return function( draggable, droppable, toleranceMode, event ) {

		if ( !droppable.offset ) {
			return false;
		}

		var x1 = ( draggable.positionAbs || draggable.position.absolute ).left + draggable.margins.left,
			y1 = ( draggable.positionAbs || draggable.position.absolute ).top + draggable.margins.top,
			x2 = x1 + draggable.helperProportions.width,
			y2 = y1 + draggable.helperProportions.height,
			l = droppable.offset.left,
			t = droppable.offset.top,
			r = l + droppable.proportions().width,
			b = t + droppable.proportions().height;

		switch ( toleranceMode ) {
		case "fit":
			return ( l <= x1 && x2 <= r && t <= y1 && y2 <= b );
		case "intersect":
			return ( l < x1 + ( draggable.helperProportions.width / 2 ) && // Right Half
				x2 - ( draggable.helperProportions.width / 2 ) < r && // Left Half
				t < y1 + ( draggable.helperProportions.height / 2 ) && // Bottom Half
				y2 - ( draggable.helperProportions.height / 2 ) < b ); // Top Half
		case "pointer":
			return isOverAxis( event.pageY, t, droppable.proportions().height ) && isOverAxis( event.pageX, l, droppable.proportions().width );
		case "touch":
			return (
				( y1 >= t && y1 <= b ) || // Top edge touching
				( y2 >= t && y2 <= b ) || // Bottom edge touching
				( y1 < t && y2 > b ) // Surrounded vertically
			) && (
				( x1 >= l && x1 <= r ) || // Left edge touching
				( x2 >= l && x2 <= r ) || // Right edge touching
				( x1 < l && x2 > r ) // Surrounded horizontally
			);
		default:
			return false;
		}
	};
})();

/*
	This manager tracks offsets of draggables and droppables
*/
$.ui.ddmanager = {
	current: null,
	droppables: { "default": [] },
	prepareOffsets: function( t, event ) {

		var i, j,
			m = $.ui.ddmanager.droppables[ t.options.scope ] || [],
			type = event ? event.type : null, // workaround for #2317
			list = ( t.currentItem || t.element ).find( ":data(ui-droppable)" ).addBack();

		droppablesLoop: for ( i = 0; i < m.length; i++ ) {

			// No disabled and non-accepted
			if ( m[ i ].options.disabled || ( t && !m[ i ].accept.call( m[ i ].element[ 0 ], ( t.currentItem || t.element ) ) ) ) {
				continue;
			}

			// Filter out elements in the current dragged item
			for ( j = 0; j < list.length; j++ ) {
				if ( list[ j ] === m[ i ].element[ 0 ] ) {
					m[ i ].proportions().height = 0;
					continue droppablesLoop;
				}
			}

			m[ i ].visible = m[ i ].element.css( "display" ) !== "none";
			if ( !m[ i ].visible ) {
				continue;
			}

			// Activate the droppable if used directly from draggables
			if ( type === "mousedown" ) {
				m[ i ]._activate.call( m[ i ], event );
			}

			m[ i ].offset = m[ i ].element.offset();
			m[ i ].proportions({ width: m[ i ].element[ 0 ].offsetWidth, height: m[ i ].element[ 0 ].offsetHeight });

		}

	},
	drop: function( draggable, event ) {

		var dropped = false;
		// Create a copy of the droppables in case the list changes during the drop (#9116)
		$.each( ( $.ui.ddmanager.droppables[ draggable.options.scope ] || [] ).slice(), function() {

			if ( !this.options ) {
				return;
			}
			if ( !this.options.disabled && this.visible && $.ui.intersect( draggable, this, this.options.tolerance, event ) ) {
				dropped = this._drop.call( this, event ) || dropped;
			}

			if ( !this.options.disabled && this.visible && this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {
				this.isout = true;
				this.isover = false;
				this._deactivate.call( this, event );
			}

		});
		return dropped;

	},
	dragStart: function( draggable, event ) {
		// Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
		draggable.element.parentsUntil( "body" ).bind( "scroll.droppable", function() {
			if ( !draggable.options.refreshPositions ) {
				$.ui.ddmanager.prepareOffsets( draggable, event );
			}
		});
	},
	drag: function( draggable, event ) {

		// If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
		if ( draggable.options.refreshPositions ) {
			$.ui.ddmanager.prepareOffsets( draggable, event );
		}

		// Run through all droppables and check their positions based on specific tolerance options
		$.each( $.ui.ddmanager.droppables[ draggable.options.scope ] || [], function() {

			if ( this.options.disabled || this.greedyChild || !this.visible ) {
				return;
			}

			var parentInstance, scope, parent,
				intersects = $.ui.intersect( draggable, this, this.options.tolerance, event ),
				c = !intersects && this.isover ? "isout" : ( intersects && !this.isover ? "isover" : null );
			if ( !c ) {
				return;
			}

			if ( this.options.greedy ) {
				// find droppable parents with same scope
				scope = this.options.scope;
				parent = this.element.parents( ":data(ui-droppable)" ).filter(function() {
					return $( this ).droppable( "instance" ).options.scope === scope;
				});

				if ( parent.length ) {
					parentInstance = $( parent[ 0 ] ).droppable( "instance" );
					parentInstance.greedyChild = ( c === "isover" );
				}
			}

			// we just moved into a greedy child
			if ( parentInstance && c === "isover" ) {
				parentInstance.isover = false;
				parentInstance.isout = true;
				parentInstance._out.call( parentInstance, event );
			}

			this[ c ] = true;
			this[c === "isout" ? "isover" : "isout"] = false;
			this[c === "isover" ? "_over" : "_out"].call( this, event );

			// we just moved out of a greedy child
			if ( parentInstance && c === "isout" ) {
				parentInstance.isout = false;
				parentInstance.isover = true;
				parentInstance._over.call( parentInstance, event );
			}
		});

	},
	dragStop: function( draggable, event ) {
		draggable.element.parentsUntil( "body" ).unbind( "scroll.droppable" );
		// Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
		if ( !draggable.options.refreshPositions ) {
			$.ui.ddmanager.prepareOffsets( draggable, event );
		}
	}
};

var droppable = $.ui.droppable;



}));
/*
 * Require-CSS RequireJS css! loader plugin
 * 0.1.2
 * Guy Bedford 2013
 * MIT
 */

/*
 *
 * Usage:
 *  require(['css!./mycssFile']);
 *
 * Tested and working in (up to latest versions as of March 2013):
 * Android
 * iOS 6
 * IE 6 - 10
 * Chome 3 - 26
 * Firefox 3.5 - 19
 * Opera 10 - 12
 * 
 * browserling.com used for virtual testing environment
 *
 * Credit to B Cavalier & J Hann for the IE 6 - 9 method,
 * refined with help from Martin Cermak
 * 
 * Sources that helped along the way:
 * - https://developer.mozilla.org/en-US/docs/Browser_detection_using_the_user_agent
 * - http://www.phpied.com/when-is-a-stylesheet-really-loaded/
 * - https://github.com/cujojs/curl/blob/master/src/curl/plugin/css.js
 *
 */

swifty.define('css',[],function() {
  if (typeof window == 'undefined')
    return { load: function(n, r, load){ load() } };

  var head = document.getElementsByTagName('head')[0];

  var engine = window.navigator.userAgent.match(/Trident\/([^ ;]*)|AppleWebKit\/([^ ;]*)|Opera\/([^ ;]*)|rv\:([^ ;]*)(.*?)Gecko\/([^ ;]*)|MSIE\s([^ ;]*)/) || 0;

  // use <style> @import load method (IE < 9, Firefox < 18)
  var useImportLoad = false;
  
  // set to false for explicit <link> load checking when onload doesn't work perfectly (webkit)
  var useOnload = true;

  // trident / msie
  if (engine[1] || engine[7])
    useImportLoad = parseInt(engine[1]) < 6 || parseInt(engine[7]) <= 9;
  // webkit
  else if (engine[2])
    useOnload = false;
  // gecko
  else if (engine[4])
    useImportLoad = parseInt(engine[4]) < 18;
  
  //main api object
  var cssAPI = {};

  cssAPI.pluginBuilder = './js/libs/css-builder';

  // <style> @import load method
  var curStyle, curSheet;
  var createStyle = function () {
    curStyle = document.createElement('style');
    head.appendChild(curStyle);
    curSheet = curStyle.styleSheet || curStyle.sheet;
  }
  var ieCnt = 0;
  var ieLoads = [];
  var ieCurCallback;
  
  var createIeLoad = function(url) {
    ieCnt++;
    if (ieCnt == 32) {
      createStyle();
      ieCnt = 0;
    }
    curSheet.addImport(url);
    curStyle.onload = function(){ processIeLoad() };
  }
  var processIeLoad = function() {
    ieCurCallback();
 
    var nextLoad = ieLoads.shift();
 
    if (!nextLoad) {
      ieCurCallback = null;
      return;
    }
 
    ieCurCallback = nextLoad[1];
    createIeLoad(nextLoad[0]);
  }
  var importLoad = function(url, callback) {
    if (!curSheet || !curSheet.addImport)
      createStyle();

    if (curSheet && curSheet.addImport) {
      // old IE
      if (ieCurCallback) {
        ieLoads.push([url, callback]);
      }
      else {
        createIeLoad(url);
        ieCurCallback = callback;
      }
    }
    else {
      // old Firefox
      curStyle.textContent = '@import "' + url + '";';

      var loadInterval = setInterval(function() {
        try {
          curStyle.sheet.cssRules;
          clearInterval(loadInterval);
          callback();
        } catch(e) {}
      }, 10);
    }
  }

  // <link> load method
  var linkLoad = function(url, callback) {
    var link = document.createElement('link');
    link.type = 'text/css';
    link.rel = 'stylesheet';
    if (useOnload)
      link.onload = function() {
        link.onload = function() {};
        // for style dimensions queries, a short delay can still be necessary
        setTimeout(callback, 7);
      }
    else
      var loadInterval = setInterval(function() {
        for (var i = 0; i < document.styleSheets.length; i++) {
          var sheet = document.styleSheets[i];
          if (sheet.href == link.href) {
            clearInterval(loadInterval);
            return callback();
          }
        }
      }, 10);
    link.href = url;
    head.appendChild(link);
  }

  cssAPI.normalize = function(name, normalize) {
    if (name.substr(name.length - 4, 4) == '.css')
      name = name.substr(0, name.length - 4);

    return normalize(name);
  }

  cssAPI.load = function(cssId, req, load, config) {

    (useImportLoad ? importLoad : linkLoad)(req.toUrl(cssId + '.css'), load);

  }

  return cssAPI;
});


swifty.define('css!js/components/editor_ckeditor/editor_ckeditor',[],function(){});

swifty.define('css!js/components/tooltip/tooltip',[],function(){});
window.CKEDITOR_GETURL = function( resource) {
    //console.log( 'window.CKEDITOR_GETURL', resource );
    if( resource.indexOf( 'plugins/' ) === 0 ) {
        return scc_data.swcreator_url + 'js/libs/ckeditor/' + resource;
    }
};

swifty.define( 'js/components/editor_ckeditor/editor_ckeditor',[
    'jquery',
    'can',
    'swiftylib/component',
    'swiftylib/view',
    'swiftylib/evt',
    'stache!js/components/editor_ckeditor/editor_ckeditor.stache',
    'js/libs/jBox.min',
    'swiftylib/i18n/__',
    'js/diverse/utils',
    './ckeditor_helpers/ckeditor_helper_seperate',
    './ckeditor_helpers/ckeditor_helper_widgets',
    'js/libs/yepnope',
    'js/libs/mout/src/function/throttle',
    // No return values:
    'js/libs/jquery-ui',
    'css!./editor_ckeditor.css',
    'css!../tooltip/tooltip.css'
], function(
    $, can, Component, View, evt, tmpl, JBox, __, Utils, addSeperateFunctionality, initWidgets, yepnope, throttle
) {
    

    return Component.extend( {
        tag: 'swifty_editor_ckeditor',
        template: new View( tmpl ),
        lastUndoImage: null,
        undoImageStack: null,

        scope: {
            className: 'swifty_editor',
            selector: '@',
            googleFonts: {
                'sans': [
                    'Lato',
                    'Montserrat',
                    'Open Sans',
                    'Roboto',
                    'Muli',
                    'Ubuntu',
                    'Oswald',
                    'Nunito'
                ], 'serif': [
                    'Lora',
                    'Playfair Display',
                    'Noto Serif',
                    'Josefin Slab',
                    'Roboto Slab',
                    'Arvo'
                ], 'special': [
                    'Sacramento',
                    'Cabin Sketch',
                    'Capriola',
                    'Amatic SC',
                    'Londrina Solid',
                    'Pacifico',
                    'Delius Swash Caps',
                    'Bubblegum Sans',
                    'Special Elite'
                ]
            },

            ini: function( /*$el*/ ) {
                var self = this;
                var component = this;

                addSeperateFunctionality( this );

                //var req = typeof( require ) !== 'undefined' ? require : swifty.require;
                //req( [ scc_data.swcreator_url + 'js/libs/ckeditor/ckeditor.js' ], function() {
                //    req( [ scc_data.swcreator_url + 'js/libs/ckeditor/adapters/jquery.js' ], function() {
                yepnope.injectJs( {
                    _url: scc_data.swcreator_url + 'js/libs/ckeditor/ckeditor.js' + '?swcv=scc_' + scc_data.scc_version
                }, function() {
                    yepnope.injectJs( {
                        _url: scc_data.swcreator_url + 'js/libs/ckeditor/adapters/jquery.js' + '?swcv=scc_' + scc_data.scc_version
                    }, function() {

                        initWidgets( component );

                        // Empty p, i and divs tags must be allowed.
                        CKEDITOR.dtd.$removeEmpty.p = 0;
                        CKEDITOR.dtd.$removeEmpty.i = 0;
                        CKEDITOR.dtd.$removeEmpty.div = 0;
                        // do remove empty span tags. When they are not removed changing fonts / colors of selected
                        // text will result in a lot of empty span tags and empty lines will be removed. There is a
                        // side effect when content already contains a lot of empty span tags: they will result in empty
                        // lines. This only happen one time, after this the empty spans will be properly cleaned
                        CKEDITOR.dtd.$removeEmpty.span = 1;
                        CKEDITOR.basePath = scc_data.swcreator_url + 'js/libs/ckeditor/';
                        CKEDITOR.plugins.basePath = scc_data.swcreator_url + 'js/libs/ckeditor/plugins/';

                        CKEDITOR.on( 'instanceReady', function() {
                            if( typeof swifty_add_exec === 'function' ) {
                                swifty_add_exec( { 'status': 'release', 'for': 'ck_inited' } );
                            }

                            // Setting contenteditable to false causes at least 2 problems:
                            // - On some page multiple CK instances get initialised and the tollbars don't have our config.
                            // - On first click on one of the icons (or not editable assets) the page scrolls and the click fails.
                            // We did set contenteditable to false previously because we want to prevent adding text outside of rows and outside of text assets.
                            // Preliminary test seems to indicate that that is no longer easlily achieved anyways.
                            // $( self.attr( 'selector' ) ).attr( 'contenteditable', 'false' );

                            evt( 'swifty_update_scrolleffect' );
                        } );

                        var $editor = $( self.attr( 'selector' ) ).attr( 'contenteditable', 'true' );
                        self.createEditor( $editor );

                        self.instance = $editor.editor;

                        // var focusManager = new CKEDITOR.focusManager( self.instance );
                        // focusManager.focus();
                        $editor.focus();

                        self.tooltip = null;
                        self.$toolbar = null;
                        self.set_focus = 1;
                        self.$asset_in_edit_mode = null;
                        self.swifty_insert_content = false;
                        self.sticky_editor = +scc_data.editor_visibility;   // '0' or '1'
                        self.forceShortcodeCloseTags = {};

                        // Calling the change event after each change was taking too much time,
                        // it is now throttled to 300 ms.
                        self.triggerChangeThrottledObject = throttle( $.proxy( self.triggerChangeEvent, self ), 300 );

                        if( self.instance ) {
                            self.setupEventHandlers();
                            self.setupSave();
                            self.setupCursorGuard();
                            self.setupSelectionQuard();
                            self.setupAssetWidget();
                            self.setupInsert();
                            self.registerSwiftyEditorAssets();
                            self.fillForceShortcodeCloseTags();
                        }
                    } );
                } );
            },

            createEditor: function( $element ) {
                var self  = this;

                var ckeOptions = {
                    'toolbar': [
                        [
                            'Cut', 'Copy', 'Paste', 'PasteText', 'PasteFromWord', 'Bold', 'Italic', 'Underline',
                            'Strike', 'RemoveFormat', 'NumberedList', 'BulletedList', 'Outdent', 'Indent',
                            'JustifyLeft', 'JustifyCenter', 'JustifyRight', 'JustifyBlock'
                        ],
                        '/',
                        [
                            'Format', 'Font', 'FontSize', 'TextColor', 'BGColor', 'Link', 'Unlink',
                            'Undo', 'Redo', 'Table', 'Smiley', 'SpecialChar', 'HideEditor'
                        ]
                    ],
                    'format_tags': 'p;h1;h2;h3;h4;h5;h6',
                    'language': scc_data.locale,
                    'title': false,
                    'extraPlugins': 'swc_asset,swc_text,swc_grid_row,swc_grid_column,swc_image,uploadimage',
                    'imageUploadUrl': scc_data.swifty_upload_url,
                    // Add 'contextmenu,tabletools' if you want to (temporary) remove the right mouse context menu
                    'removePlugins': 'tab,liststyle,magicline,forms,scayt,wsc,image',
                    'undoStackSize': 50, // 20 = default, 50 = what we want
                    'baseFloatZIndex': 10000,
                    'allowedContent': true,
                    'enterMode': CKEDITOR.ENTER_P,   // this is the default
                    'font_names': 'Arial/Arial, Helvetica, sans-serif;' +
                    'Courier New/Courier New, Courier, monospace;' +
                    'Georgia/Georgia, serif;' +
                    'Lucida Sans Unicode/Lucida Sans Unicode, Lucida Grande, sans-serif;' +
                    'Times New Roman/Times New Roman, Times, serif;' +
                    'Trebuchet MS/Trebuchet MS, Helvetica, sans-serif;' +
                    'Verdana/Verdana, Geneva, sans-serif',
                    'resize_enabled': false,
                    'entities_latin': false,
                    'entities_greek': false,
                    'entities': false,
                    'basicEntities': false
                };

                // if( scc_data && scc_data.area && scc_data.area === 'main' ) {
                    ckeOptions.font_names += ';';
                    self.googleFonts.each( function( fontGroup, ky ) {
                        var kind = ky;
                        var alt = '';
                        if( ky === 'sans' ) {
                            kind = 'Google sans serif';
                            alt = 'sans-serif';
                        }
                        if( ky === 'serif' ) {
                            kind = 'Google serif';
                            alt = 'serif';
                        }
                        if( ky === 'special' ) {
                            kind = 'Google special';
                            alt = 'monospace';
                        }
                        $.each( fontGroup, function( ii, font ) {
                            ckeOptions.font_names += kind + ': ' + font + '/' + font + ', ' + alt + ';'
                        } );
                    } );
                // }

                return $element.ckeditor( ckeOptions );
            },

            showStartUpTooltip: function() {
                if( this.tooltip ) {
                    this.destroySingle( 'tooltip' );
                }

                this.tooltip = this.setupTooltip();
                this.tooltip.open();
            },

            setupTooltip: function() {
                return new JBox( 'Tooltip', {
                    'content': __( 'Start typing here or add content<br> by using the button at the bottom.' ),
                    'target': $( '.swc_page_cntnt.cke_editable p br' ),
                    'reposition': true,
                    'position': {
                        'x': 'right',
                        'y': 'left'
                    },
                    'closeOnClick': true,
                    'outside': 'x',
                    'offset': {
                        'x': 16,
                        'y': 10
                    }
                } );
            },

            onPluginsLoadedHandler: function( ev ) {
                var self = this;

                ev.editor.addCommand && ev.editor.addCommand( 'hideEditor', {
                    'exec': function( /*editor*/ ) {
                        self.setEditorVisibilityByAjax( 0 );
                    }
                } );

                ev.editor.ui.addButton && ev.editor.ui.addButton( 'HideEditor', {
                    'label': __( 'Show editor on text selection' ),
                    'command': 'hideEditor',
                    'icon': scc_data.ckeditor_path + 'images/x.png'
                } );

                ev.editor.commands.hideEditor.disable();
            },

            // When you click outside the editor, for instance on a button in a panel, the editor would lose focus.
            // This handler makes sure the foucus is restored.
            // While an edit panel is opened, this handler is temp disabled via swifty_editor_set_focus,
            // so the edit fields in that edit panel can get focus.

            onBlurHandler: function( ev ) {
                var self = this;

                if( self.sticky_editor ) {
                    if( self.set_focus ) {
                        // var focusManager = new CKEDITOR.focusManager( ev.editor );
                        // focusManager.focus();
                        ev.editor.focus();
                    }
                } else {
                    if( self.set_focus ) {
                        // var focusManager = new CKEDITOR.focusManager( ev.editor );
                        // focusManager.focus();
                        ev.editor.focus();

                        self.toggleToolbarVisibility( self.isTextSelection() );

                        setTimeout( function() {
                            var selectedWidget = $( '.cke_widget_selected' );

                            if( selectedWidget.length === 1 ) {
                                self.setWidgetFocus( { '$asset': selectedWidget.find( '.swc_asset,.swc_text,.swc_grid_row' ) }, true );
                            }
                        }, 1 );
                    } else {
                        if( self.isTextSelection() ) {
                            self.resetSelection();
                            self.toggleToolbarVisibility( false );
                        }
                    }
                }
            },

            onContentDomHandler: function( ev ) {
                var self = this;
                var commands = ev.editor.commands;

                commands.hideEditor && commands.hideEditor[ self.sticky_editor ? 'enable' : 'disable' ]();

                $.each( [ 'mousedown', 'mouseup', 'keyup', 'touchend' ], function( index, eventName ) {
                    var editable = ev.editor.editable();

                    editable.attachListener( editable, eventName, self.onMouseKeyTouchHandler, self );
                } );
            },

            onMouseKeyTouchHandler: function( ev ) {
                var self = this;
                var eventName = ev.name.toLowerCase();

                if( !self.sticky_editor ) {
                    if( eventName === 'mousedown' ) {
                        // the next line was commented because it disables the doubleclick selection in IE
                        // it was introduced to keep the selection when clicking a selection
                        //self.resetSelection();
                        self.mouse_down_state = true;
                    } else {
                        if( eventName === 'mouseup' ) {
                            self.mouse_down_state = false;
                        }

                        self.setEditorVisibility();

                    }
                }
                if( eventName === 'keyup' ) {
                    self.destroySingle( 'tooltip' );

                    // This fix will prevent multiple pastes when CTRL+V is hold down a bit longer.
                    // self.pasteOccured is a CanJS Compute and the change handler is located in
                    // ckeditor_helper_setup_event_handler.js
                    if ( ev.data.getKeystroke() === 1114198 ) {   // 1114198 -> CTRL+V
                        self.pasteOccured( null );
                    }
                }
            },

            setEditorVisibilityByAjax: function( showIt ) {
                var self = this;
                var dfd = new $.Deferred();

                if( !showIt ) {
                    // calculate the start position for the animation
                    var $editor = $( '#cke_editor1' );
                    if( $editor.length === 1 ) {

                        var offset = $editor.offset();
                        var posX = offset.left;
                        var posY = 0;

                        if( $editor.css( 'position' ) === 'absolute' ) {
                            posY = offset.top - $( window ).scrollTop();
                        }

                        var position_start = {
                            'top': posY + 'px',
                            'left': posX + 'px',
                            'width': $editor.css( 'width' ),
                            'height': $editor.css( 'height' ),
                            'opacity': 0,
                            'background': '#f0f0f0',
                            'position': 'fixed',
                            'z-index': 10001
                        };

                        evt( 'editor_toolbar_minimize', { 'position_start': position_start } );
                    }
                }

                self.sticky_editor = showIt;
                self.toggleToolbarVisibility( showIt );

                evt( 'set_editor_visibility_state', {
                    'show_it': showIt
                } );

                self.instance.fire( 'contentDom' );

                $.post(
                    scc_data.ajax_url,
                    {
                        'action': 'set_editor_visibility',
                        'show_it': showIt,
                        'id': scc_data.page_id,
                        'ajax_nonce': scc_data.ajax_nonce
                    }
                );

                dfd.resolve( showIt );

                return dfd;
            },

            setEditorVisibility: function() {
                var self = this;

                this.toggleToolbarVisibility( this.isTextSelection() );

                setTimeout( function() {
                    self.resetPanelStack();
                }, 1 );
            },

            toggleToolbarVisibility: function( visible ) {
                var self = this;

                if( visible ) {
                    setTimeout( function() {
                        self.$toolbar.parent().show();
                        self.$toolbar.show();

                        // CKEditor toolbar is not positioned correctly when a scroll occurred before the toolbar
                        // becomes visible. Here we reposition the toolbar.
                        self.repositionToolbar();
                    }, 1 );
                } else {
                    self.$toolbar.parent().hide();
                    self.$toolbar.hide();
                }
            },

            resetSelection: function() {
                this.instance.getSelection().removeAllRanges();
            },

            resetPanelStack: function() {
                var selection = this.instance.getSelection();
                var doReset = false;
                var focusedEl = $( '.cke_widget_focused' );
                var selectedEl, isWidget;

                if( selection ) {
                    if( this.$asset_in_edit_mode ) {
                        selectedEl = selection.getSelectedElement();
                        isWidget = this.isWidgetElement( selectedEl );

                        if( !isWidget ) {
                            focusedEl.removeClass( 'cke_widget_focused' );
                            doReset = true;
                        } else if(
                            isWidget && ( +isWidget !== +this.getWidgetIdAssetBased( this.$asset_in_edit_mode ) )
                        ) {
                            if( focusedEl && focusedEl.length > 1 ) {
                                focusedEl.not( $( selectedEl.$ ) ).each( function() {
                                    $( this ).removeClass( 'cke_widget_focused' );
                                } );
                            }

                            doReset = true;
                        }

                        if( doReset ) {
                            this.$asset_in_edit_mode = null;
                            this.set_focus = 1;
                            this.setAssetEditIconVisibility( true );
                            evt( 'reset_panel_stack' );
                        }
                    }
                }
            },

            isTextSelection: function() {
                var selection = this.instance.getSelection();
                var range, text;

                if( selection ) {
                    range = selection.getRanges()[ 0 ];
                    text = $.trim( selection.getSelectedText() );

                    // Unlock the selection, otherwise no changes can be done to de selection
                    this.unlockSelection();

                    if( !range ) {
                        selection = this.instance.getSelection();
                        range = selection.getRanges()[ 0 ];
                        text = $.trim( selection.getSelectedText() );
                    }

                    return ( range && text && text.length > 0 ) ? true : false;
                } else {
                    return false;
                }
            },

            unlockSelection: function( opts ) {
                var self = this;

                self.instance.unlockSelection();

                setTimeout( function() {
                    // $asset is only set when the edit panel is visible
                    if( opts && opts.$asset ) {
                        self.setWidgetFocus( opts, true );
                    }
                }, 1 );
            },

            repositionToolbar: function() {
                var $editor = $( '#cke_' + this.instance.name );
                var $article = $( this.instance.element.$ );

                if( this.$toolbar.offset().top === $article.offset().top ) {
                    $editor.css(
                        'top',
                        $editor.position().top - $editor.height()
                    );
                }

                if( this.$toolbar.offset().top < $( window ).scrollTop() ) {
                    $editor.css(
                        'top',
                        $editor.position().top + $editor.height() + $article.outerHeight( true )
                    );
                }
            },

            isContentElement: function( node ) {
                return node && node.equals( this.getContentElement() );
            },

            getContentElement: function() {
                return this.instance && this.instance.element;
            },

            isParagraphElement: function( node ) {
                return ( node && node.type === 1 && ( node.is( 'p' ) || node.is( 'div' ) ) && !this.isWidgetElement( node ) );
            },

            getParagraphElement: function( node ) {
                var self = this;

                if( !self.isContentElement( node ) ) {
                    return node.getAscendant( function( el ) {
                        if( self.isParagraphElement( el ) ) {
                            return el;
                        }
                    }, true );   // includeSelf set to true.
                }
            },

            /**
             * get list of paragraphs and widgets, ignore paragraphs in widgets and accepts only widgets containing asset
             *
             * @returns {CKEDITOR.dom.nodeList}
             */
            getParagraphAndWidgetElements: function() {
                var list = $( this.getContentElement().$ ).find( 'div.cke_widget_wrapper, p:not("div.swc_asset p,div.swc_text p")' );
                list = list.filter( 'p, div:has( > .swc_asset), div:has( > .swc_text)' );

                return new CKEDITOR.dom.nodeList( list.get() );
            },

            /**
             * get list of paragraphs and rows in root of content
             *
             * @returns {CKEDITOR.dom.nodeList}
             */
            getParagraphAndRowElements: function() {
                var list = $( this.getContentElement().$ ).children( 'div.cke_widget_wrapper, p' );
                return new CKEDITOR.dom.nodeList( list.get() );
            },

            getRootElements: function( node ) {
                var list;

                if( node && this.isTextAsset( node ) ) {
                    list = $( node.$ ).find( '.swc_asset_cntnt > p, .swc_asset_cntnt > div.cke_widget_wrapper' );
                } else if( node && this.isGridColumn( node ) ) {
                    list = $( node.$ ).children( 'div.cke_widget_wrapper' );
                } else {
                    list = $( this.getContentElement().$ ).children();
                }

                return new CKEDITOR.dom.nodeList( list.get() );
            },

            isTextAsset: function( node ) {
                if( node && node.type === 1 ) {
                    if( node.hasClass( 'swc_text' ) ) {
                        return true;
                    }

                    if( node.hasClass( 'cke_widget_wrapper' ) ) {
                        var firstNode = node.getChild( 0 );

                        return firstNode.hasClass( 'swc_text' );
                    }
                }

                return false;
            },

            isGridColumn: function( node ) {
                return ( node && node.type === 1 && node.hasClass( 'swc_grid_column' ) );
            },

            getGridRows: function() {
                var list = $( this.getContentElement().$ ).children().children( '.swc_grid_row' );

                return new CKEDITOR.dom.nodeList( list.get() );
            },

            getGridColumnsFromRow: function( rowNode ) {
                var list = $( rowNode.$ ).find( '.swc_grid_column' );

                return new CKEDITOR.dom.nodeList( list.get() );
            },

            isCurrentInsertPositionInTableOrGrid: function() {
                var self = this;

                var range = self.instance.getSelection().getRanges()[ 0 ];
                if( range ) {
                    if( self.getAscendantTextAsset( range.startContainer ) ) {
                        return false;
                    }
                    if( self.getTableOrGrid( range.startContainer ) ) {
                        return true;
                    }
                }
                return false;
            },

            isCurrentInsertPositionInWidget: function() {
                var self = this;
                var range = self.instance.getSelection().getRanges()[ 0 ];
                if( range ) {
                    if( self.getClosestWidget( range.startContainer ) ) {
                        return true;
                    }
                }
                return false;
            },

            isCurrentInsertPositionInAsset: function() {
                var self = this;
                var range = self.instance.getSelection().getRanges()[ 0 ];
                if( range && range.startContainer ) {
                    if( range.startContainer.getAscendant( function( el ) {
                            if( el.type === 1 && ( ( el.getName() === 'div' ) && ( el.hasClass( 'swc_asset' ) /*|| el.hasClass( 'swc_text' )*/ ) ) ) {
                                return el;
                            }
                        }, true )    // includeSelf set to true, needed for empty divs.
                    ) {
                        return true;
                    }
                }
                return false;
            },

            appendHtmlToList: function( list, html ) {
                var self = this;

                var nrOfItems;

                // hack to remove fillingchar which causes an selection error when adding a asset to a column
                self.instance.fire( 'beforeSetMode' );

                if( list && ( nrOfItems = list.count() ) ) {
                    var lastNode = list.getItem( nrOfItems - 1 );
                    var range = self.instance.createRange();

                    range.setStartAfter( lastNode );
                    range.collapse( true );
                    range.select();

                    // hack to remove fillingchar which causes an selection error when adding a asset to a column
                    self.instance.fire( 'beforeSetMode' );
                    
                    try {
                        self.instance.insertHtml( html, range );
                    } catch( e ) {
                        // Sometimes setting the range after inserting HTML will fail. In this case we will simply continue
                        // with what is done next: calling this event
                        if( self.instance.getSelection().getRanges().length === 0 ) {
                            self.instance.fire( 'afterInsertHtml', {} );
                        } else {
                            throw e;
                        }
                    }
                } else {
                    try {
                        self.instance.insertHtml( html );
                    } catch( e ) {
                        // Sometimes setting the range after inserting HTML will fail. In this case we will simply continue
                        // with what is done next: calling this event
                        if( self.instance.getSelection().getRanges().length === 0 ) {
                            self.instance.fire( 'afterInsertHtml', {} );
                        } else {
                            throw e;
                        }
                    }
                }
            },

            appendHtmlToSelector: function( html ) {
                var self = this;

                $( self.attr( 'selector' ) ).attr( 'contenteditable', 'true' );

                var rootElements = self.getRootElements();

                self.appendHtmlToList( rootElements, html );

                // $( self.attr( 'selector' ) ).attr( 'contenteditable', 'false' );

                rootElements = self.getRootElements();

                return rootElements.getItem( rootElements.count() - 1 );
            },

            appendHtmlToColumn: function( $column, html ) {
                var self = this;

                $( self.attr( 'selector' ) ).attr( 'contenteditable', 'false' );
                $column.attr( 'contenteditable', 'true' );

                var elements = self.getRootElements( new CKEDITOR.dom.node( $column[0] ) );

                if( elements.count() === 0 ) {
                    var range = self.instance.createRange();

                    range.setStartAt( new CKEDITOR.dom.node( $column[0] ), CKEDITOR.POSITION_AFTER_START );
                    range.collapse( true );
                    range.select();
                }

                self.appendHtmlToList( elements, html );

                $column.attr( 'contenteditable', 'false' );
                $( self.attr( 'selector' ) ).attr( 'contenteditable', 'true' );
            },

            /**
             * Go to an editable position within the $column
             *
             * @param $column
             */
            setColumnRangeForInsert: function( $column ) {
                var self = this;

                // var focusManager = new CKEDITOR.focusManager( self.instance );
                // focusManager.focus();
                self.instance.focus();

                var range = self.instance.createRange();
                range.moveToElementEditablePosition( new CKEDITOR.dom.node( $column[0].firstChild ), 1 );
                range.select();
            },

            setParagraphRangeForInsert: function( $p ) {
                var self = this;

                // var focusManager = new CKEDITOR.focusManager( self.instance );
                // focusManager.focus();
                self.instance.focus();

                var range = self.instance.createRange();
                range.moveToElementEditablePosition( new CKEDITOR.dom.node( $p[0] ), 1 );
                range.select();
            },

            setAssetInsertPosition: function( only_insert_at_root, force_html_insert ) {
                var self = this;

                var selection = self.instance.getSelection();
                var selectedEl = selection.getSelectedElement();
                var range = selection.getRanges()[ 0 ];
                var startContainer = null;

                // No range found. We create one and set the cursor in the first paragraph.
                if( ! range ) {
                    range = self.instance.createRange();
                    range.moveToElementEditablePosition( self.getContentElement().find( 'p' ).getItem( 0 ), false );
                    self.instance.getSelection().selectRanges( [ range ] );
                }

                // Never insert inside other (text)asset.
                if( only_insert_at_root || self.isCurrentInsertPositionInAsset() ) {
                    // is current position within table or columns?
                    startContainer = range.startContainer;
                    var containingTableOrGrid = self.getTableOrGrid( startContainer );
                    if( containingTableOrGrid ) {
                        // find top table or columns in hierarchy
                        while( containingTableOrGrid ) {
                            startContainer = containingTableOrGrid;
                            containingTableOrGrid = self.getTableOrGrid( startContainer.getParent() );
                        }
                        // get the container of the row, this container will be in the self.getRootElements()
                        if( startContainer.hasClass( 'swc_grid_row' ) ) {
                            startContainer = startContainer.getParent();
                        }

                        var items = self.getRootElements();
                        var nrOfItems = items.count();

                        if( nrOfItems > 1 ) {   // More than one first level elements
                            // find location of this top element, and move just before it
                            var curPos = self.getCurPos( startContainer, items );
                            startContainer = items.getItem( Math.max( 0, curPos - 1 ) );
                            if( ( force_html_insert ) || ! self.isWidgetElement( startContainer ) ) {
                                range.moveToPosition( startContainer, CKEDITOR.POSITION_BEFORE_START );
                                range.select();
                                return null;
                            } else {
                                return startContainer;
                            }
                        }
                    }
                }

                // A widget is selected.
                if( self.isWidgetElement( selectedEl ) ) {
                    if( force_html_insert ) {
                        range.moveToPosition( paragraphEl, CKEDITOR.POSITION_BEFORE_START );
                    } else {
                        return selectedEl;
                    }
                } else {
                    startContainer = range.startContainer;
                    var table = self.getTableOrRowOrCell( startContainer, 'table' );

                    if( table ) {
                        self.moveToPositionInTable( range, table );
                    } else {
                        var paragraphEl = self.getParagraphElement( startContainer );

                        if( paragraphEl ) {
                            if( force_html_insert ) {
                                range.moveToPosition( paragraphEl, CKEDITOR.POSITION_BEFORE_START );
                            } else {
                                return paragraphEl;
                            }
                        } else {
                            range.moveToPosition( self.getContentElement(), CKEDITOR.POSITION_AFTER_START );
                        }
                    }
                }

                range.select();
                return null;
            },

            moveToPositionInTable: function( range, table ) {
                var tableCell = this.getTableOrRowOrCell( range.startContainer, 'td' );

                if( tableCell.getName() === 'td' ) {
                    range.moveToPosition( tableCell, CKEDITOR.POSITION_AFTER_START );
                } else {
                    range.moveToPosition( table, CKEDITOR.POSITION_BEFORE_START );
                }
            },

            registerSwiftyEditorAssets: function() {
                evt( 'register_swifty_editor_assets', { 'assets': [
                    //{ 'category': 'textual', 'action': 'smiley', 'order': '10','icon': '&#xe04a;', 'name': __( 'Smiley' ) },
                    //{ 'category': 'textual', 'action': 'specialchar', 'order': '20', 'icon': '&#xe04b;', 'name': __( 'Special character' ) },
                    //{ 'category': 'textual', 'action': 'horizontalrule', 'order': '40', 'icon': '&#xe046;', 'name': __( 'Horizontal rule' ) },
                    //{ 'category': 'interactive', 'action': 'anchor', 'order': '990', 'icon': '&#xe045;', 'name': __( 'Anchor tag' ) },
                    //{ 'category': 'clipboard', 'action': 'paste', 'order': '10', 'icon': '&#xe047;', 'name': __( 'Paste' ) },
                    //{ 'category': 'clipboard', 'action': 'pastefromword', 'order': '20', 'icon': '&#xe048;', 'name': __( 'Paste from Word' ) },
                    //{ 'category': 'clipboard', 'action': 'pastetext', 'order': '20', 'icon': '&#xe049;', 'name': __( 'Paste as text' ) },
                    //{ 'category': 'layout', 'action': 'table', 'order': '200', 'icon': '&#xe04c;', 'name': __( 'Table' ) }
                ] } );
            },

            /**
             *  Fill the member forceShortcodeCloseTags with shortcode and force_close_tag combinations.
             */
            fillForceShortcodeCloseTags: function() {
                var self = this;

                evt( 'get_asset_force_close_tags' ).then( function( data ) {
                    self.forceShortcodeCloseTags = data;
                } );
            },

            /**
             * After a triple click the selection could be extended beyond the current paragraph into the next widget
             * causing a lot of trouble when deleting / changing styles. This event will check if the current selection
             * is bigger than 1 area with editablecontent and make sure to shrink the selection range to only 1 paragraph
             */
            setupSelectionQuard: function() {
                var self = this;

                this.instance.on( 'selectionCheck', function( evt ) {

                    // ignore fake selections
                    if( evt.data && evt.data && evt.data.isFake ) {
                        return true;
                    }

                    var ranges = evt.data.getRanges();

                    if( ranges && ranges.length === 1 ) {

                        var range = ranges[0];

                        // This check has only meaning when not collapsed and the end container is in the start of a element.
                        if( ! range.collapsed && ( range.endOffset === 0 ) && ( range.endContainer instanceof CKEDITOR.dom.element ) ) {
                            var walker = new CKEDITOR.dom.walker( range ),
                                nodes = [],
                                node;

                            while( node = walker.next() ) {
                                nodes.push( node );
                            }

                            var container, crosses;

                            // Check if the closest parents of each node are all the same editable element.
                            // If not, the range crosses editable boundaries one way or another.
                            OuterLoop:
                                for( var i = 0; i < nodes.length; i ++ ) {
                                    var parents = nodes[i].getParents( ! ! 'closest first' );

                                    parents.shift();

                                    for( var j = 0; j < parents.length; j ++ ) {
                                        if( parents[j].getAttribute( 'contenteditable' ) === 'true' ) {
                                            if( ! container ) {
                                                container = parents[j]; // i == 0
                                                break;
                                            } else {
                                                if( ! parents[j].equals( container ) ) {
                                                    crosses = true;
                                                    node = nodes[i - 1]; // i > 0
                                                    break OuterLoop;
                                                }
                                            }
                                        }
                                    }
                                }

                            if( crosses ) {
                                range.setEndAfter( range.startContainer );
                                self.instance.getSelection().selectRanges( [range] );
                            }
                        }
                        return true;
                    }
                } );
            },

            setupCursorGuard: function() {
                var self = this;

                self.instance.on( 'selectionChange', function( evt ) {
                    // ignore fake selections
                    if( evt.data && evt.data.selection && evt.data.selection.isFake ) {
                        return true;
                    }
                    if( self.swifty_insert_content ) {
                        return true;
                    }

                    var elementsList = [],
                        isContentEditable = true,
                        // Use elementPath to consider children of editable only (#11124).
                        elementsChain = self.instance.elementPath().elements;

                    // Starts iteration from body element, skipping html.
                    for( var j = elementsChain.length; j --; ) {
                        var element = elementsChain[j],
                            ignore = 0;

                        isContentEditable =
                            element.hasAttribute( 'contenteditable' ) ?
                            element.getAttribute( 'contenteditable' ) === 'true' : isContentEditable;

                        // // If elem is non-contenteditable, and it's not specifying contenteditable
                        // // attribute - then elem should be ignored.
                        // if( ! isContentEditable && ! element.hasAttribute( 'contenteditable' ) )
                        //     ignore = 1;

                        if( ! ignore ) {
                            elementsList.unshift( element );
                        }
                    }

                    var in_editable_area = false;
                    for( var w = 0; w < elementsList.length; w ++ ) {
                        var currentElement = elementsList[w];

                        // Sometimes a non content element is selected, catch them and return selection to editable area.
                        if( w === 0 ) {
                            // Could change to switch.
                            if( currentElement.getName() === 'tbody' ) {
                                in_editable_area = false;
                                break;
                            }

                            if( currentElement.getName() === 'tr' ) {
                                in_editable_area = false;
                                break;
                            }

                            // ignore this selection when it is hidden (used when loosing focus)
                            if( currentElement.hasAttribute( 'data-cke-hidden-sel' ) ) {
                                return true;
                            }
                        }

                        // // If selection is inside a non-editable element, break from loop and reset selection.
                        // if( currentElement.hasClass( 'swifty_not_editable' ) ) {
                        //     in_editable_area = false;
                        //     break;
                        // }

                        if( currentElement.hasClass( 'swc_locked' ) ) {
                            in_editable_area = false;
                            break;
                        }

                        // if( currentElement.hasClass( 'swifty_editable' ) ) {
                        //     in_editable_area = true;
                        // }

                        // Is this the editable of a text asset?
                        if( currentElement.hasClass( 'swc_asset_cntnt' ) && currentElement.getParent().hasClass( 'swc_text' ) ) {
                            in_editable_area = true;
                        }
                    }

                    if( ! in_editable_area ) {
                        var $newLocation = self.getContentElement().find( '.swc_text > .swc_asset_cntnt p' );
                        if( $newLocation.length > 0 ) {
                            self.instance.getSelection().removeAllRanges();

                            var range = self.instance.createRange();
                            range.moveToElementEditablePosition( $newLocation.getItem( 0 ), false );
                            self.instance.getSelection().selectRanges( [ range ] );
                            return false;
                        }
                    }

                } );
            },

            setupSave: function() {
                var self = this;

                // If anything changes send out an event
                self.instance.on( 'change', function( ev ) {

                    // make sure this icon is not saved with content
                    $( '.swc_asset_plus_icon_wrapper' ).remove();

                    // Outcommented this code because table element is moved back to the CKE toolbar.
                    // $( '.swc_table_edit_button' ).remove();

                    $( '.swc_asset_resizer_icon_wrapper' ).remove();
                    $( '.swc_asset_cog_icon_wrapper, .swc_asset_any_icon_wrapper, .swc_asset_adv_icons_wrapper' ).remove();
                    self.removeRefreshSpinner();

                    var html = ev.editor.getData();

                    evt(
                        'swifty_editor_content_changed',
                        {
                            'content': html
                        }
                    );

                    evt( 'check_can_undo_redo' );
                } );

                // Receive incoming content change events
                can.bind.call( window, 'evt_swc_swifty_editor_set_new_content', function( ev, opts ) {
                    self.instance.setData( opts.content );
                    evt( 'add_exec', { 'fn': 'swifty_check_inserts' } );
                    if( opts.dfd ) {
                        opts.dfd.resolve();
                    }
                } );

                // Handle save requests
                can.bind.call( window, 'evt_swc_swifty_editor_trigger_save', function( /*ev, opts*/ ) {
                    self.triggerChangeThrottledObject();
                } );
            },

            triggerChangeEvent: function() {
                this.instance.fire( 'change' );
            },

            addRefreshSpinner: function( opts ) {
                $( opts.container ).prepend( '<span class="swc_asset_refreshing"><i class="fa fa-refresh fa-spin"></i></span>' );
            },

            removeRefreshSpinner: function() {
                $( '.swc_asset_refreshing' ).remove();
            },

            contentModfied: function() {
                this.instance.fire( 'change' );
            },

            setupWidgetKeyDeletion: function( widget ) {
                widget.on( 'key', function( evt ) {
                    switch( evt.data.keyCode ) {
                        case 8:
                        case 46:
                            evt.cancel();
                            evt.stop();
                    }
                } );
            },

            setFocus: function( opts ) {
                if( !opts ) {
                    return;
                }

                this.set_focus = opts.focus;
            },

            openEditAfterInsert: function( $element, inline, initCss ) {
                if( $( $element ).hasClass( 'swc_asset_state_ins_updating' ) ) {
                    $( $element ).removeClass( 'swc_asset_state_ins_updating' );

                    // Open the asset panel
                    evt(
                        'swifty_editor_asset_dialog',
                        {
                            'el': $( $element ),
                            'mod': 'added_new',
                            'inline': inline,
                            'init_css': initCss
                        }
                    );
                }
            },

            setAssetEditIconVisibility: function( visible ) {
                $( '.cke_widget_drag_handler_container' )[
                    visible ? 'removeClass' : 'addClass'
                ]( 'swc_hide_asset_icon' );
                $( '.cke_widget_wrapper .cke_widget_element' )[
                    visible ? 'removeClass' : 'addClass'
                    ]( 'swc_hide_outline' );
            },

            /**
             * get the table or row, the returned node tells if current node is located in a table or grid even when nested
             *
             * @param node
             * @returns {*|CKEDITOR.dom.node|CKEDITOR.htmlParser.element}
             */
            getTableOrGrid: function( node ) {
                return node.getAscendant( function( el ) {
                    if( el.type === 1 && ( ( el.getName() === 'table' ) ||
                        ( ( el.getName() === 'div' ) && el.hasClass( 'swc_grid_row' ) ) ||
                        ( ( el.getName() === 'div' ) && el.hasClass( 'swc_grid_column' ) ) ) ) {
                        return el;
                    }
                }, true );   // includeSelf set to true, needed for empty divs.
            },

            getAscendantTextAsset: function( node ) {
                return node.getAscendant( function( el ) {
                    if( el.type === 1 && (
                        ( ( el.getName() === 'div' ) && el.hasClass( 'swc_text' ) ) ) ) {
                        return el;
                    }
                }, true );   // includeSelf set to true, needed for empty divs.
            },

            getTableOrRowOrCell: function( node, name ) {
                return node.getAscendant( function( el ) {
                    if( el.type === 1 && el.getName() === name ) {
                        return el;
                    }
                }, true );   // includeSelf set to true, needed for empty divs.
            },

            /**
             * get the row or column div in which this node lives
             *
             * @param node
             * @param name 'swc_grid_column' or 'swc_grid_row'
             * @returns {*|CKEDITOR.dom.node|CKEDITOR.htmlParser.element}
             */
            getGridRowOrColumn: function( node, name ) {
                return node.getAscendant( function( el ) {
                    if( el.type === 1 && ( el.getName() === 'div' ) && el.hasClass( name ) ) {
                        return el;
                    }
                }, true );   // includeSelf set to true, needed for empty divs.
            },

            /**
             * return index of curItem in items
             *
             * @param curItem
             * @param items
             * @returns {number}
             */
            getCurPos: function( curItem, items ) {
                for( var i = 0, len = items.count(); i < len; i++ ) {
                    if( curItem.equals( items.getItem( i ) ) ) {
                        return i;
                    }
                }
            },

            getNewPos: function( move, curPos ) {
                return ( move === 'up' || move === 'left' ) ? curPos - 1 : curPos + 1;
            },

            /**
             * get the widget, the returned node tells if current node is located in a block widget even when nested
             *
             * @param node
             * @returns {*|CKEDITOR.dom.node|CKEDITOR.htmlParser.element}
             */
            getClosestWidget: function( node ) {
                return node.getAscendant( function( el ) {
                    if( el.type === 1 && ( ( el.getName() === 'div' ) && el.hasClass( 'cke_widget_element' ) ) ) {
                        return el;
                    }
                }, true );   // includeSelf set to true, needed for empty divs.
            },

            moveRow: function( opts ) {
                if( ! opts ) {
                    return;
                }

                var curWidgetObj = this.getWidget( this.getWidgetIdAssetBased( opts.$row ) );
                var curWidget = curWidgetObj.wrapper;

                if( curWidget && opts.move ) {
                    switch( opts.move ) {
                        case 'up':
                        case 'down':

                            var items = this.getParagraphAndRowElements();   // NodeList of P and widget elements.
                            var nrOfItems = items.count();

                            if( nrOfItems > 1 ) {   // More than one first level elements
                                var curPos = this.getCurPos( curWidget, items );

                                if( ( opts.move === 'up' && curPos > 0 ) ||
                                    ( opts.move === 'down' && curPos < nrOfItems - 1 )
                                ) {
                                    var newPos = this.getNewPos( opts.move, curPos );

                                    curWidget[ opts.move === 'up' ? 'insertBefore' : 'insertAfter' ](
                                        items.getItem( newPos )
                                    );
                                } else if ( opts.move === 'up' && curPos === 0 ) {
                                    // put at the top of the page
                                    curWidget.move( this.getContentElement(), true );
                                } else if ( opts.move === 'down' && curPos === nrOfItems - 1 ) {
                                    // put at the bottom of the page
                                    curWidget.move( this.getContentElement(), false );
                                }
                            }

                            break;
                        default:
                            return;
                    }

                    curWidget.scrollIntoView();

                    this.contentModfied();
                }
            },

            insertPAsset: function( opts ) {
                if( ! opts ) {
                    return;
                }

                var curWidgetObj = this.getWidget( this.getWidgetIdAssetBased( opts.$asset ) );
                var curWidget = curWidgetObj.wrapper;

                if( curWidget && opts.action ) {
                    // use the nbsp to allow editing below a asset, otherwise it is shown behind the asset when inserting
                    var p = CKEDITOR.dom.element.createFromHtml( '<p>&nbsp;</p>' );
                    p[opts.action === 'above' ? 'insertBefore' : 'insertAfter']( curWidget );

                    this.contentModfied();
                }
            },

            triggerSetPositionEvent: function( el, position ) {
                evt(
                    'swifty_editor_set_position',
                    {
                        'position': position,
                        'el': el
                    }
                );
            },

            moveInsideItemWithWidgets: function( move, widget, newPos, items ) {
                widget[ move === 'left' ? 'insertBefore' : 'insertAfter' ](
                    items.getItem( newPos )
                );
            },

            /**
             * move widget(node) to the end of another column
             *
             * @param move
             * @param widget
             * @param newPos
             * @param items
             */
            moveToNewColum: function( move, widget, newPos, items ) {
                var newColumn = items.getItem( newPos );
                widget.move( newColumn, false ); // use true to put at start of column
            },

            moveToItemWithWidgets: function( move, widget, newPos, items ) {
                var newCell = items.getItem( newPos );
                var widgetsInNewCell = newCell.find( '.cke_widget_wrapper' );
                var nrOfWidgetsInNewCell = widgetsInNewCell.count();

                if( nrOfWidgetsInNewCell ) {
                    newPos = move === 'left' ? nrOfWidgetsInNewCell - 1 : 0;

                    widget[ move === 'left' ? 'insertAfter' : 'insertBefore' ](
                        widgetsInNewCell.getItem( newPos )
                    );
                } else {
                    widget.move( newCell, true );
                }
            },

            setCursor: function( opts ) {
                var $assetEl, $asset, widgetId, widget;

                if( opts && opts.$asset ) {
                    $asset = opts.$asset;
                } else {   // yes-no panel doesn't know about the asset.
                    $assetEl = $( '.cke_widget_selected' ).find( '.swc_asset,.swc_text,.swc_grid_row' );

                    if( $assetEl.length ) {
                        $asset = $assetEl;
                    }
                }

                if( $asset && $asset.length ) {
                    widgetId = this.getWidgetIdAssetBased( $asset );
                    widget = this.getWidget( widgetId );

                    if( widget ) {
                        this.setWidgetFocus( { '$asset': $asset }, false );
                        this.moveCursorToClosestEditableElement( widget.wrapper, widget.inline );
                    }
                }
            },

            moveCursorToClosestEditableElement: function( node, inline ) {
                var table = this.getTableOrRowOrCell( node, 'table' );
                var range = this.instance.createRange();
                var editableEl = null;

                if( inline ) {
                    editableEl = node;
                } else {
                    if( table ) {
                        var allCells = table.find( 'td' );

                        for( var i = 0, cellLen = allCells.count(); i < cellLen; i++ ) {
                            var cell = allCells.getItem( i );
                            var children = cell.getChildren();

                            for( var k = 0, childLen = children.count(); k < childLen; k++ ) {
                                var child = children.getItem( k );

                                // Text or BR node
                                if( child.type === 3 || ( child.type === 1 && child.is( 'br' ) ) ) {
                                    editableEl = child;
                                    break;
                                }
                            }

                            if( editableEl ) {
                                break;
                            }
                        }

                        if( !editableEl ) {
                            editableEl = this.getEditableElement( table );
                        }
                    } else {
                        editableEl = this.getEditableElement( node );
                    }
                }

                range.moveToElementEditablePosition(
                    editableEl || this.getContentElement(),
                    inline  // isMoveToEnd -> true or false
                );

                this.instance.getSelection().selectRanges( [ range ] );
            },

            getEditableElement: function( node ) {
                var pAndWidgetElements = this.getParagraphAndWidgetElements();   // NodeList of P and widget elements.
                var curPos = this.getCurPos( node, pAndWidgetElements );
                var editableEl = null;
                var el;

                if( curPos >= 0 ) {
                    for( var i = curPos, len = pAndWidgetElements.count(); i < len; i++ ) {
                        el = pAndWidgetElements.getItem( i );

                        if( this.isParagraphElement( el ) ) {
                            editableEl = el;
                            break;
                        }
                    }

                    if( !editableEl ) {
                        for( var j = curPos; j >= 0; j-- ) {
                            el = pAndWidgetElements.getItem( j );

                            if( this.isParagraphElement( el ) ) {
                                editableEl = el;
                                break;
                            }
                        }
                    }
                }

                return editableEl;
            },

            isWidgetElement: function( node ) {
                return ( node && node.type === 1 && node.hasAttribute( 'data-cke-widget-id' ) ) ?
                    node.getAttribute( 'data-cke-widget-id' ) :
                    null;
            },

            getWidget: function( widgetId ) {
                var widgets = this.instance.widgets;
                var curWidgetArr = $.map( widgets.instances, function( widgetInstance /*, k*/ ) {
                    // widgetId can be a number or a string, so we do a typecast.
                    if( widgetInstance.id === +widgetId ) {
                        return widgetInstance;
                    }
                } );

                return curWidgetArr && curWidgetArr.length === 1 ? curWidgetArr[ 0 ] : null;
            },

            getWidgetIdAssetBased: function( $asset ) {
                return $asset ? $asset.closest( '.cke_widget_wrapper' ).data( 'cke-widget-id' ) : null;
            },

            setWidgetFocus: function( opts, focus ) {
                var widgetId = this.getWidgetIdAssetBased( opts.$asset );
                var curWidgetObj = this.getWidget( widgetId );
                if( curWidgetObj ) {
                    var curWidget = curWidgetObj.wrapper;

                    curWidget && curWidget[ focus ? 'addClass' : 'removeClass' ]( 'cke_widget_focused' );
                }
            },

            setAssetInEditMode: function( opts ) {
                this.$asset_in_edit_mode = opts && opts.$asset;
                this.setAssetEditIconVisibility( this.$asset_in_edit_mode ? false : true );

                // all focus rectangles are hidden in setAssetEditIconVisibility, so get it back for the
                // active asset
                if( this.$asset_in_edit_mode ) {
                    this.$asset_in_edit_mode.removeClass( 'swc_hide_outline' );
                }
            },

            documentMouseUp: function() {
                if( !this.sticky_editor && this.mouse_down_state ) {
                    this.instance.fire( 'blur' );
                }
            },

            // Outcommented this code because table element is moved back to the CKE toolbar.
            // openTableProperties: function( opts ) {
            //     var tables = this.getContentElement().find( 'table' );
            //     var range;
            //
            //     for( var i = 0, len = tables.count(); i < len; i++ ) {
            //         var table = tables.getItem( i );
            //
            //         if( $( table.$ ).is( opts.$table ) ) {
            //             range = this.instance.createRange();
            //
            //             range.moveToElementEditablePosition( table, false );
            //
            //             this.instance.getSelection().selectRanges( [ range ] );
            //             this.instance.fire( 'doubleclick', { 'element': table } );
            //         }
            //     }
            // },

            destroySingle: function( key ) {
                if( this[ key ] ) {
                    this[ key ].destroy( true );
                    this[ key ] = null;
                }
            },

            destroyAll: function() {
                this.destroySingle( 'instance' );
                this.destroySingle( 'tooltip' );

                $( this.attr( 'selector' ) ).removeAttr( 'contenteditable' );
            },

            setWrappersHeight: function() {
                $( '.cke_widget_wrapper' ).each( function( index, element ) {
                    var $content = $( element ).find( '.swc_asset,.swc_text,.swc_grid_row,.swc_grid_column' );

                    if( $content[0].style.width === '100%' ) {
                        $( element ).css( 'height', $content.css( 'height' ) );
                    } else {
                        $( element ).css( 'height', '' );
                    }
                } );
            },

            changeAssetLoaction: function( $assetWrapper, $placeholder ) {
                var self = this;
                var editor = self.instance;
                var widgetsRepo = editor.widgets;
                var sourceWidget;
                var id = this.getWidgetIdAssetBased( $assetWrapper );

                var nodePlaceholder = new CKEDITOR.dom.element( $placeholder[ 0 ] );

                // Before drag drop we make columns editable.
                $( '.swc_grid_column' ).attr( 'contenteditable', 'true' );

                sourceWidget = widgetsRepo.instances[ id ];
                if ( !sourceWidget ) {
                    return;
                }

                // Using the events (as we should) will fail. So use direct functions instead.
                self.instance.undoManager.save( true );
                self.instance.undoManager.lock( false, true );

                sourceWidget.wrapper.insertBefore( nodePlaceholder );

                nodePlaceholder.remove();

                self.resetSelection();

                // Using the events (as we should) will fail. So use direct functions instead.
                self.instance.undoManager.unlock();
                self.instance.undoManager.update();
                // There currently is a bug where you have to do ctrl-z twice before the drop is undo.
                // This seems to be a bug in CKeditor itself.

                // Before drag drop we make columns editable.
                $( '.swc_grid_column' ).attr( 'contenteditable', 'false' );

                evt( 'add_exec', { 'fn': 'swifty_check_inserts' } );
                setTimeout( function() {
                    evt( 'add_exec', { 'fn': 'swifty_check_inserts' } );
                }, 1000 );

                self.contentModfied();
            },

            replaceIds: function( node ) {
                var escapeRegExp = function( str ) {
                    return str.replace( /([.*+?^=!:${}()|\[\]\/\\])/g, '\\$1' );
                };

                // find ids
                var oldIds = [];

                // get new id, remember earlier generated ids
                var replaceId = function( id ) {
                    if( ! oldIds[ id ] ) {
                        oldIds[ id ] = Date.now() + '_' + parseInt( Math.random() * 99999, 10 );
                    }
                    return oldIds[ id ];
                };

                var elementsInData = node.find( '.cke_widget_element' );
                $.each( elementsInData.$, function( index, element ) {
                    if( element.hasAttribute( 'id' ) ) {
                        var id = element.getAttribute( 'id' );
                        id = id.slice( 1 );
                        element.setAttribute( 'id', 'c' + replaceId( id ) );
                    }
                } );

                elementsInData = node.find( '.swc_custom_cssclose' );
                $.each( elementsInData.$, function( index, element ) {
                    if( element.hasAttribute( 'id' ) ) {
                        var id = element.getAttribute( 'id' );
                        id = id.slice( 9 );
                        element.setAttribute( 'id', 'cssclose_' + replaceId( id ) );
                    }
                } );

                var assetInData = node.find( '.swc_asset_cntnt' );
                $.each( assetInData.$, function( index, element ) {
                    if( element.hasAttribute( 'data-asset_data' ) ) {
                        var dataString = element.getAttribute( 'data-asset_data' );
                        if( dataString ) {
                            var data = $.parseJSON( Utils.atou( dataString ) );
                            if( data ) {
                                if( data[ 'swc_cssid' ] ) {
                                    data[ 'swc_cssid' ] = replaceId( data[ 'swc_cssid' ] );
                                    element.setAttribute( 'data-asset_data', Utils.utoa( JSON.stringify( data ) ) );
                                }
                            }
                        }
                    }
                } );

                var rowInData = node.find( '.swc_grid_row' );
                $.each( rowInData.$, function( index, element ) {
                    if( element.hasAttribute( 'data-grid_data' ) ) {
                        var dataString = element.getAttribute( 'data-grid_data' );
                        if( dataString ) {
                            var data = $.parseJSON( dataString );
                            if( data ) {
                                if( data[ 'cssid' ] ) {
                                    data[ 'cssid' ] = replaceId( data[ 'cssid' ] );
                                    element.setAttribute( 'data-grid_data', JSON.stringify( data ) );
                                }
                            }
                        }
                    }
                } );

                var styleInData = node.find( 'style.swc_custom_css' );
                $.each( styleInData.$, function( index, element ) {
                    if( element.hasAttribute( 'id' ) ) {
                        var id = element.getAttribute( 'id' );
                        id = id.slice( 4 );
                        var newid = replaceId( id );

                        element.setAttribute( 'id', 'css_' + newid );
                        var styleText = element.textContent;
                        styleText = styleText.replace( new RegExp( escapeRegExp( id ), 'g' ), newid );
                        element.textContent = styleText;
                    }
                } );
            }

        },
        events: {
            inserted: function() {
                this.scope.ini( this.element );
            },

            removed: function() {
                this.scope.destroyAll();
            },

            '{window} evt_swc_replace_ids': function( el, ev, opts, dfd ) {
                var self = this;
                if( opts && opts.html ) {

                    var tempDoc = document.implementation.createHTMLDocument( '' ),
                        temp = new CKEDITOR.dom.element( tempDoc.body );

                    // Without this isReadOnly will not work properly.
                    temp.data( 'cke-editable', 1 );

                    temp.appendHtml( opts.html );

                    self.scope.replaceIds( temp );

                    dfd.resolve( temp.getHtml() );
                }
            },

            '{window} evt_swc_create_editor': function( el, ev, opts, dfd ) {
                if( opts && opts.$element ) {
                    dfd.resolve( this.scope.createEditor( opts.$element ) );
                }
            },

            '{window} evt_swc_ckeditor_command': function( el, ev, opts ) {
                var cmd = opts && opts.command ? opts.command : null;

                if ( cmd ) {
                    this.scope.instance.execCommand( cmd );
                }
            },

            '{window} evt_swc_swifty_editor_content_modified': function( /*el, ev, opts*/ ) {
                this.scope.contentModfied();
            },

            '{window} evt_swc_check_can_undo_redo': function( /*el, ev, opts*/ ) {
                if( this.scope.instance && this.scope.instance.undoManager ) {
                    evt(
                        'can_undo_redo',
                        {
                            'can_undo': this.scope.instance.undoManager.undoable(),
                            'can_redo': this.scope.instance.undoManager.redoable()
                        }
                    );
                }
            },

            // Restore a previously saved 'image'/snapshot of the editor.
            // We do a few tricks here with the snapshot stack because we could not find a better way.
            '{window} evt_swc_ckeditor_undo_last_image': function( /*el, ev, opts*/ ) {
                if( this.scope.instance && this.scope.instance.undoManager ) {
                    this.scope.instance.undoManager.restoreImage( this.scope.lastUndoImage );
                    if( this.scope.undoImageStack ) {
                        this.scope.instance.undoManager.snapshots = this.scope.undoImageStack;
                    }
                }
            },

            '{window} evt_swc_swifty_editor_remove_refresh_spinner': function( /*el, ev, opts*/ ) {
                this.scope.removeRefreshSpinner();
            },

            '{window} evt_swc_swifty_editor_set_focus': function( el, ev, opts ) {
                this.scope.setFocus( opts );
            },

            '{window} evt_swc_swifty_editor_unlock_selection': function( el, ev, opts ) {
                this.scope.unlockSelection( opts );
            },

            '{window} evt_swc_swifty_editor_set_cursor': function( el, ev, opts ) {
                this.scope.setCursor( opts );
            },

            '{window} evt_swc_swifty_editor_move_asset': function( el, ev, opts ) {
                this.scope.moveAsset( opts );
            },

            '{window} evt_swc_swifty_editor_move_row': function( el, ev, opts ) {
                this.scope.moveRow( opts );
            },

            '{window} evt_swc_swifty_editor_insert_p_asset': function( el, ev, opts ) {
                this.scope.insertPAsset( opts );
            },

            '{window} evt_swc_swifty_editor_set_asset_in_edit_mode': function( el, ev, opts ) {
                this.scope.setAssetInEditMode( opts );
            },

            '{document} mouseup': function( /*el, ev*/ ) {
                this.scope.documentMouseUp();
            },

            '{window} evt_swc_editor_visibility': function( el, ev, opts, dfd ) {
                this.scope.setEditorVisibilityByAjax( opts.show_it ).then( function( showIt ) {
                    dfd.resolve( showIt );
                } );
            },

            '{window} evt_swc_set_column_range_for_insert': function( el, ev, opts, dfd ) {
                this.scope.setColumnRangeForInsert( opts.$column );
                dfd.resolve();
            },

            '{window} evt_swc_set_paragraph_range_for_insert': function( el, ev, opts, dfd ) {
                this.scope.setParagraphRangeForInsert( opts.$p );
                dfd.resolve();
            },

            // Outcommented this code because table element is moved back to the CKE toolbar.
            // '{window} evt_swc_editor_open_table_properties': function( el, ev, opts ) {
            //     this.scope.openTableProperties( opts );
            // },

            '{window} evt_swc_editor_drag_handlers_hide': function( /*el, ev, opts*/ ) {
                $( '.cke_widget_drag_handler_container' ).hide();
            },

            '{window} evt_swc_swifty_editor_set_wrappers_height': function( /*el, ev, opts*/ ) {
                this.scope.setWrappersHeight();
            },

            '{window} evt_swc_swifty_editor_change_asset_location': function( el, ev, opts ) {
                this.scope.changeAssetLoaction( opts.$assetWrapper, opts.$placeholder );
            },

            '{window} evt_swc_swifty_editor_show_tooltip': function( /*el, ev, opts*/ ) {
                this.scope.showStartUpTooltip();
            },

            '{window} evt_swc_get_list_google_fonts': function( el, ev, opts, dfd ) {
                dfd.resolve( this.scope.googleFonts );
            }
        }
    } );
} );

swifty.define('css!cssDir/swcreator_ui',[],function(){});


swifty.define('css!js/panels/panel_stack/panel_stack',[],function(){});
swifty.define( 'js/panels/panel_stack/panel_stack',[
    'jquery',
    'swiftylib/control',
    'swiftylib/evt',
    'js/libs/mout/src/function/throttle',
    // No return values:
    'css!js/panels/panel_stack/panel_stack.css'
], function(
    $, Control, evt, throttle
) {
    

    return Control.extend( {
        'defaults': {
        }
    }, {
        init: function() {
            var self = this;
            self.element.append( '<div class="swc_panel_stack"></div>' );
            self.element.append(
              '<div id="swc-spinner" class="swc-spinner">' +
                '<i class="fa fa-refresh fa-spin"></i>' +
              '</div>' );
            self.element.append('<div id="swc-screen-cover" class="swc-screen-cover"></div>');

            self.resizeThrottledObject = throttle( $.proxy( self.resize, self ), 100 );

            self._super();
        },

        addPanel: function( PanelClass, opts ) {
            var self  =this;
            var $panelStack = $( '.swc_panel_stack' );
            var ret;

            //if( opts && opts.mode && opts.mode === 'icon_clicked' && $panelStack.children( 'div' ).length > 1 ) {
            //    this.resetPanelStack( { 'left': true } );
            //}

            $panelStack.children( 'div' ).removeClass( 'swc_panel_visible' );

            var $prevPanel = $panelStack.children( 'div:last' );

            ret = new PanelClass(
                $( '<div></div>' ).appendTo( '.swc_panel_stack' ),
                opts
            );

            var $newPanel = $panelStack.children( 'div:last' );

            self.slidePanels( $newPanel, $prevPanel );

            return ret;
        },

        slidePanels: function( $newPanel, $prevPanel ) {
            var self = this;

            $newPanel.css( {
                'left': '0',
                'top': '0'
            } );

            // Slide the panels in and out
            setTimeout( function() {
                $prevPanel.removeClass( 'swc_panel_animate swc_panel_transition_fast' ).addClass( 'swc_panel_animate_out swc_panel_visible' );
                $newPanel.removeClass( 'swc_panel_animate_out swc_panel_transition_fast' ).addClass( 'swc_panel_animate swc_panel_visible' );
                if( ! ( $prevPanel.length > 0 && $newPanel.length > 0 ) ) {
                    $prevPanel.addClass( 'swc_panel_transition_fast' );
                    $newPanel.addClass( 'swc_panel_transition_fast' );
                }

                self._fixPanelsPositions( $newPanel, $prevPanel, 1 );
            }, 1 );
        },

        closePanel: function( el ) {
            var self = this;
            var $panelStack = $( '.swc_panel_stack' );
            var $curPanel = $( el );

            if( ! $curPanel.children().first().hasClass( 'swc_panel' ) ) {
                $curPanel = $curPanel.closest( '.swc_panel' ).parent();
            }

            var $newPanel = $curPanel;
            var $prevPanel = $curPanel.prev();

            while( $prevPanel.hasClass( 'swc_panel_marked_close' ) ) {
                $prevPanel = $prevPanel.prev();
            }

            self.slidePanels( $prevPanel, $newPanel );

            // Remove the panels that have the class swc_panel_marked_close
            $panelStack.children( 'div' ).filter( '.swc_panel_marked_close' ).remove();

            // When we only show the main panel we always want all icons visible.
            if( $panelStack.children( 'div' ).length === 1 ) {
                evt( 'swifty_editor_set_asset_in_edit_mode' );
            }

            var tm = self._getDuration( $newPanel, $prevPanel );

            setTimeout( function() {
                self._fixPanelsPositions( $prevPanel, $newPanel, 1 ).then( function() {
                    // We remove the panel after the panel has slided to the right after 500 ms
                    setTimeout( function() {
                        $curPanel.remove();
                        self._fixPanelsPositions( $prevPanel, $newPanel, 1 );

                        // When we only show the main panel we always want all icons visible.
                        if( $panelStack.children( 'div' ).length === 1 ) {
                            evt( 'swifty_editor_set_asset_in_edit_mode' );
                        }
                    }, tm );
                } );
            }, 1 );
        },

        _fixPanelsPositions: function( $newPanel, $prevPanel, resetIframeHeight ) {
            var self = this;
            var dfd = new $.Deferred();

            dfd.resolve();

            var h = parseInt( $( window ).height(), 10 );

            if( $newPanel && $newPanel.length >= 1 ) {
                h -= $newPanel.outerHeight() /*- 20*/;
            }

            var tm = self._getDuration( $newPanel, $prevPanel );

            // Set the height of the iframe, so the panels will fit neatly below
            if( resetIframeHeight === 1 ) {
                $( '#swc_iframe' ).height( parseInt( $( window ).height(), 10 ) );
            } else {
                $( '#swc_iframe' ).height( h );
            }
            $( '#swc_iframe' ).animate(
                { 'height': h },
                tm
            );

            evt( 'swifty_update_scrolleffect' );
            setTimeout( function() {
                evt( 'swifty_update_scrolleffect' );
            }, tm );

            return dfd;
        },

        _getDuration: function( $newPanel, $prevPanel ) {
            if( ! ( $prevPanel && $prevPanel.length > 0 && $newPanel && $newPanel.length > 0 ) ) {
                return 1;
            }

            return 400;
        },

        resize: function() {
            var $panelStack = $( '.swc_panel_stack' );

            $panelStack.find( 'div.swc_panel_visible' ).addClass( 'swc_panel_transition_fast' );

            this._fixPanelsPositions( $( '.swc_panel_stack .swc_panel:last' ), null, 1 ).then( function() {
                setTimeout( function() {
                    $panelStack.find( 'div.swc_panel_visible' ).removeClass( 'swc_panel_transition_fast' );
                }, 100 );
            } );
        },

        resetPanelStack: function( opts ) {
            var self = this;
            var $panelStack = $( '.swc_panel_stack' );
            var $firstPanel = $panelStack.children( 'div:first' );
            var $lastPanel = $panelStack.children( 'div:last' );

            if( opts && opts.left ) {
                // OLD: Remove all the panels except the first and last one after 500 ms (is the animation duration)
                // NEW: We have a situation where theis timeout caused serious problems and we can't figure out why the timeout is needed anyway, so we removed the timeout.
                // setTimeout( function() {
                    $panelStack.children( 'div' ).not( ':first' ).not( ':last' ).remove();
                // }, 400 );
            } else {   // Slide out the last panel to the left
                $panelStack.children( 'div' ).not( ':first' ).not( ':last' ).remove();

                self.slidePanels( $firstPanel, $lastPanel );

                // Remove the last panel after 500 ms (is the animation duration)
                setTimeout( function() {
                    $lastPanel.remove();
                    self._fixPanelsPositions( null, null, 1 );
                }, 400 );
            }
        },

        '{window} resize': function() {
            this.resizeThrottledObject();
        },

        '{window} evt_swc_reset_panel_stack': function( el, ev, opts ) {
            this.resetPanelStack( opts );
        },

        '{window} evt_swc_fix_panel_heights': function( el, ev, opts ) {
            var self = this;

            if( opts && opts.redraw_element ) {
                // This forces a browser reflow of the element (panel).
                // It fixes a bug in Chrome.

                $( opts.redraw_element ).each( function( ii, el ) {
                    var element = $( el )[ 0 ];

                    if( !element ) { return; }

                    var n = document.createTextNode( ' ' );
                    var disp = element.style.display;

                    element.appendChild( n );
                    // element.style.display = 'none';

                    setTimeout( function() {
                        // element.style.display = disp;
                        n.parentNode.removeChild( n );
                        self._fixPanelsPositions( $( '.swc_panel_stack .swc_panel:last' ), null, 0 );
                    }, 1 );
                } );
            }

            // Re-determine the height of the panels and the iframe.

            self._fixPanelsPositions( $( '.swc_panel_stack .swc_panel:last' ), null, 0 );
            setTimeout( function() {
                self._fixPanelsPositions( $( '.swc_panel_stack .swc_panel:last' ), null, 0 );
            }, 1 );
            setTimeout( function() {
                self._fixPanelsPositions( $( '.swc_panel_stack .swc_panel:last' ), null, 0 );
            }, 1000 );
        }
    } );
} );
swifty.define( 'js/panels/panel_stack/panel_stack_instance',[
    'js/panels/panel_stack/panel_stack'
], function(
    PanelStack
) {
    

    return new PanelStack( 'body', {} );
} );
swifty.define( 'swiftylib/list',[
    'can/list'
], function( List ) {
    

    return List;
} );

/*!
 * CanJS - 2.3.21
 * http://canjs.com/
 * Copyright (c) 2016 Bitovi
 * Sat, 19 Mar 2016 01:24:17 GMT
 * Licensed MIT
 */

/*can@2.3.21#list/sort/sort*/
swifty.define('can/list/sort',[
    'can/util/library',
    'can/list'
], function (can) {
    var oldBubbleRule = can.List._bubbleRule;
    can.List._bubbleRule = function (eventName, list) {
        var oldBubble = oldBubbleRule.apply(this, arguments);
        if (list.comparator && can.inArray('change', oldBubble) === -1) {
            oldBubble.push('change');
        }
        return oldBubble;
    };
    var proto = can.List.prototype, _changes = proto._changes || function () {
        }, setup = proto.setup, unbind = proto.unbind;
    can.extend(proto, {
        setup: function (instances, options) {
            setup.apply(this, arguments);
            this.bind('change', can.proxy(this._changes, this));
            this._comparatorBound = false;
            this.bind('comparator', can.proxy(this._comparatorUpdated, this));
            delete this._init;
            if (this.comparator) {
                this.sort();
            }
        },
        _comparatorUpdated: function (ev, newValue) {
            if (newValue || newValue === 0) {
                this.sort();
                if (this._bindings > 0 && !this._comparatorBound) {
                    this.bind('change', this._comparatorBound = function () {
                    });
                }
            } else if (this._comparatorBound) {
                unbind.call(this, 'change', this._comparatorBound);
                this._comparatorBound = false;
            }
        },
        unbind: function (ev, handler) {
            var res = unbind.apply(this, arguments);
            if (this._comparatorBound && this._bindings === 1) {
                unbind.call(this, 'change', this._comparatorBound);
                this._comparatorBound = false;
            }
            return res;
        },
        _comparator: function (a, b) {
            var comparator = this.comparator;
            if (comparator && typeof comparator === 'function') {
                return comparator(a, b);
            }
            if (typeof a === 'string' && typeof b === 'string' && ''.localeCompare) {
                return a.localeCompare(b);
            }
            return a === b ? 0 : a < b ? -1 : 1;
        },
        _changes: function (ev, attr, how, newVal, oldVal) {
            var dotIndex = ('' + attr).indexOf('.');
            if (this.comparator && dotIndex !== -1) {
                if (ev.batchNum) {
                    if (ev.batchNum === this._lastProcessedBatchNum) {
                        return;
                    } else {
                        this.sort();
                        this._lastProcessedBatchNum = ev.batchNum;
                        return;
                    }
                }
                var currentIndex = +attr.substr(0, dotIndex);
                var item = this[currentIndex];
                var changedAttr = attr.substr(dotIndex + 1);
                if (typeof item !== 'undefined' && (typeof this.comparator !== 'string' || this.comparator.indexOf(changedAttr) === 0)) {
                    var newIndex = this._getRelativeInsertIndex(item, currentIndex);
                    if (newIndex !== currentIndex) {
                        this._swapItems(currentIndex, newIndex);
                        can.batch.trigger(this, 'length', [this.length]);
                    }
                }
            }
            _changes.apply(this, arguments);
        },
        _getInsertIndex: function (item, lowerBound, upperBound) {
            var insertIndex = 0;
            var a = this._getComparatorValue(item);
            var b, dir, comparedItem, testIndex;
            lowerBound = typeof lowerBound === 'number' ? lowerBound : 0;
            upperBound = typeof upperBound === 'number' ? upperBound : this.length - 1;
            while (lowerBound <= upperBound) {
                testIndex = (lowerBound + upperBound) / 2 | 0;
                comparedItem = this[testIndex];
                b = this._getComparatorValue(comparedItem);
                dir = this._comparator(a, b);
                if (dir < 0) {
                    upperBound = testIndex - 1;
                } else if (dir >= 0) {
                    lowerBound = testIndex + 1;
                    insertIndex = lowerBound;
                }
            }
            return insertIndex;
        },
        _getRelativeInsertIndex: function (item, currentIndex) {
            var naiveInsertIndex = this._getInsertIndex(item);
            var nextItemIndex = currentIndex + 1;
            var a = this._getComparatorValue(item);
            var b;
            if (naiveInsertIndex >= currentIndex) {
                naiveInsertIndex -= 1;
            }
            if (currentIndex < naiveInsertIndex && nextItemIndex < this.length) {
                b = this._getComparatorValue(this[nextItemIndex]);
                if (this._comparator(a, b) === 0) {
                    return currentIndex;
                }
            }
            return naiveInsertIndex;
        },
        _getComparatorValue: function (item) {
            var comparator = this.comparator;
            if (item && comparator && typeof comparator === 'string') {
                item = typeof item[comparator] === 'function' ? item[comparator]() : item.attr(comparator);
            }
            return item;
        },
        _getComparatorValues: function () {
            var self = this;
            var a = [];
            this.each(function (item, index) {
                a.push(self._getComparatorValue(item));
            });
            return a;
        },
        sort: function (comparator) {
            if (arguments.length) {
                this.attr('comparator', comparator);
            } else {
                this._sort();
            }
            return this;
        },
        _sort: function () {
            var a, b, c, isSorted;
            for (var i, iMin, j = 0, n = this.length; j < n - 1; j++) {
                iMin = j;
                isSorted = true;
                c = undefined;
                for (i = j + 1; i < n; i++) {
                    a = this._getComparatorValue(this.attr(i));
                    b = this._getComparatorValue(this.attr(iMin));
                    if (this._comparator.call(this, a, b) < 0) {
                        isSorted = false;
                        iMin = i;
                    }
                    if (c && this._comparator.call(this, a, c) < 0) {
                        isSorted = false;
                    }
                    c = a;
                }
                if (isSorted) {
                    break;
                }
                if (iMin !== j) {
                    this._swapItems(iMin, j);
                }
            }
            can.batch.trigger(this, 'length', [this.length]);
            return this;
        },
        _swapItems: function (oldIndex, newIndex) {
            var temporaryItemReference = this[oldIndex];
            [].splice.call(this, oldIndex, 1);
            [].splice.call(this, newIndex, 0, temporaryItemReference);
            can.batch.trigger(this, 'move', [
                temporaryItemReference,
                newIndex,
                oldIndex
            ]);
        }
    });
    can.each({
        push: 'length',
        unshift: 0
    }, function (where, name) {
        var proto = can.List.prototype, old = proto[name];
        proto[name] = function () {
            if (this.comparator && arguments.length) {
                var args = can.makeArray(arguments);
                var length = args.length;
                var i = 0;
                var newIndex, val;
                while (i < length) {
                    val = can.bubble.set(this, i, this.__type(args[i], i));
                    newIndex = this._getInsertIndex(val);
                    Array.prototype.splice.apply(this, [
                        newIndex,
                        0,
                        val
                    ]);
                    this._triggerChange('' + newIndex, 'add', [val], undefined);
                    i++;
                }
                can.batch.trigger(this, 'reset', [args]);
                return this;
            } else {
                return old.apply(this, arguments);
            }
        };
    });
    (function () {
        var proto = can.List.prototype;
        var oldSplice = proto.splice;
        proto.splice = function (index, howMany) {
            var args = can.makeArray(arguments);
            if (!this.comparator) {
                return oldSplice.apply(this, args);
            }
            oldSplice.call(this, index, howMany);
            args.splice(0, 2);
            proto.push.apply(this, args);
        };
    }());
    return can.Map;
});
swifty.define( 'swiftylib/sort',[
    'can/list/sort'
], function( Sort ) {
    

    return Sort;
} );


swifty.define('stache!js/panels/panel/panel.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/panels/panel/panel.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<div class="swc_panel {{panel_css_class}}">\n    <div class="swc_panel_inner_wrapper">\n        <div class="swc_panel_title_container">\n            <div class="swc_panel_title_icon">&#xe03d</div>\n            <div class="swc_panel_title_pos">\n                <div class="swc_title">\n                    {{__ title}}\n                    {{#if title_tooltip}}\n                        <i class="fa fa-question"></i>\n                        <swc_tooltip for_sel=".swc_title" {{#if title_tooltip_title}}title="{{__ title_tooltip_title}}"{{/if}} text="{{__ title_tooltip}}" />\n                    {{/if}}\n                </div>\n            </div>\n        </div>\n        <div class="swc_panel_container">\n            {{#eq back_action \'exit\'}}\n            {{else}}\n                <div class="swc_panel_back_container {{#eq back_action \'exit\'}}swc_back_exit{{/eq}}">\n                    <div class="swc_back_button swc_button">\n                        {{#eq panel_css_class \'swc_small_panel\'}}\n                            &#xe900;\n                        {{else}}\n                            <i class="fa fa-chevron-left"></i>\n                        {{/eq}}\n                    </div>\n                </div>\n            {{/eq}}\n            <div class="swc_panel_content">\n                {{#if tmpl_content}}\n                    {{&renderStache tmpl_content}}\n                {{/if}}\n            </div>\n            {{#if map.show_main_menu}}\n                {{#if show_panel_extra}}\n                    <div class="swc_panel_extra">\n                        <div class="swc_panel_extra_inner">\n                            {{#if tmpl_extra}}\n                                <div class="swc_panel_extra_container">\n                                    {{&renderStache tmpl_extra}}\n                                </div>\n                            {{/if}}\n                            {{#with map}}\n                            {{#if map.show_undo_redo}}\n                                <div class="swc_panel_extra_inner_row">\n                                    <div class="swc_button swc_main_scrsize swc_main_editor swc_enabled"><span aria-hidden="true">&#xe601;</span></div>\n                                    <swc_tooltip for_sel=".swc_main_editor" title="{{__ \'Toolbar switch\' }}" text="{{__ \'Switch between always showing the toolbar or only when you select text.\' }}" />\n                                </div>\n                            {{/if}}\n                            {{/with}}\n                            {{#if show_screen_size}}\n                            <div class="swc_panel_extra_inner_row">\n                                <div class="swc_button swc_main_scrsize swc_main_desk_mob swc_enabled">&#xe928</div>\n                                <swc_tooltip for_sel=".swc_main_desk_mob" content_sel=".swc_main_desk_mob_content" content_width="null" />\n                            </div>\n                            {{/if}}\n                            {{#if page_model_map.show_button_manage_versions}}\n                            <div class="swc_button swc_main_scrsize swc_manage_versions swc_enabled">&#xe912;</div>\n                            {{/if}}\n                            {{#if page_model_map.show_button_notifications}}\n                            <div class="swc_button swc_main_scrsize swc_notifications swc_enabled"><i class="fa fa-inbox"></i>\n                                {{#is message_data.items.total_nr_unread 0}}\n                                {{else}}\n                                    <div class="swc_button_msg_count">{{message_data.items.total_nr_unread}}</div>\n                                {{/is}}\n                            </div>\n                            {{/if}}\n                            {{#if is_easy_mode}}\n                            <div class="swc_button swc_main_scrsize swc_help_button swc_enabled"><i class="fa fa-question"></i></div>\n                            {{/if}}\n                            {{#if show_save_panel}}\n                            <div class="swc_panel_btn_divider"></div>\n                            <div class="swc_panel_extra_inner_row">\n                                <div class="swc_button swc_main_scrsize swc_main_save swc_main_save_size_2 {{map.save_panel_state}}">{{map.text_save_state}}</div>\n                                <swc_tooltip for_sel=".swc_main_save" title="{{__ \'Autosave\' }}"  content_sel=".swc_save_panel_tooltip" />\n                            </div>\n                            {{/if}}\n                            {{#if page_model_map.show_button_publish}}\n                            <swc_panel_button icon="&#xe040;" action="publish" name="{{page_model_map.publish_title}}" is_disabled="{{page_model_map.is_published_same}}"/>\n                            {{/if}}\n                        </div>\n                    </div>\n                    <div class="swc_main_desk_mob_content" style="display: none;">\n                        <div class="swc_button swc_main_scrsize swc_main_desktop swc_enabled"><i class="fa fa-desktop"></i></div>\n                        <div class="swc_button swc_main_scrsize swc_main_tablet swc_enabled"><i class="fa fa-tablet"></i></div>\n                        <div class="swc_button swc_main_scrsize swc_main_mobile swc_enabled"><i class="fa fa-mobile"></i></div>\n                    </div>\n                    <div class="swc_save_panel_tooltip" style="display: none;">\n                    <p>{{map.save_panel_tooltip}}</p>\n                    </div>\n                {{/if}}\n                {{#eq back_action \'exit\'}}\n                    <div class="swc_panel_back_container {{#eq back_action \'exit\'}}swc_back_exit{{/eq}}">\n                        <div class="swc_back_button swc_button">\n                            {{#eq panel_css_class \'swc_small_panel\'}}\n                                &#xe900;\n                            {{else}}\n                                <i class="fa fa-chevron-left"></i>\n                            {{/eq}}\n                        </div>\n                    </div>\n                {{/eq}}\n            {{/if}}\n            <div class="clearfix"></div>\n        </div>\n    </div>\n    {{#if tmpl_tabs}}\n        {{&renderStache tmpl_tabs}}\n    {{/if}}\n</div>' ); return idn; });


swifty.define('stache!js/components/panel_button/panel_button.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/components/panel_button/panel_button.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '{{convertFAIcons}}\n<div class="swc_panel_button_wrapper">\n    <div class="swc_panel_button swc_panel_button_{{action}} {{^active}}swc_inactive{{/active}} {{#if is_disabled}}swc_disabled{{/if}} {{#is_hidden}}swc_hidden{{/is_hidden}} {{#is_selected}}swc_selected{{/is_selected}}">\n        <div class="swc_icon" style="{{#if bg_img}}background-image: url({{bg_img}});{{/if}}">\n            {{#if icon}}\n                <span aria-hidden="true">{{&icon}}</span>\n            {{/if}}\n            {{#if fa_icon}}\n                <i class="fa {{fa_icon}}"></i>\n            {{/if}}\n            {{#if row_type}}\n                <swc_column_icon cols="{{row_type}}" />\n            {{/if}}\n            {{#if ribbon_coming}}\n                <!--<div class="swc_ribbon_label">-->\n                    <!--{{__ \'Coming soon\' }}-->\n                <!--</div>-->\n            {{/if}}\n        </div>\n        <div class="swc_text_outer">\n            <div class="swc_text">\n            {{#if name}}\n                {{&__ name}}\n            {{else}}\n                {{__ action}}\n            {{/if}}\n            </div>\n        </div>\n    </div>\n    {{#if ribbon_paid}}\n        <div class="swc_ribbon">\n            <i class="fa fa-check"></i>\n        </div>\n    {{/if}}\n    {{#if ribbon_expired}}\n        <div class="swc_ribbon">\n            <i class="fa fa-dollar"></i>\n        </div>\n    {{/if}}\n    {{#if ribbon_coming}}\n        <div class="swc_ribbon">\n            <i class="fa fa-dollar"></i>\n        </div>\n    {{/if}}\n</div>' ); return idn; });


swifty.define('css!js/components/panel_button/panel_button',[],function(){});
swifty.define( 'js/components/panel_button/panel_button',[
    'jquery',
    'swiftylib/component',
    'swiftylib/view',
    'stache!js/components/panel_button/panel_button.stache',
    // No return values:
    'css!js/components/panel_button/panel_button.css',
    'can/map/define'
], function(
    $, Component, View, tmpl
) {
    

    return Component.extend( {
        tag: 'swc_panel_button',
        template: new View( tmpl ),
        scope: {
            define: {
                is_disabled  : {
                    type: 'boolean'
                },
                is_selected  : {
                    type: 'boolean'
                }
            },
            active: '@',
            icon: '@',
            row_type: '@',
            action: '@',
            name: '@',
            is_disabled: '@',
            is_hidden: '@',
            is_selected: '@',
            ribbon_paid: '@',
            ribbon_expired: '@',
            ribbon_coming: '@',
            bg_img: '@'
        },
        events: {
//            click: function(){
//                evt( 'panel_button_click', { action: this.scope.attr( 'action' ) }, this.element );
//            },
//
//            ' evt_swc_button_state_change': function( $el, ev, opts ) {
//                this.scope.attr( {
//                    'is_disabled': opts.is_disabled,
//                    'is_hidden': opts.is_hidden
//                } );
//            }
        }
    } );
} );
swifty.define( 'js/components/tooltip/jBox.min',[ 'jquery' ], function( jQuery ) {


function jBox(e,t){this.options={id:null,width:"auto",height:"auto",attach:null,trigger:"click",preventDefault:false,title:null,content:null,getTitle:null,getContent:null,ajax:null,data:"",reload:false,target:null,position:{x:"center",y:"center"},outside:null,offset:0,attributes:{x:"left",y:"top"},adjustPosition:false,adjustTracker:false,adjustDistance:5,fixed:false,reposition:false,pointer:false,fade:180,animation:null,theme:"Default",addClass:"",overlay:false,zIndex:1e4,delayOpen:0,delayClose:0,closeOnEsc:false,closeOnClick:false,closeOnMouseleave:false,closeButton:false,constructOnInit:false,blockScroll:false,appendTo:jQuery("body"),draggable:null,onInit:function(){},onCreated:function(){},onOpen:function(){},onClose:function(){},onCloseComplete:function(){},onAjax:function(){},onAjaxComplete:function(){},autoClose:7e3,color:null,stack:true,audio:false,volume:100,src:"href",gallery:"data-jbox-image",imageLabel:"title",imageFade:600,imageSize:"cover"};this.defaultOptions={Tooltip:{getContent:"title",trigger:"mouseenter",position:{x:"center",y:"top"},outside:"y",pointer:true,adjustPosition:true,reposition:true},Mouse:{target:"mouse",position:{x:"right",y:"bottom"},offset:15,trigger:"mouseenter",adjustPosition:"flip"},Modal:{target:jQuery(window),fixed:true,blockScroll:true,closeOnEsc:true,closeOnClick:"overlay",closeButton:"title",overlay:true,animation:"zoomOut"},Notice:{target:jQuery(window),fixed:true,position:{x:20,y:20},attributes:{x:"right",y:"top"},animation:"zoomIn",closeOnClick:"box",_onInit:function(){this.open();this.options.delayClose=this.options.autoClose;this.options.delayClose&&this.close()}.bind(this),_onCreated:function(){this.options.color&&this.wrapper.addClass("jBox-Notice-color jBox-Notice-"+this.options.color)},_onOpen:function(){jQuery.each(jQuery(".jBox-Notice"),function(e,t){t=jQuery(t);if(t.attr("id")==this.id||t.css(this.options.attributes.y)=="auto"||t.css(this.options.attributes.x)=="auto")return;if(!this.options.stack){t.data("jBox").close({ignoreDelay:true});return}t.css("margin-"+this.options.attributes.y,parseInt(t.css("margin-"+this.options.attributes.y))+this.dimensions.y+10)}.bind(this));if(this.options.audio&&!this.IE8){this.audio=jQuery("<audio/>");jQuery("<source/>",{src:this.options.audio+".mp3"}).appendTo(this.audio);jQuery("<source/>",{src:this.options.audio+".ogg"}).appendTo(this.audio);this.audio[0].volume=Math.min(this.options.volume/100,1);this.audio[0].play()}}.bind(this),_onCloseComplete:function(){this.destroy()}.bind(this)},Image:{target:jQuery(window),fixed:true,blockScroll:true,closeOnEsc:true,closeOnClick:"overlay",overlay:true,animation:"zoomOut",width:800,height:533,attach:jQuery("[data-jbox-image]"),preventDefault:true,_onInit:function(){this.images=this.currentImage={};this.imageZIndex=1;jQuery.each(this.attachedElements,function(e,t){t=jQuery(t);if(t.data("jBox-image-gallery"))return;var n=t.attr(this.options.gallery)||"default";!this.images[n]&&(this.images[n]=[]);this.images[n].push({src:t.attr(this.options.src),label:t.attr(this.options.imageLabel)||""});this.options.imageLabel=="title"&&t.removeAttr("title");t.data("jBox-image-gallery",n);t.data("jBox-image-id",this.images[n].length-1)}.bind(this));var e=function(e,t,n,r){if(jQuery("#jBox-image-"+e+"-"+t).length)return;var i=jQuery("<div/>",{id:"jBox-image-"+e+"-"+t,"class":"jBox-image-container"}).css({backgroundImage:"url("+this.images[e][t].src+")",backgroundSize:this.options.imageSize,opacity:r?1:0,zIndex:n?0:this.imageZIndex++}).appendTo(this.content);var s=jQuery("<div/>",{id:"jBox-image-label-"+e+"-"+t,"class":"jBox-image-label"+(r?" active":"")}).html(this.images[e][t].label).appendTo(this.imageLabel);!r&&!n&&i.animate({opacity:1},this.options.imageFade)}.bind(this);var t=function(e,t){jQuery(".jBox-image-label.active").removeClass("active");jQuery("#jBox-image-label-"+e+"-"+t).addClass("active")};this.showImage=function(n){if(n!="open"){var r=this.currentImage.gallery;var i=this.currentImage.id+(1*(n=="prev")?-1:1);i=i>this.images[r].length-1?0:i<0?this.images[r].length-1:i}else{var r=this.source.data("jBox-image-gallery");var i=this.source.data("jBox-image-id");jQuery(".jBox-image-pointer-prev, .jBox-image-pointer-next").css({display:this.images[r].length>1?"block":"none"})}this.currentImage={gallery:r,id:i};if(jQuery("#jBox-image-"+r+"-"+i).length){jQuery("#jBox-image-"+r+"-"+i).css({zIndex:this.imageZIndex++,opacity:0}).animate({opacity:1},n=="open"?0:this.options.imageFade);t(r,i)}else{this.wrapper.addClass("jBox-loading");var s=jQuery('<img src="'+this.images[r][i].src+'">').load(function(){e(r,i,false);t(r,i);this.wrapper.removeClass("jBox-loading")}.bind(this))}var o=i+1;o=o>this.images[r].length-1?0:o<0?this.images[r].length-1:o;!jQuery("#jBox-image-"+r+"-"+o).length&&jQuery('<img src="'+this.images[r][o].src+'">').load(function(){e(r,o,true)})}},_onCreated:function(){this.imageLabel=jQuery("<div/>",{id:"jBox-image-label"}).appendTo(this.wrapper);this.wrapper.append(jQuery("<div/>",{"class":"jBox-image-pointer-prev",click:function(){this.showImage("prev")}.bind(this)})).append(jQuery("<div/>",{"class":"jBox-image-pointer-next",click:function(){this.showImage("next")}.bind(this)}))},_onOpen:function(){jQuery("body").addClass("jBox-image-open");jQuery(document).on("keyup.jBox-"+this.id,function(e){e.keyCode==37&&this.showImage("prev");e.keyCode==39&&this.showImage("next")}.bind(this));this.showImage("open")},_onClose:function(){jQuery("body").removeClass("jBox-image-open");jQuery(document).off("keyup.jBox-"+this.id)},_onCloseComplete:function(){this.wrapper.find(".jBox-image-container").css("opacity",0)}}};if(jQuery.type(e)=="string"){this.type=e;e=this.defaultOptions[e]}this.options=jQuery.extend(this.options,e,t);if(this.options.id===null){var n=1;while(jQuery("#jBox"+n).length!=0)n++;this.options.id="jBox"+n}this.id=this.options.id;(this.options.position.x=="center"&&this.options.outside=="x"||this.options.position.y=="center"&&this.options.outside=="y")&&(this.options.outside=false);(!this.options.outside||this.options.outside=="xy")&&(this.options.pointer=false);jQuery.type(this.options.offset)!="object"&&(this.options.offset={x:this.options.offset,y:this.options.offset});this.options.offset.x||(this.options.offset.x=0);this.options.offset.y||(this.options.offset.y=0);jQuery.type(this.options.adjustDistance)!="object"&&(this.options.adjustDistance={top:this.options.adjustDistance,right:this.options.adjustDistance,bottom:this.options.adjustDistance,left:this.options.adjustDistance});this.align=this.options.outside&&this.options.outside!="xy"?this.options.position[this.options.outside]:this.options.position.y!="center"&&jQuery.type(this.options.position.y)!="number"?this.options.position.x:this.options.position.x!="center"&&jQuery.type(this.options.position.x)!="number"?this.options.position.y:this.options.attributes.x;this.options.outside&&this.options.outside!="xy"&&(this.outside=this.options.position[this.options.outside]);var r=navigator.userAgent.toLowerCase();this.IE8=r.indexOf("msie")!=-1&&parseInt(r.split("msie")[1])==8;this.prefix=r.indexOf("webkit")!=-1?"-webkit-":"";this._getOpp=function(e){return{left:"right",right:"left",top:"bottom",bottom:"top",x:"y",y:"x"}[e]};this._getXY=function(e){return{left:"x",right:"x",top:"y",bottom:"y",center:"x"}[e]};this._getTL=function(e){return{left:"left",right:"left",top:"top",bottom:"top",center:"left",x:"left",y:"top"}[e]};this._create=function(){if(this.wrapper)return;this.wrapper=jQuery("<div/>",{id:this.id,"class":"jBox-wrapper"+(this.type?" jBox-"+this.type:"")+(this.options.theme?" jBox-"+this.options.theme:"")+(this.options.addClass?" "+this.options.addClass:"")+(this.IE8?" jBox-IE8":"")}).css({position:this.options.fixed?"fixed":"absolute",display:"none",opacity:0,zIndex:this.options.zIndex}).data("jBox",this);this.options.closeOnMouseleave&&this.wrapper.mouseenter(function(){this.open()}.bind(this)).mouseleave(function(){this.close()}.bind(this));this.container=jQuery("<div/>",{"class":"jBox-container"}).appendTo(this.wrapper);this.content=jQuery("<div/>",{"class":"jBox-content"}).css({width:this.options.width,height:this.options.height}).appendTo(this.container);if(this.options.closeButton){this.closeButton=jQuery("<div/>",{"class":"jBox-closeButton jBox-noDrag"}).click(function(){this.close()}.bind(this));if(this.options.closeButton!="title"){this.wrapper.addClass("jBox-closeButton-box");this.closeButton.appendTo(this.container)}}this.wrapper.appendTo(this.options.appendTo);if(this.options.pointer){this.pointer={position:this._getOpp(this.outside),xy:this._getXY(this.outside),align:"center",offset:0};this.pointer.element=jQuery("<div/>",{"class":"jBox-pointer jBox-pointer-"+this.pointer.position}).appendTo(this.wrapper);this.pointer.dimensions={x:this.pointer.element.outerWidth(),y:this.pointer.element.outerHeight()};if(jQuery.type(this.options.pointer)=="string"){var e=this.options.pointer.split(":");e[0]&&(this.pointer.align=e[0]);e[1]&&(this.pointer.offset=parseInt(e[1]))}this.pointer.alignAttribute=this.pointer.xy=="x"?this.pointer.align=="bottom"?"bottom":"top":this.pointer.align=="right"?"right":"left";this.wrapper.css("padding-"+this.pointer.position,this.pointer.dimensions[this.pointer.xy]);this.pointer.element.css(this.pointer.alignAttribute,this.pointer.align=="center"?"50%":0).css("margin-"+this.pointer.alignAttribute,this.pointer.offset);this.pointer.margin={margin:this.pointer.element.css("margin")};this.pointer.align=="center"&&this.pointer.element.css(this.prefix+"transform","translate("+(this.pointer.xy=="y"?this.pointer.dimensions.x*-.5+"px":0)+", "+(this.pointer.xy=="x"?this.pointer.dimensions.y*-.5+"px":0)+")");this.pointer.element.css(this.pointer.xy=="x"?"width":"height",parseInt(this.pointer.dimensions[this.pointer.xy])+parseInt(this.container.css("border-"+this.pointer.alignAttribute+"-width")));this.wrapper.addClass("jBox-pointerPosition-"+this.pointer.position)}this.setContent(this.options.content);this.setTitle(this.options.title);if(this.options.draggable){var t=this.options.draggable=="title"?this.titleContainer:this.options.draggable.length>0?this.options.draggable:this.wrapper;t.addClass("jBox-draggable").on("mousedown",function(e){if(e.button==2||jQuery(e.target).hasClass("jBox-noDrag")||jQuery(e.target).parents(".jBox-noDrag").length)return;var t=this.wrapper.outerHeight(),n=this.wrapper.outerWidth(),r=this.wrapper.offset().top+t-e.pageY,i=this.wrapper.offset().left+n-e.pageX;jQuery(document).on("mousemove.jBox-draggable-"+this.id,function(e){this.wrapper.offset({top:e.pageY+r-t,left:e.pageX+i-n})}.bind(this));e.preventDefault()}.bind(this)).on("mouseup",function(){jQuery(document).off("mousemove.jBox-draggable-"+this.id)}.bind(this))}this.options.onCreated.bind(this)();this.options._onCreated&&this.options._onCreated.bind(this)()};this.options.constructOnInit&&this._create();this.options.attach&&this.attach();this._positionMouse=function(e){this.pos={left:e.pageX,top:e.pageY};var t=function(e,t){if(this.options.position[t]=="center"){this.pos[e]-=Math.ceil(this.dimensions[t]/2);return}this.pos[e]+=e==this.options.position[t]?this.dimensions[t]*-1-this.options.offset[t]:this.options.offset[t];return this.pos[e]}.bind(this);this.wrapper.css({left:t("left","x"),top:t("top","y")});this.targetDimensions={x:0,y:0,left:e.pageX,top:e.pageY};this._adjustPosition()};this._attachEvents=function(){this.options.closeOnEsc&&jQuery(document).on("keyup.jBox-"+this.id,function(e){if(e.keyCode==27){this.close({ignoreDelay:true})}}.bind(this));this.options.closeOnClick&&jQuery(document).on("click.jBox-"+this.id,function(e){if(this.blockBodyClick||this.options.closeOnClick=="overlay"&&(!this.overlay||e.target!=this.overlay[0])||this.options.closeOnClick=="box"&&e.target!=this.wrapper[0]&&!this.wrapper.has(e.target).length||this.options.closeOnClick=="body"&&(e.target==this.wrapper[0]||this.wrapper.has(e.target).length))return;this.close({ignoreDelay:true})}.bind(this));if((this.options.adjustPosition&&this.options.adjustTracker||this.options.reposition)&&!this.fixed&&this.outside){var e,t=0,n=150;var r=function(){var r=(new Date).getTime();if(!e){if(r-t>n){this.options.reposition&&this.position();this.options.adjustTracker&&this._adjustPosition();t=r}e=setTimeout(function(){e=null;t=(new Date).getTime();this.options.reposition&&this.position();this.options.adjustTracker&&this._adjustPosition()}.bind(this),n)}}.bind(this);this.options.adjustTracker&&this.options.adjustTracker!="resize"&&jQuery(window).on("scroll.jBox-"+this.id,function(e){r()}.bind(this));(this.options.adjustTracker&&this.options.adjustTracker!="scroll"||this.options.reposition)&&jQuery(window).on("resize.jBox-"+this.id,function(e){r()}.bind(this))}this.options.target=="mouse"&&jQuery("body").on("mousemove.jBox-"+this.id,function(e){this._positionMouse(e)}.bind(this))};this._detachEvents=function(){this.options.closeOnEsc&&jQuery(document).off("keyup.jBox-"+this.id);this.options.closeOnClick&&jQuery(document).off("click.jBox-"+this.id);if(this.options.adjustPosition&&this.options.adjustTracker||this.options.reposition){jQuery(window).off("scroll.jBox-"+this.id);jQuery(window).off("resize.jBox-"+this.id)}this.options.target=="mouse"&&jQuery("body").off("mousemove.jBox-"+this.id)};this._addOverlay=function(){!this.overlay&&(this.overlay=jQuery("#jBox-overlay").length?jQuery("#jBox-overlay").css({zIndex:Math.min(jQuery("#jBox-overlay").css("z-index"),this.options.zIndex-1)}):jQuery("<div/>",{id:"jBox-overlay"}).css({display:"none",opacity:0,zIndex:this.options.zIndex-1}).appendTo(jQuery("body")));var e=this.overlay.data("jBox")||{};e["jBox-"+this.id]=true;this.overlay.data("jBox",e);if(this.overlay.css("display")=="block")return;this.options.fade?this.overlay.stop()&&this.overlay.animate({opacity:1},{queue:false,duration:this.options.fade,start:function(){this.overlay.css({display:"block"})}.bind(this)}):this.overlay.css({display:"block",opacity:1})};this._removeOverlay=function(){if(!this.overlay)return;var e=this.overlay.data("jBox");delete e["jBox-"+this.id];this.overlay.data("jBox",e);if(jQuery.isEmptyObject(e)){this.options.fade?this.overlay.stop()&&this.overlay.animate({opacity:0},{queue:false,duration:this.options.fade,complete:function(){this.overlay.css({display:"none"})}.bind(this)}):this.overlay.css({display:"none",opacity:0})}};this._generateCSS=function(){if(this.IE8)return;jQuery.type(this.options.animation)!="object"&&(this.options.animation={pulse:{open:"pulse",close:"zoomOut"},zoomIn:{open:"zoomIn",close:"zoomIn"},zoomOut:{open:"zoomOut",close:"zoomOut"},move:{open:"move",close:"move"},slide:{open:"slide",close:"slide"},flip:{open:"flip",close:"flip"},tada:{open:"tada",close:"zoomOut"}}[this.options.animation]);this.options.animation.open&&(this.options.animation.open=this.options.animation.open.split(":"));this.options.animation.close&&(this.options.animation.close=this.options.animation.close.split(":"));this.options.animation.openDirection=this.options.animation.open?this.options.animation.open[1]:null;this.options.animation.closeDirection=this.options.animation.close?this.options.animation.close[1]:null;this.options.animation.open&&(this.options.animation.open=this.options.animation.open[0]);this.options.animation.close&&(this.options.animation.close=this.options.animation.close[0]);this.options.animation.open&&(this.options.animation.open+="Open");this.options.animation.close&&(this.options.animation.close+="Close");var e={pulse:{duration:350,css:[["0%","scale(1)"],["50%","scale(1.1)"],["100%","scale(1)"]]},zoomInOpen:{duration:this.options.fade||180,css:[["0%","scale(0.9)"],["100%","scale(1)"]]},zoomInClose:{duration:this.options.fade||180,css:[["0%","scale(1)"],["100%","scale(0.9)"]]},zoomOutOpen:{duration:this.options.fade||180,css:[["0%","scale(1.1)"],["100%","scale(1)"]]},zoomOutClose:{duration:this.options.fade||180,css:[["0%","scale(1)"],["100%","scale(1.1)"]]},moveOpen:{duration:this.options.fade||180,positions:{top:{"0%":-12},right:{"0%":12},bottom:{"0%":12},left:{"0%":-12}},css:[["0%","translate%XY(%Vpx)"],["100%","translate%XY(0px)"]]},moveClose:{duration:this.options.fade||180,timing:"ease-in",positions:{top:{"100%":-12},right:{"100%":12},bottom:{"100%":12},left:{"100%":-12}},css:[["0%","translate%XY(0px)"],["100%","translate%XY(%Vpx)"]]},slideOpen:{duration:400,positions:{top:{"0%":-400},right:{"0%":400},bottom:{"0%":400},left:{"0%":-400}},css:[["0%","translate%XY(%Vpx)"],["100%","translate%XY(0px)"]]},slideClose:{duration:400,timing:"ease-in",positions:{top:{"100%":-400},right:{"100%":400},bottom:{"100%":400},left:{"100%":-400}},css:[["0%","translate%XY(0px)"],["100%","translate%XY(%Vpx)"]]},flipOpen:{duration:600,css:[["0%","perspective(400px) rotateX(90deg)"],["40%","perspective(400px) rotateX(-15deg)"],["70%","perspective(400px) rotateX(15deg)"],["100%","perspective(400px) rotateX(0deg)"]]},flipClose:{duration:this.options.fade||300,css:[["0%","perspective(400px) rotateX(0deg)"],["100%","perspective(400px) rotateX(90deg)"]]},tada:{duration:800,css:[["0%","scale(1)"],["10%, 20%","scale(0.9) rotate(-3deg)"],["30%, 50%, 70%, 90%","scale(1.1) rotate(3deg)"],["40%, 60%, 80%","scale(1.1) rotate(-3deg)"],["100%","scale(1) rotate(0)"]]}};jQuery.each(["pulse","tada"],function(t,n){e[n+"Open"]=e[n+"Close"]=e[n]});var t=function(t,n){keyframe_css="@"+this.prefix+"keyframes jBox-animation-"+this.options.animation[t]+"-"+t+(n?"-"+n:"")+" {";jQuery.each(e[this.options.animation[t]].css,function(r,i){var s=n?i[1].replace("%XY",this._getXY(n).toUpperCase()):i[1];e[this.options.animation[t]].positions&&(s=s.replace("%V",e[this.options.animation[t]].positions[n][i[0]]));keyframe_css+=i[0]+" {"+this.prefix+"transform:"+s+";}"}.bind(this));keyframe_css+="}";keyframe_css+=".jBox-animation-"+this.options.animation[t]+"-"+t+(n?"-"+n:"")+" {";keyframe_css+=this.prefix+"animation-duration: "+e[this.options.animation[t]].duration+"ms;";keyframe_css+=this.prefix+"animation-name: jBox-animation-"+this.options.animation[t]+"-"+t+(n?"-"+n:"")+";";keyframe_css+=e[this.options.animation[t]].timing?this.prefix+"animation-timing-function: "+e[this.options.animation[t]].timing+";":"";keyframe_css+="}";return keyframe_css}.bind(this);var n="";jQuery.each(["open","close"],function(r,i){if(!this.options.animation[i]||!e[this.options.animation[i]]||i=="close"&&!this.options.fade)return"";e[this.options.animation[i]].positions?jQuery.each(["top","right","bottom","left"],function(e,r){n+=t(i,r)}):n+=t(i)}.bind(this));jQuery("<style/>").append(n).appendTo(jQuery("head"))};this._blockBodyClick=function(){this.blockBodyClick=true;setTimeout(function(){this.blockBodyClick=false}.bind(this),10)};this.options.animation&&this._generateCSS();this._animate=function(e){if(this.IE8)return;e||(e=this.isOpen?"open":"close");if(!this.options.fade&&e=="close")return null;var t=this.options.animation[e+"Direction"]||(this.align!="center"?this.align:this.options.attributes.x);this.flipped&&this._getXY(t)==this._getXY(this.align)&&(t=this._getOpp(t));var n="jBox-animation-"+this.options.animation[e]+"-"+e+" jBox-animation-"+this.options.animation[e]+"-"+e+"-"+t;this.wrapper.addClass(n);var r=parseFloat(this.wrapper.css(this.prefix+"animation-duration"))*1e3;e=="close"&&(r=Math.min(r,this.options.fade));setTimeout(function(){this.wrapper.removeClass(n)}.bind(this),r)};this._abortAnimation=function(){if(this.IE8)return;var e="jBox-animation";var t=this.wrapper.attr("class").split(" ").filter(function(t){return t.lastIndexOf(e,0)!==0});this.wrapper.attr("class",t.join(" "))};this._adjustPosition=function(){if(!this.options.adjustPosition)return null;if(this.positionAdjusted){this.wrapper.css(this.pos);this.pointer&&this.wrapper.css("padding",0).css("padding-"+this._getOpp(this.outside),this.pointer.dimensions[this._getXY(this.outside)]).removeClass("jBox-pointerPosition-"+this._getOpp(this.pointer.position)).addClass("jBox-pointerPosition-"+this.pointer.position);this.pointer&&this.pointer.element.attr("class","jBox-pointer jBox-pointer-"+this._getOpp(this.outside)).css(this.pointer.margin);this.positionAdjusted=false;this.flipped=false}var e=jQuery(window);var t={x:e.width(),y:e.height(),top:e.scrollTop(),left:e.scrollLeft()};t.bottom=t.top+t.y;t.right=t.left+t.x;var n=t.top>this.pos.top-(this.options.adjustDistance.top||0),r=t.right<this.pos.left+this.dimensions.x+(this.options.adjustDistance.right||0),i=t.bottom<this.pos.top+this.dimensions.y+(this.options.adjustDistance.bottom||0),s=t.left>this.pos.left-(this.options.adjustDistance.left||0),o=s?"left":r?"right":null,u=n?"top":i?"bottom":null,a=o||u;if(!a)return;if(this.options.adjustPosition!="move"&&(o==this.outside||u==this.outside)){this.target=="mouse"&&(this.outside="right");if((this.outside=="top"||this.outside=="left"?t[this._getXY(this.outside)]-(this.targetDimensions[this._getTL(this.outside)]-t[this._getTL(this.outside)])-this.targetDimensions[this._getXY(this.outside)]:this.targetDimensions[this._getTL(this.outside)]-t[this._getTL(this.outside)])>this.dimensions[this._getXY(this.outside)]+this.options.adjustDistance[this._getOpp(this.outside)]){this.wrapper.css(this._getTL(this.outside),this.pos[this._getTL(this.outside)]+(this.dimensions[this._getXY(this.outside)]+this.options.offset[this._getXY(this.outside)]+this.targetDimensions[this._getXY(this.outside)])*(this.outside=="top"||this.outside=="left"?1:-1)).removeClass("jBox-pointerPosition-"+this.pointer.position).addClass("jBox-pointerPosition-"+this._getOpp(this.pointer.position));this.pointer&&this.wrapper.css("padding",0).css("padding-"+this.outside,this.pointer.dimensions[this._getXY(this.outside)]);this.pointer&&this.pointer.element.attr("class","jBox-pointer jBox-pointer-"+this.outside);this.positionAdjusted=true;this.flipped=true}}var f=this._getXY(this.outside)=="x"?u:o;if(this.pointer&&this.options.adjustPosition!="flip"&&this._getXY(f)==this._getOpp(this._getXY(this.outside))){if(this.pointer.align=="center"){var l=this.dimensions[this._getXY(f)]/2-this.pointer.dimensions[this._getOpp(this.pointer.xy)]/2-parseInt(this.pointer.element.css("margin-"+this.pointer.alignAttribute))*(f!=this._getTL(f)?-1:1)}else{var l=f==this.pointer.alignAttribute?parseInt(this.pointer.element.css("margin-"+this.pointer.alignAttribute)):this.dimensions[this._getXY(f)]-parseInt(this.pointer.element.css("margin-"+this.pointer.alignAttribute))-this.pointer.dimensions[this._getXY(f)]}spaceDiff=f==this._getTL(f)?t[this._getTL(f)]-this.pos[this._getTL(f)]+this.options.adjustDistance[f]:(t[this._getOpp(this._getTL(f))]-this.pos[this._getTL(f)]-this.options.adjustDistance[f]-this.dimensions[this._getXY(f)])*-1;if(f==this._getOpp(this._getTL(f))&&this.pos[this._getTL(f)]-spaceDiff<t[this._getTL(f)]+this.options.adjustDistance[this._getTL(f)]){spaceDiff-=t[this._getTL(f)]+this.options.adjustDistance[this._getTL(f)]-(this.pos[this._getTL(f)]-spaceDiff)}spaceDiff=Math.min(spaceDiff,l);if(spaceDiff<=l&&spaceDiff>0){this.pointer.element.css("margin-"+this.pointer.alignAttribute,parseInt(this.pointer.element.css("margin-"+this.pointer.alignAttribute))-spaceDiff*(f!=this.pointer.alignAttribute?-1:1));this.wrapper.css(this._getTL(f),this.pos[this._getTL(f)]+spaceDiff*(f!=this._getTL(f)?-1:1));this.positionAdjusted=true}}};this.options.onInit.bind(this)();this.options._onInit&&this.options._onInit.bind(this)();return this}jBox.prototype.attach=function(e,t){e||(e=jQuery(this.options.attach.selector));t||(t=this.options.trigger);e&&e.length&&jQuery.each(e,function(e,n){n=jQuery(n);if(!n.data("jBox-attached-"+this.id)){this.options.getContent=="title"&&n.attr("title")!=undefined&&n.data("jBox-getContent",n.attr("title")).removeAttr("title");this.attachedElements||(this.attachedElements=[]);this.attachedElements.push(n[0]);n.on(t+".jBox-attach-"+this.id,function(e){if(this.isOpen&&this.source[0]!=n[0])var r=true;this.source=n;!this.options.target&&(this.target=n);t=="click"&&this.options.preventDefault&&e.preventDefault();this[t=="click"&&!r?"toggle":"open"]()}.bind(this));this.options.trigger=="mouseenter"&&n.on("mouseleave",function(){this.close()}.bind(this));n.data("jBox-attached-"+this.id,t)}}.bind(this));return this};jBox.prototype.detach=function(e){e||(e=this.attachedElements||[]);e&&e.length&&jQuery.each(e,function(e,t){t=jQuery(t);if(t.data("jBox-attached-"+this.id)){t.off(t.data("jBox-attached-"+this.id+".jBox-attach-"+this.id));t.data("jBox-attached-"+this.id,null)}});return this};jBox.prototype.setTitle=function(e){if(e==null||e==undefined)return this;!this.wrapper&&this._create();if(!this.title){this.titleContainer=jQuery("<div/>",{"class":"jBox-title"});this.title=jQuery("<div/>").appendTo(this.titleContainer);this.wrapper.addClass("jBox-hasTitle");if(this.options.closeButton=="title"){this.wrapper.addClass("jBox-closeButton-title");this.closeButton.appendTo(this.titleContainer)}this.titleContainer.insertBefore(this.content)}this.title.html(e);this.position();return this};jBox.prototype.setContent=function(e){if(e==null)return this;!this.wrapper&&this._create();switch(jQuery.type(e)){case"string":this.content.html(e);break;case"object":this.content.children().css({display:"none"});this.options.content.appendTo(this.content).css({display:"block"});break}this.position();return this};jBox.prototype.position=function(e){e||(e={});this.target=e.target||this.target||this.options.target||jQuery(window);this.dimensions={x:this.wrapper.outerWidth(),y:this.wrapper.outerHeight()};if(this.target=="mouse")return;if(this.options.position.x=="center"&&this.options.position.y=="center"){this.wrapper.css({left:"50%",top:"50%",marginLeft:this.dimensions.x*-.5+this.options.offset.x,marginTop:this.dimensions.y*-.5+this.options.offset.y});return this}var t=this.target.offset();this.targetDimensions={x:this.target.outerWidth(),y:this.target.outerHeight(),top:t?t.top:0,left:t?t.left:0};this.pos={};var n=function(e){if(jQuery.inArray(this.options.position[e],["top","right","bottom","left","center"])==-1){this.pos[this.options.attributes[e]]=this.options.position[e];return}var t=this.options.attributes[e]=e=="x"?"left":"top";this.pos[t]=this.targetDimensions[t];if(this.options.position[e]=="center"){this.pos[t]+=Math.ceil((this.targetDimensions[e]-this.dimensions[e])/2);return}t!=this.options.position[e]&&(this.pos[t]+=this.targetDimensions[e]-this.dimensions[e]);(this.options.outside==e||this.options.outside=="xy")&&(this.pos[t]+=this.dimensions[e]*(t!=this.options.position[e]?1:-1))}.bind(this);n("x");n("y");if(this.options.pointer){var r=0;switch(this.pointer.align){case"center":if(this.options.position[this._getOpp(this.options.outside)]!="center"){r+=this.dimensions[this._getOpp(this.options.outside)]/2}break;default:switch(this.options.position[this._getOpp(this.options.outside)]){case"center":r+=(this.dimensions[this._getOpp(this.options.outside)]/2-this.pointer.dimensions[this._getOpp(this.options.outside)]/2)*(this.pointer.align==this._getTL(this.pointer.align)?1:-1);break;default:r+=this.pointer.align!=this.options.position[this._getOpp(this.options.outside)]?this.dimensions[this._getOpp(this.options.outside)]-this.pointer.dimensions[this._getOpp(this.options.outside)]/2:this.pointer.dimensions[this._getOpp(this.options.outside)]/2;break}break}r*=this.options.position[this._getOpp(this.options.outside)]==this.pointer.alignAttribute?-1:1;r+=this.pointer.offset*(this.pointer.align==this._getOpp(this._getTL(this.pointer.align))?1:-1);this.pos[this._getTL(this._getOpp(this.pointer.xy))]+=r}this.pos[this.options.attributes.x]+=this.options.offset.x;this.pos[this.options.attributes.y]+=this.options.offset.y;this.wrapper.css(this.pos);this._adjustPosition();return this};jBox.prototype.open=function(e){e||(e={});!this.wrapper&&this._create();this.timer&&clearTimeout(this.timer);this._blockBodyClick();if(this.isDisabled)return this;var t=function(){this.source&&this.options.getTitle&&this.source.attr(this.options.getTitle)!=undefined&&this.setTitle(this.source.attr(this.options.getTitle));this.source&&this.options.getContent&&(this.source.data("jBox-getContent")!=undefined?this.setContent(this.source.data("jBox-getContent")):this.source.attr(this.options.getContent)!=undefined?this.setContent(this.source.attr(this.options.getContent)):null);this.position({target:e.target});this.options.onOpen.bind(this)();this.options._onOpen&&this.options._onOpen.bind(this)();this.options.ajax&&(!this.ajaxLoaded||this.options.reload)&&this.ajax();this.isClosing&&this._abortAnimation();if(!this.isOpen){this.isOpen=true;this._attachEvents();this.options.blockScroll&&jQuery("body").addClass("jBox-blockScroll-"+this.id);this.options.overlay&&this._addOverlay();this.options.animation&&!this.isClosing&&this._animate("open");if(this.options.fade){this.wrapper.stop().animate({opacity:1},{queue:false,duration:this.options.fade,start:function(){this.isOpening=true;this.wrapper.css({display:"block"})}.bind(this),always:function(){this.isOpening=false}.bind(this)})}else{this.wrapper.css({display:"block",opacity:1})}}}.bind(this);this.options.delayOpen&&!this.isOpen&&!this.isClosing&&!e.ignoreDelay?this.timer=setTimeout(t,this.options.delayOpen):t();return this};jBox.prototype.close=function(e){e||(e={});this.timer&&clearTimeout(this.timer);this._blockBodyClick();if(this.isDisabled)return this;var t=function(){this.options.onClose.bind(this)();if(this.isOpen){this.isOpen=false;this._detachEvents();this.options.blockScroll&&jQuery("body").removeClass("jBox-blockScroll-"+this.id);this.options.overlay&&this._removeOverlay();this.options.animation&&!this.isOpening&&this._animate("close");this.source=null;if(this.options.fade){this.wrapper.stop().animate({opacity:0},{queue:false,duration:this.options.fade,start:function(){this.isClosing=true}.bind(this),complete:function(){this.wrapper.css({display:"none"});this.options.onCloseComplete&&this.options.onCloseComplete.bind(this)();this.options._onCloseComplete&&this.options._onCloseComplete.bind(this)()}.bind(this),always:function(){this.isClosing=false}.bind(this)})}else{this.wrapper.css({display:"none",opacity:0});this.options._onCloseComplete&&this.options._onCloseComplete.bind(this)()}}}.bind(this);e.ignoreDelay?t():this.timer=setTimeout(t,Math.max(this.options.delayClose,10));return this};jBox.prototype.toggle=function(e){this[this.isOpen?"close":"open"](e);return this};jBox.prototype.disable=function(){this.isDisabled=true;return this};jBox.prototype.enable=function(){this.isDisabled=false;return this};jBox.prototype.ajax=function(e){e||(e={});this.ajaxRequest&&this.ajaxRequest.abort();this.ajaxRequest=jQuery.ajax({url:e.url||this.options.ajax,data:e.data||this.options.data,beforeSend:function(){this.content.html("");this.wrapper.addClass("jBox-loading");this.position();this.options.onAjax.bind(this)()}.bind(this),complete:function(e){this.wrapper.removeClass("jBox-loading");this.content.html(e.responseText);this.position();this.ajaxLoaded=true;this.options.onAjaxComplete.bind(this)()}.bind(this)});return this};jBox.prototype.destroy=function(){this.close({ignoreDelay:true});this.wrapper.remove();return this};jQuery.fn.jBox=function(e,t){e||(e={});t||(t={});return new jBox(e,jQuery.extend(t,{attach:this}))};if(!Function.prototype.bind){Function.prototype.bind=function(e){var t=Array.prototype.slice.call(arguments,1),n=this,r=function(){},i=function(){return n.apply(this instanceof r&&e?this:e,t.concat(Array.prototype.slice.call(arguments)))};r.prototype=this.prototype;i.prototype=new r;return i}}


    return jBox;
} );
swifty.define( 'js/components/tooltip/tooltip',[
    'jquery',
    'swiftylib/component',
    'swiftylib/view',
    './jBox.min',
    // No return values:
    'css!./tooltip.css'
], function(
    $, Component, View, JBox
) {
    

    return Component.extend( {
        tag: 'swc_tooltip',
        template: '',
        scope: {
            for_sel: '@',
            title: '@',
            text: '@',
            content_sel: '@',
            content_width: '@',

            ini: function( $el ) {
                var self = this;
                var attach = $el.parent().find( self.attr( 'for_sel' ) );
                if( self.attr( 'for_sel' ) === '__parent' ) {
                    attach = $el.parent();
                }

                var content = self.attr( 'text' );
                if( self.attr( 'content_sel' ) ) {
                    content = $( self.attr( 'content_sel' ) );
                }

                var obj = {
                    attach: attach,
                    title: self.attr( 'title' ),
                    content: content,
                    width: 200,
                    reposition: true,
                    adjustTracker: true,
                    closeOnClick: true
                };

                if( self.attr( 'content_sel' ) ) {
                    obj.closeOnMouseleave = true;
                }

                if( self.attr( 'content_width' ) ) {
                    obj.width = self.attr( 'content_width' );
                }

                new JBox( 'Tooltip', obj );
            }
        },
        events: {
            inserted: function() {
                this.scope.ini( this.element );
            }
        }
    } );
} );

swifty.define('stache!js/components/form_input/form_input.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/components/form_input/form_input.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '{{convertValues}}\n<div class="swifty_form_input_wrapper">\n    <label>\n        {{#if label}}\n        <div class="swifty_form_label">\n            {{__ label}}\n            {{#if tooltip}}\n                <div class="swifty_form_label_question_button">\n                    <i class="fa fa-question"></i>\n                    <swc_tooltip for_sel=".swifty_form_label_question_button" {{#if tooltip_title}}title="{{__ tooltip_title}}"{{/if}} text="{{__ tooltip}}" />\n                </div>\n            {{/if}}\n        </div>\n        {{/if}}\n        <div class="swifty_form_input swifty_form_input_{{typ}}">\n            {{#if hasMultipleValues}}\n                {{#if isSelect}}\n                    <select class="span{{cols}}" name="{{name}}" can-value="{{_value}}" style="width:100%;">\n                    {{#each vals}}\n                        <option value="{{v_val}}">{{v_text}}</option>\n                    {{/each}}\n                    </select>\n                {{else}}\n                    {{#each vals}}\n                        <div class="swifty_form_input_multiple {{#eq direction \'vertical\'}}swifty_form_direction_vertical{{/eq}} {{#if v_icon}}swifty_form_input_multi_compact{{/if}}">\n                            <label>\n                                <{{tag}} class="span{{cols}}" name="{{name}}" can-value="{{_value}}" value="{{v_val}}"/>\n                                <div class="swifty_form_input_replacement">\n                                    {{#eq typ \'radio\'}}\n                                        {{#if v_icon}}\n                                            <i class="fa {{v_icon}}"></i>\n                                        {{else}}\n                                            <div>\n                                                <div></div>\n                                            </div>\n                                        {{/if}}\n                                    {{/eq}}\n                                </div>\n                                {{#if v_text}}\n                                    <div class="swifty_form_input_text">\n                                        {{__ v_text}}\n                                    </div>\n                                {{/if}}\n                            </label>\n                        </div>\n                    {{/each}}\n                {{/if}}\n            {{else}}\n                <label>\n                    <{{tag}} class="span{{cols}}" name="{{name}}" can-value="{{_value}}"{{#eq typ \'checkbox\'}} can-true-value="1" can-false-value="0"{{/eq}} style="{{#eq preferred_width \'\'}}{{else}} width: {{preferred_width}}px;{{/eq}}"/>\n                    <div class="swifty_form_input_replacement">\n                        {{#eq typ \'checkbox\'}}\n                            <div>\n                                <i class="fa fa-check"></i>\n                            </div>\n                        {{/eq}}\n                    </div>\n                    {{#if text}}\n                        <div class="swifty_form_input_text">\n                            {{__ text}}\n                        </div>\n                    {{/if}}\n                {{/if}}\n            </label>\n        </div>\n    </label>\n</div>\n' ); return idn; });


swifty.define('css!js/components/form_input/form_input',[],function(){});
swifty.define( 'js/components/form_input/form_input',[
    'jquery',
    'swiftylib/component',
    'swiftylib/view',
    'stache!./form_input.stache',
    // No return values:
    'css!./form_input.css'
], function(
    $, Component, View, tmpl
) {
    

    return Component.extend( {
        tag: 'swifty_form_input',
        template: new View( tmpl ),
        scope: {
            tag: 'input type="text"',
            typ: 'text',
            label: '@',
            name: '@',
            text: '@',
            tooltip: '@',
            tooltip_title: '@',
            _value: '@',
            direction: '@',
            preferred_width: '@'
        },
        events: {},
        helpers: {
            convertValues: function ( /*opts*/ ) {
                var self = this;
                var values2 = self.attr( 'values' ) + '';
                if( self.attr( 'values' ) && /|/.test( values2 ) ) {
                    var values = values2.split( '|' );
                    self.attr( 'vals', [] );
                    $.each( values, function( ii, val ) {
                        var v = val;
                        var text;
                        var icon;
                        var valArray = val.split( '^' );
                        if( valArray.length > 1 ) {
                            v = valArray[ 0 ];
                            text = valArray[ 1 ];
                            icon = valArray[ 2 ];
                        }
                        self.attr( 'vals' ).push( {
                            v_val: v,
                            v_text: text,
                            v_icon: icon
                        } );
                    } );
                    self.attr( 'hasMultipleValues', true );
                } else {
                    self.attr( 'hasMultipleValues', false );
                }
                self.attr( 'isSelect', self.attr( 'typ' ) === 'select' );
            }
        }
    } );
} );
swifty.define( 'js/components/form_checkbox/form_checkbox',[
    '../form_input/form_input'
], function(
    FormInput
) {
    

    return FormInput.extend( {
        tag: 'swifty_form_checkbox',
        scope: {
            tag: 'input type="checkbox"',
            typ: 'checkbox',
            label: '@',
            values: '',
            name: '@',
            text: '@',
            tooltip: '@',
            tooltip_title: '@',
            _value: '@'
        }
    } );
} );
swifty.define( 'js/components/form_radiobutton/form_radiobutton',[
    '../form_input/form_input'
], function(
    FormInput
) {
    

    return FormInput.extend( {
        tag: 'swifty_form_radiobutton',
        scope: {
            tag: 'input type="radio"',
            typ: 'radio',
            label: '@',
            values: '@',
            name: '@',
            text: '@',
            tooltip: '@',
            tooltip_title: '@',
            _value: '@',
            direction: '@'
        }
    } );
} );
swifty.define( 'js/components/form_textarea/form_textarea',[
    '../form_input/form_input'
], function(
    FormInput
) {
    

    return FormInput.extend( {
        tag: 'swifty_form_textarea',
        scope: {
            tag: 'textarea',
            typ: 'textarea',
            label: '@',
            values: '',
            name: '@',
            text: '@',
            tooltip: '@',
            tooltip_title: '@',
            _value: '@'
        }
    } );
} );

swifty.define('stache!js/components/colorpicker/colorpicker.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/components/colorpicker/colorpicker.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<input class="swifty_colorpicker_input" can-value="{color}" />\n<div class="swifty_colorpicker_none"><i class="fa fa-trash"></i></div>\n<div class="swifty_colorpicker_iris"></div>\n' ); return idn; });


swifty.define('css!js/components/colorpicker/colorpicker',[],function(){});
swifty.define( 'js/components/colorpicker/colorpicker',[
    'jquery',
    '../form_input/form_input',
    './../tooltip/jBox.min',
    'swiftylib/view',
    'swiftylib/map',
    'stache!./colorpicker.stache',
    // No return values:
    'css!./colorpicker.css'
], function(
    $, FormInput, JBox, View, Map, tmpl
) {
    

    // we need a unique id for the on click events
    var swifty_colorpicker_next_id = 0;

    // remember which colorpicker was opened, so we can close it when another opens
    var last_opened_colorpicker = undefined;

    return FormInput.extend( {
        tag: 'swifty_colorpicker',
        scope: {
            tag: 'input type="text"',
            typ: 'text',
            label: '@',
            values: '@',
            name: '@',
            text: '@',
            tooltip: '@',
            tooltip_title: '@',
            _value: '@',
            colorpicker_id: '',
            colorpicker: undefined,

            ini: function( $el ) {
                var self = this;

                var $input = $el.find( 'input:first' );
                var $previewButton;

                self.attr('colorpicker_id', 'swifty_colorpicker_' + ( swifty_colorpicker_next_id++ ) );

                // Replace the visual input field by a preview 'button'
                $input
                    .css( 'display', 'none' )
                    .after( '<div id="' + self.colorpicker_id + '" class="swifty_colorpicker_preview"></div>' );

                $previewButton = $el.find( '.swifty_colorpicker_preview' );
                $previewButton.css( 'background-color', $input.val() );

                // Create the popup for the color picker
                new JBox( 'Confirm', {
                    attach: $( '#' + self.colorpicker_id ),
                    content: $( '<div class="swifty_colorpicker_popup"></div>' ),
                    position: {
                        x: 'center',
                        y: 'top'
                    },
                    outside: 'y',
                    reposition: true,
                    adjustTracker: true,
                    adjustPosition: 'move',
                    pointer: 'center',
                    closeOnClick: 'body',
                    addClass: 'swifty_colorpicker_popup_wrapper',

                    onOpen: function() {

                        if( last_opened_colorpicker ) {
                            last_opened_colorpicker.close( { ignoreDelay: true } );
                            last_opened_colorpicker = null;
                        }
                        last_opened_colorpicker = this;

                        var info_data = new Map( {
                            color: $input.val()
                        } );

                        info_data.bind( 'change', function( ev, attr, how, newVal/*, oldVal*/ ) {
                            $previewButton.css( 'background-color', newVal );
                            $input.val( newVal );
                            $input.trigger( 'keyup' );
                        } );

                        var template = new View( tmpl, info_data );
                        this.content.html( template );

                        this.content.find( '.swifty_colorpicker_none' ).on( 'click', function( /*ev*/ ) {
                            info_data.attr( 'color', '' );
                        } );

                        // Create the WP Iris color picker
                        this.content.find( '.swifty_colorpicker_input' ).iris( {
                            change: function( event, ui ) {
                                $previewButton.css( 'background-color', ui.color.toString() );
                                $input.val( ui.color.toString() );
                                $input.trigger( 'keyup' );
                                info_data.attr( 'color', $input.val() );
                            },
                            width: 200,
                            hide: false,
                            border: false,
                            target: this.content.find( '.swifty_colorpicker_iris' )[0]
                        } );

                        self.attr('colorpicker', this );

                        // Resize and reposition the popup, because Iris changed the size of the popup
                        this.position();
                    },
                    onClose: function() {
                        last_opened_colorpicker = null;
                        if( this.content ) {
                            this.content.find( '.swifty_colorpicker_none' ).off( 'click' );
                        }
                    }
                } );
            }
        },
        events: {
            inserted: function() {
                this.scope.ini( this.element );
            },

            removed: function() {
                // we need this when user close the panels by clicking somewhere in the content
                if( this.scope.attr( 'colorpicker' ) !== undefined ) {
                    var picker = this.scope.attr( 'colorpicker' );
                    this.scope.attr( 'colorpicker', null );
                    picker.destroy();
                }
            }
        }
    } );
} );

swifty.define('stache!js/components/form_link/form_link.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/components/form_link/form_link.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '{{#if url_selectable}}\n   <swifty_form_radiobutton name="link_type" _value=\'{link_type}\' values="P^{{__ \'Page\'}}^|U^{{__ \'URL\'}}" label="{{__ \'Link to page or URL\'}}" class="swifty_form_line_below" />\n   {{#if is_url}}\n       <swifty_form_input name="url" _value=\'{url}\' label="{{__ \'URL\'}}" />\n   {{/if}}\n{{/if}}\n{{#if is_page}}\n    <swifty_form_select name="page_id" _value=\'{page_id}\' values="{{pages}}" label="{{__ \'Page\'}}" />\n{{/if}}' ); return idn; });

swifty.define( 'js/components/form_link/form_link',[
    'jquery',
    '../form_input/form_input',
    'swiftylib/view',
    'swiftylib/i18n/__',
    'stache!./form_link.stache',
    'swiftylib/map'
], function(
    $, FormInput, View, __, tmpl, Map
) {
    

    return FormInput.extend( {
        tag: 'swifty_form_link',

        scope: {
            tag: 'input type="text"',
            typ: 'text',
            label: '@',
            values: '',
            name: '@',
            text: '@',
            tooltip: '@',
            tooltip_title: '@',
            _value: '@',
            url_selectable: '@',

            ini: function ($el) {
                var self = this;

                var $input = $el.find( 'input:first' );

                var $label = $el.find( '.swifty_form_label:first' );

                // Replace the visual input field by a template with the inputs we need
                $label
                    .css( 'display', 'none' );

                $input
                    .css( 'display', 'none' );

                // get the pages with a ajax call and render the template instead of the original content.
                // use the original value of the input for the link information
                $.post(
                    scc_data.ajax_url,
                    {
                        'action': 'swcreator_get_page_list',
                        'ajax_nonce': scc_data.ajax_nonce,
                        'id': scc_data.page_id
                    },
                    function( data ) {

                        var pages = '';

                        var builder = function buildpagelist(data_, indent) {
                            var page, index;
                            var pages = '';
                            for( index = 0; index < data_.length; ++index ) {
                                page = data_[index];
                                if(page.menu) {
                                    pages = pages + '|' + buildpagelist(page.menu, indent + '-');
                                } else {
                                    if( pages !== '' ) {
                                        pages = pages + '|';
                                    }
                                    pages = pages + page.id + '^' + indent + page.title;
                                }
                            }
                            return pages;
                        };

                        var firstOption = self.attr( 'url_selectable' ) === '0' ? __( 'All pages' ) : '';

                        // add empty page link at the start
                        pages = '-1^' + firstOption + '|' + builder( data, '' );

                        var info_data = new Map( {
                            is_page: false,
                            is_url: false,
                            link_type: 'P',
                            page_id: -1,
                            url: $input.val(),
                            pages: pages,
                            url_selectable: self.attr( 'url_selectable' ) === '1',
                            label: ( self.attr( 'label' ) ? self.attr( 'label' ) : _( 'Page' ) )
                        } );

                        // link info: <link type>^^^<page id>^^^<page title>
                        var value = $input.val();
                        var splitted_value = value.split( '^^^' );
                        if( splitted_value.length > 2 ) {
                            info_data.attr( 'link_type' , splitted_value[ 0 ]);
                            info_data.attr( 'page_id' , splitted_value[ 1 ] * 1);
                            info_data.attr( 'url' , splitted_value[ 2 ]);
                        }

                        info_data.attr( 'is_page', info_data.attr( 'link_type' ) === 'P' );
                        info_data.attr( 'is_url', info_data.attr( 'link_type' ) === 'U' );

                        info_data.bind( 'change', function( /*ev, attr, how, newVal, oldVal*/ ) {
                            var url = this.attr( 'url' );
                            var link_type = this.attr( 'link_type' );
                            info_data.attr( 'is_page', link_type === 'P' );
                            info_data.attr( 'is_url', link_type === 'U' );
                            var page_id = this.attr( 'page_id' );

                            $input.val( [ link_type, page_id, url ].join( '^^^' ) );

                            $input.trigger( 'keyup' );
                        });

                        var template = new View( tmpl, info_data );

                        $input
                            .after( template );
                    }
                );
            }
        },
        events: {
            inserted: function() {
                this.scope.ini( this.element );
            }
        }
    } );
} );
swifty.define( 'js/components/form_select/form_select',[
    '../form_input/form_input'
], function(
    FormInput
) {
    

    return FormInput.extend( {
        tag: 'swifty_form_select',
        scope: {
            tag: 'select',
            typ: 'select',
            label: '@',
            values: '@',
            name: '@',
            text: '@',
            tooltip: '@',
            tooltip_title: '@',
            _value: '@'
        }
    } );
} );

swifty.define('stache!js/components/icon_button/icon_button.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/components/icon_button/icon_button.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '{{convertFAIcons}}\n<div class="swifty_form_input_wrapper">\n    <div class="swc_button swc_icon_button{{#if type}} swc_{{type}}{{/if}}{{#if action}} swc_{{action}}{{/if}}">\n        {{#if icon}}\n        <div class="swc_icon">\n            <span aria-hidden="true">{{icon}}</span>\n        </div>\n        {{/if}}\n        {{#if fa_icon}}\n        <div class="swc_icon">\n            <i class="fa {{fa_icon}}"></i>\n        </div>\n        {{/if}}\n        {{#if text}}\n        <div class="swc_text">\n            {{__ text}}\n        </div>\n        {{/if}}\n    </div>\n</div>' ); return idn; });

swifty.define( 'js/components/icon_button/icon_button',[
    'jquery',
    'swiftylib/component',
    'swiftylib/view',
    'stache!./icon_button.stache'
], function(
    $, Component, View, tmpl
) {
    

    return Component.extend( {
        'tag': 'swc_icon_button',
        'template': new View( tmpl ),
        'scope': {
            'icon': '@',
            'text': '@',
            'action': '@',
            'type': '@'
        },
        'events': {}
    } );
} );

swifty.define('stache!js/components/column_icon/column_icon.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/components/column_icon/column_icon.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<div class="swc_column_icon">\n    <table>\n        <tr>\n        {{#each columns}}\n            <td width="{{width}}"></td>\n        {{/each}}\n        </tr>\n    </table>\n</div>' ); return idn; });

swifty.define( 'js/components/column_icon/column_icon',[
    'jquery',
    'swiftylib/component',
    'swiftylib/view',
    'stache!./column_icon.stache'
], function(
    $, Component, View, tmpl
    ) {
    

    return Component.extend( {
        'tag': 'swc_column_icon',
        'template': new View( tmpl ),
        'viewModel': {
            'cols': '@',
            define: {
                columns: {
                    get: function() {
                        var cols = [];

                        $.each( this.attr( 'cols' ).split( '-' ), function( index, width ) {
                            cols.push( { 'width': width + '%' } );
                        } );

                        return cols;
                    }
                }
            }
        },
        'events': {}
    } );
} );

swifty.define('css!js/components/iconpicker/iconpicker',[],function(){});
swifty.define( 'js/components/iconpicker/iconpicker',[
    'jquery',
    '../form_input/form_input',
    './../tooltip/jBox.min',
    // No return values:
    'css!./iconpicker.css'
], function(
    $, FormInput, JBox
) {
    

    // we need a unique id for the on click events
    var global_swifty_iconpicker_id = 0;

    return FormInput.extend( {
        tag: 'swifty_iconpicker',
        scope: {
            tag: 'input type="text"',
            typ: 'text',
            label: '@',
            values: '@',
            name: '@',
            text: '@',
            tooltip: '@',
            tooltip_title: '@',
            _value: '@',
            iconpicker_id: '',
            iconpicker_dialog: undefined,

            ini: function( $el ) {
                var self = this;

                self.iconpicker_id = 'swifty_iconpicker_' + ( global_swifty_iconpicker_id++ );

                // Replace the visual input field by a preview 'button'
                var $input = $el.find( 'input:first' );
                $input
                    .css( 'display', 'none' )
                    .after( '<div id="' + self.iconpicker_id + '" class="swifty_iconpicker_preview"></div>' );

                var $previewButton = $el.find( '.swifty_iconpicker_preview' );
                $previewButton.html( '<i class="fa ' + $input.val() + '"></i>' );
                $previewButton.css( 'background-color', '#ffffff' );
                $previewButton.css( 'text-align', 'center' );

                $.post(
                    scc_data.ajax_url,
                    {
                        'action': 'swcreator_get_fa_icon_list',
                        'ajax_nonce': scc_data.ajax_nonce,
                        'id': scc_data.page_id
                    },
                    function( data ) {

                        var content = '<div class="swifty_iconpicker_popup" id_picker="' + self.iconpicker_id + '" >' +
                            data.content +
                            '</div>';

                        // Create the popup for the color picker
                        self.iconpicker_dialog = new JBox( 'Confirm', {
                            attach: $( '#' + self.iconpicker_id ),
                            content: content,
                            position: {
                                x: 'center',
                                y: 'top'
                            },
                            width: 420,
                            height: 300,
                            adjustPosition: true,
                            outside: 'y',
                            closeOnClick: 'body',
                            closeOnMouseleave: true,
                            pointer: 'center',
                            addClass: 'swifty_iconpicker_popup_wrapper',
                            onCreated: function () {
                                var $picker = this.content.find( '.swifty_iconpicker_popup' );
                                var $icons = $picker.children( 'i' );
                                $icons.click(function ( /*e*/ ) {
                                    // this: is the clicked <i>
                                    var $selected_icon = $( this );
                                    var $previewButton = $( '#' + $selected_icon.parent().attr( 'id_picker' ) );
                                    var $input = $previewButton.parent().find( 'input:first' );

                                    $input.val( $selected_icon.attr( 'class' ).substring( 3 ) );
                                    $previewButton.html( '<i class="fa ' + $input.val() + '"></i>' );
                                    $input.trigger( 'keyup' );
                                });

                                // Resize and reposition the popup, because Iris changed the size of the popup
                                this.position();
                            }
                        });
                    }
                );
            }
        },
        events: {
            inserted: function() {
                this.scope.ini( this.element );
            },
            removed: function() {
                if( this.scope.iconpicker_dialog ) {
                    try {
                        this.scope.iconpicker_dialog.detach();
                        this.scope.iconpicker_dialog.destroy();
                    } catch( err ) {
                        // simply ignore exceptions here
                    }
                }
            }
        }
    } );
} );

swifty.define('stache!js/components/dialog/dialog.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/components/dialog/dialog.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<div class="swc_dialog_wrapper">\n    <div class="swc_dialog_window swc_panel">\n        <div class="swc_dialog_header_pane">\n            <div class="swc_panel_title_icon">&#xe03d</div>\n            <div class="swc_title">\n                {{__ map.title}}\n            </div>\n            <div class="swc_back_button swc_button" ($click)=\'closeDialog(.)\'>\n                &#xe900;\n            </div>\n        </div>\n        <div class="swc_dialog_content_pane">\n            <div class="swc_dialog_content_pane_inner">\n                <div class="swc_dialog_content_pane_html">\n                    <content/>\n                    {{&map.html}}\n                </div>\n                {{#if map.show_iframe}}\n                    <iframe src="{{map.url}}" onload="jQuery( \'.swc_ifr_loading\' ).addClass( \'swc_ifr_l_hide\' );"></iframe>\n                    <div class="swc_ifr_loading"><i class="fa fa-spinner fa-spin fa-fw"></i></div>\n                {{/if}}\n            </div>\n            <div class="swc_content_gradient"></div>\n        </div>\n        <div class="swc_dialog_footer_pane {{#if map.small_header}}swc_dialog_ftr_small{{/if}}">\n            <div class="swc_dialog_footer_t">\n                {{#if map.show_checkbox_delete}}\n                    <swifty_form_checkbox name="swc_position" _value="map.checkbox_delete" text="{{__ \'Hide this message\'}}{{map.test}}" />\n                {{/if}}\n            </div>\n            {{#is map.total_nr 0}}\n            {{else}}\n                <div class="swc_panel_presets_choose_container">\n                    <div class="swc_button swc_dialog_previous" ($click)=\'previous(.)\'>\n                        <i class="fa fa-chevron-left"></i>\n                    </div>\n                    <div class="swc_title swc_preset_nr_tot">\n                        {{map.active_nr}}/{{map.total_nr}}\n                    </div>\n                    <div class="swc_button swc_dialog_next" ($click)=\'next(.)\'>\n                        <i class="fa fa-chevron-right"></i>\n                    </div>\n                </div>\n            {{/is}}\n        </div>\n    </div>\n</div>' ); return idn; });


swifty.define('css!js/components/dialog/dialog',[],function(){});
swifty.define( 'js/components/dialog/dialog',[
    'jquery',
    'swiftylib/evt',
    'swiftylib/component',
    'swiftylib/view',
    'stache!js/components/dialog/dialog.stache',
    // No return values:
    'css!js/components/dialog/dialog.css',
    'can/map/define'
], function(
    $, evt, Component, View, tmpl
) {
    

    return Component.extend( {
        tag: 'swc_dialog',
        template: new View( tmpl ),
        viewModel: {
            map: '@',

            ini: function( $el ) {
                $el.on( 'click', '.swc_dialog_click', function ( ev ) {
                    evt( 'dialog_action', {
                        'action': $( ev.currentTarget ).attr( 'data-swc_dialog_action' ),
                        'data': $( ev.currentTarget ).attr( 'data-swc_dialog_data' ),
                        '$el': $( ev.currentTarget )
                    } );
                } );
            },

            closeDialog: function( /*panel*/ ) {
                evt( 'dialog_close' );
            },
            
            next: function( /*panel*/ ) {
                evt( 'dialog_next' );
            },
            
            previous: function( /*panel*/ ) {
                evt( 'dialog_previous' );
            }
        },
        events: {
            inserted: function() {
                this.scope.ini( this.element );
            }
        }
    } );
} );

swifty.define('stache!js/components/form_color_default/form_color_default.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/components/form_color_default/form_color_default.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<swifty_form_radiobutton name="color_{{original_name}}" _value=\'{color_default}\' values="default^{{__ \'Default\'}}^|custom^{{__ \'Custom\'}}" label="{{original_label}}" class="swifty_form_line_below" />\n{{#if is_custom_color}}\n    <swifty_colorpicker movetoid="color_{{original_name}}_custom" name="custom_{{original_name}}" _value="{custom_color}" label="{{__ \'Custom color\'}}"/>\n{{/if}}\n' ); return idn; });

swifty.define( 'js/components/form_color_default/form_color_default',[
    'jquery',
    '../form_input/form_input',
    'swiftylib/view',
    'stache!./form_color_default.stache',
    'swiftylib/map'
], function(
    $, FormInput, View, tmpl, Map
) {
    

    return FormInput.extend( {
        tag: 'swifty_form_color_default',

        scope: {
            tag: 'input type="text"',
            typ: 'text',
            label: '@',
            values: '',
            name: '@',
            text: '@',
            tooltip: '@',
            tooltip_title: '@',
            _value: '@',
            'default': '@',

            ini: function ($el) {

                var self = this;
                var $input = $el.find('input:first');

                var $label = $el.find('.swifty_form_label:first');

                // Replace the visual input field by a template with the inputs we need
                $label
                    .css('display', 'none');

                $input
                    .css('display', 'none');

                var value = $input.val();

                var info_data = new Map({
                    is_custom_color: false,
                    color_default: 'default',
                    custom_color: value,
                    original_label: self.label,
                    original_name: self.name
                });

                if (value === '') {
                    info_data.attr('color_default', 'default');
                    info_data.attr( 'custom_color', self[ 'default' ] );
                    info_data.attr('is_custom_color', false);
                } else {
                    info_data.attr('color_default', 'custom');
                    info_data.attr('custom_color', value);
                    info_data.attr('is_custom_color', true);
                }

                info_data.bind('change', function( /*ev, attr, how, newVal, oldVal*/ ) {
                    if (info_data.attr( 'color_default') === 'default' ) {
                        info_data.attr('is_custom_color', false);
                        $input.val('');
                    } else {
                        info_data.attr('is_custom_color', true);
                        $input.val(info_data.attr('custom_color'));
                    }
                    $input.trigger('keyup');
                });

                var template = new View(tmpl, info_data);

                $input
                    .after(template);
            }
        },
        events: {
            inserted: function() {
                this.scope.ini( this.element );
            }
        }
    } );
} );

swifty.define('css!js/panels/panel/panel',[],function(){});
swifty.define( 'js/panels/panel/panel',[
    'jquery',
    'swiftylib/evt',
    'swiftylib/control',
    'swiftylib/view',
    'swiftylib/map',
    'js/panels/panel_stack/panel_stack_instance',
    'swiftylib/i18n/__',
    'stache!js/panels/panel/panel.stache',
    // No return values:
    'js/components/panel_button/panel_button',
    'js/components/tooltip/tooltip',
    'js/components/form_input/form_input',
    'js/components/form_checkbox/form_checkbox',
    'js/components/form_radiobutton/form_radiobutton',
    'js/components/form_textarea/form_textarea',
    'js/components/colorpicker/colorpicker',
    'js/components/form_link/form_link',
    'js/components/form_select/form_select',
    'js/components/icon_button/icon_button',
    'js/components/column_icon/column_icon',
    'js/components/iconpicker/iconpicker',
    'js/components/dialog/dialog',
    'js/components/form_color_default/form_color_default',
    'css!js/panels/panel/panel.css'
], function(
    $, evt, Control, View, Map, panelStackInstance, __, tmpl
) {
    

    return Control.extend( {
        'defaults': {
            'title': '???',
            'panel_css_class': '',
            'back_action': '',
            'show_screen_size': true,
            'show_panel_extra': false,
            'show_save_panel': false,
            'is_easy_mode': false,
            'state_saving': 0,
            'save_leave_msg':__( 'Please do not leave the page while we are still saving the changes.' ),
            'tmpl': tmpl
        }
    }, {
        init: function() {
            var self = this;

            // self.options.show_screen_size = scc_data.is_swifty_site_designer_active;
            self.options.show_save_panel = scc_data.area === 'main';
            self.options.is_easy_mode = scc_data.swifty_gui_mode === 'easy';
            self.options.map = new Map( {
                'text_save_state': __( 'Saved' ),
                'save_panel_state': 'swc_enabled',
                'save_panel_tooltip': '',
                'editor_visibility': +scc_data.editor_visibility ? false : true,   // '0' or '1'
                'show_undo_redo': true,
                'show_main_menu': false
            } );
            self.element.html( new View( self.options.tmpl )(
                self.options, {
            } ) );

            self.setStateSaving( 0 );

            self._super();

            self.on();

            // make sure the undo redo state is properly set when opening (sub)panels
            evt( 'check_can_undo_redo' );

            setTimeout( function() {
                evt( 'fix_panel_heights', { 'redraw_element': $( self.element ).find( '.swc_panel_content_nowrap' ) } );
            }, 1 );
        },

        closePanel: function() {
            panelStackInstance.closePanel( this.element );
        },

        markCloseOnFocus: function() {
            this.element.addClass( 'swc_panel_marked_close' );
        },

        setIFrameWidth: function( width ) {
            $( '#swc_iframe' ).css( 'width', width );
        },

        '.swc_back_button click': function( /*el, ev*/ ) {
            this.closePanel();
        },

        // Click on screen size icons
        
        '{window} click': function( $el, ev ) {
            $el = $( ev.target ).closest( '.swc_main_scrsize' );
            if( $el.length > 0 ) {
                var width = '';

                if( $el.hasClass( 'swc_main_desktop' ) ) {
                    width = '100%';
                    this.options.options_map.attr( 'mobile_view', 'desktop' );
                }
                if( $el.hasClass( 'swc_main_tablet' ) ) {
                    width = '768px';
                    this.options.options_map.attr( 'mobile_view', 'tablet' );
                }
                if( $el.hasClass( 'swc_main_mobile' ) ) {
                    width = '320px';
                    this.options.options_map.attr( 'mobile_view', 'mobile' );
                }

                if( width !== '' ) {
                    this.setIFrameWidth( width );

                    //if ( width === '320px' ) {
                    //    $( '.swifty_area_frame' ).addClass( 'swc_display_small' );
                    //} else {
                    //    $( '.swifty_area_frame' ).removeClass( 'swc_display_small' );
                    //}
                }
            }
        },

        '.swc_main_undo click': function() {
            evt( 'ckeditor_command', {
                'command': 'undo'
            } );
        },

        '.swc_main_redo click': function() {
            evt( 'ckeditor_command', {
                'command': 'redo'
            } );
        },

        '.swc_main_editor click': function() {
            var self = this;
            // only needed when toggled, event is called twice
            var current_showIt = this.options.map.attr( 'editor_visibility' ) ? 1 : 0;

            evt( 'editor_visibility', {
                'show_it': current_showIt
            } ).then( function( showIt ) {
                self.setEditorVisibilityState( showIt );
            } );
        },

        setEditorVisibilityState: function( showIt ) {
            var newShowIt = +showIt ? false : true;

            if( this.options.map.attr( 'editor_visibility' ) !== newShowIt ) {
                this.options.map.attr( 'editor_visibility', newShowIt );
            }
        },

        '{window} evt_swc_reset_mobile_view': function( /*el, ev, opts*/ ) {
            this.setIFrameWidth( '100%' );
        },

        '{window} evt_swc_set_editor_visibility_state': function( el, ev, opts ) {
            this.setEditorVisibilityState( opts.show_it );
        },

        '{window} evt_swc_editor_toolbar_minimize': function( el, ev, opts ) {
            this.animateCKEditorToggle( opts.position_start );
        },

        animateCKEditorToggle: function( position_start )  {
            var $toggleButton = $( '.swc_panel_visible' ).find( '.swc_main_editor' );

            if( ( $toggleButton.length === 1 ) ) {

                var offset = $toggleButton.offset();
                var posX = offset.left;
                var posY = ( offset.top - $( window ).scrollTop() );

                var position_end = {
                    'top': posY + 'px',
                    'left': posX + 'px',
                    'width': $toggleButton.css( 'width' ),
                    'height': $toggleButton.css( 'height' ),
                    'background': '#f0f0f0'
                };

                var $toggler = $( '<div id="ckedit_toggler"></div>' ).appendTo( 'body' );

                // start at the editor toolbar
                $toggler.css( position_start );

                // show animation
                $toggler.animate( {
                        'opacity': 0.8
                    }, 25, function() {
                        // move to toggle button
                        $toggler.animate(
                            position_end,
                            700, function() {
                                // hide animation
                                $toggler.animate( {
                                        'opacity': 0
                                    }, 50, function() {
                                        $toggler.remove();
                                    }
                                );
                            }
                        );
                    }
                );
            }
        },

        '{window} evt_swc_animate_clipboard_copy': function( el, ev, opts ) {
            this.animateClipboardCopy( opts.$element );
        },

        animateClipboardCopy: function( $element ) {

            if( $element.length === 1 ) {

                var offset = $element.offset();
                var posX = offset.left;
                var posY = offset.top - $('#swc_iframe').contents().scrollTop();

                var position_start = {
                    'top': posY + 'px',
                    'left': posX + 'px',
                    'width': $element.css( 'width' ),
                    'height': $element.css( 'height' ),
                    'opacity': 0,
                    'background': '#f0f0f0',
                    'position': 'fixed',
                    'z-index': 10001
                };

                var $toggleButton = $( '.swc_panel_visible' ).find( '.swc_panel_button_add_content' );

                if( ( $toggleButton.length === 1 ) ) {

                    offset = $toggleButton.offset();
                    posX = offset.left;
                    posY = ( offset.top - $( window ).scrollTop() );

                    var position_end = {
                        'top': posY + 'px',
                        'left': posX + 'px',
                        'width': $toggleButton.css( 'width' ),
                        'height': $toggleButton.css( 'height' ),
                        'background': '#f0f0f0'
                    };

                    var $toggler = $( '<div id="copy_content_toggler"></div>' ).appendTo( 'body' );

                    // start at element
                    $toggler.css( position_start );

                    // show animation
                    $toggler.animate( {
                            'opacity': 0.8
                        }, 25, function() {
                            // move to toggle button
                            $toggler.animate(
                                position_end,
                                700, function() {
                                    // hide animation
                                    $toggler.animate( {
                                            'opacity': 0
                                        }, 50, function() {
                                            $toggler.remove();
                                        }
                                    );
                                }
                            );
                        }
                    );
                }
            }
        },

        '{window} evt_swc_can_undo_redo': function( el, ev, data /*, dfd*/ ) {
            $( '.swc_main_scrsize.swc_main_undo' ).toggleClass( 'swc_enabled', data.can_undo );
            $( '.swc_main_scrsize.swc_main_redo' ).toggleClass( 'swc_enabled', data.can_redo );
        },

        setStateSaving: function( state ) {
            var self = this;

            if( this.options.state_saving !== state ) {
                this.options.state_saving = state;
                if( this.options.map ) {
                    if( state !== 2 ) {
                        self.options.map.attr( 'save_panel_state', 'swc_enabled' );
                        self.options.map.attr( 'save_panel_tooltip', __( 'Manually saving is not necessary because all changes are automatically saved (but not yet published).' ) );
                    } else {
                        self.options.map.attr( 'save_panel_state', 'swc_error' );
                        self.options.map.attr( 'save_panel_tooltip', __( 'ATTENTION!!! There is a problem with saving this page. Try to click this button every 30 seconds until the button is no longer red. Also check if you still have a decent Internet connection. If you do not do this, you might lose your latest changes.' ) );
                    }
                    switch( state ) {
                        case 0:
                            this.options.map.attr( 'text_save_state', __( 'Saved' ) );
                            break;
                        case 1:
                            this.options.map.attr( 'text_save_state', __( 'Saving...' ) );
                            break;
                        case 2:
                            this.options.map.attr( 'text_save_state', __( 'Save failed' ) );
                            break;
                    }
                }
            }
        },

        setStateSavingStarted: function() {
            var self = this;

            self.setStateSaving( 1 );

            // Make sure when users leaves the page before saving is doen, the browsers issues a default warning
            window.onbeforeunload = function( e ) {
                // If we haven't been passed the event get the window.event
                e = e || window.event;
                var message = self.options.save_leave_msg;
                // For IE6-8 and Firefox prior to version 4
                if( e ) {
                    e.returnValue = message;
                }
                // For Chrome, Safari, IE8+ and Opera 12+
                return message;
            };
        },

        '{window} evt_swc_saving_throttled_started': function( /*el, ev, opts*/ ) {
            this.setStateSavingStarted();
        },

        '{window} evt_swc_saving_started': function( /*el, ev, opts*/ ) {
            this.setStateSavingStarted();
        },

        '{window} evt_swc_saving_done': function( el, ev, opts, dfd ) {
            var self = this;
            self.setStateSaving( 0 );

            // Saving is done. User is free to leave the page
            window.onbeforeunload = null;

            dfd.resolve();
        },

        '{window} evt_swc_saving_failed': function( /*el, ev, opts*/ ) {
            var self = this;
            self.setStateSaving( 2 );
        }
    } );
} );
swifty.define( 'js/panels/asset_base/asset_base',[
    'jquery',
    'swiftylib/evt',
    'js/panels/panel/panel'
], function(
    $, evt, Panel
) {
    

    return Panel.extend( {
        'defaults': {
            'asset_instance': undefined, // must be set when instantiated
            'mode': undefined
        }
    }, {
        init: function() {
            var self = this;
            var asset = self.options.asset_instance;

            self.options.asset_data = asset ? asset.getAssetData() : {};
            self.options.ucname = asset ? asset.getAssetNameTranslated() : '';
            self.options.lcname = self.options.ucname ? self.options.ucname.toLowerCase() : '';
            self.options.is_block = asset && asset.options && asset.options.is_block;
            self.options.show_add_p_tags = asset && asset.options && ! asset.options.in_grid;

            self._super();
        }
    } );
} );


swifty.define('stache!js/panels/yes_no/yes_no.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/panels/yes_no/yes_no.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<div class="swc_panel_content_nowrap">\n    <swc_panel_button icon="{{no_icon}}" action="no" name="{{no_name}}"/>\n    <swc_panel_button icon="{{yes_icon}}" action="yes" name="{{yes_name}}"/>\n</div>\n' ); return idn; });

swifty.define( 'js/panels/yes_no/yes_no',[
    'jquery',
    'swiftylib/evt',
    'js/panels/panel/panel',
    'stache!./yes_no.stache'
], function(
    $, evt, Panel, tmpl
) {
    

    return Panel.extend( {
        'defaults': {
            'tmpl_content': tmpl,
            'title': '???',
            'yes_name': 'yes',
            'no_name': 'no',
            'yes_icon': '&#xe033;',
            'no_icon': '&#xe02f;'
        }
    }, {
        '.swc_panel_button_yes click': function() {
            evt( 'yes', { 'evt_el': this.options.evt_el }, this.options.evt_el );
        },

        '.swc_panel_button_no click': function() {
            evt( 'no', {}, this.options.evt_el );
        },

        '.swc_back_button click': function( /*el, ev*/ ) {
            // dojh by dorh This code does NOT belong here. Editor events have nothing to do with a generic yes/no panel!
            evt( 'swifty_editor_set_cursor' );
            evt( 'swifty_editor_set_asset_in_edit_mode' );

            this._super();
        }
    } );
} );


swifty.define('stache!js/panels/move_asset/move_asset.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/panels/move_asset/move_asset.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<div class="swc_panel_content_nowrap">\n    <swc_panel_button icon="&#xe02d;" action="up" name="{{__ \'Up\'}}"/>\n    <swc_panel_button icon="&#xe02e;" action="down" name="{{__ \'Down\'}}"/>\n    <swc_panel_button icon="&#xe02f;" action="left" name="{{__ \'Left\'}}"/>\n    <swc_panel_button icon="&#xe030;" action="right" name="{{_ \'Right\'}}"/>\n</div>\n' ); return idn; });

swifty.define( 'js/panels/move_asset/move_asset',[
    'jquery',
    'swiftylib/evt',
    'js/panels/panel/panel',
    'swiftylib/i18n/__',
    'stache!./move_asset.stache'
], function(
    $, evt, Panel, __, tmpl
) {
    

    return Panel.extend( {
        'defaults': {
            'tmpl_content': tmpl,
            'title': __( 'Move [lcname]' ),
            'title_tooltip': __( 'You can also move [t_type], by dragging the symbol at it\'s top right (when this panel is closed.)' ),
            't_type': __( 'content' )
        }
    }, {
        'swc_panel_button click': function( $el /*, ev*/ ) {
            evt( 'swifty_editor_move_asset', {
                'move': $el.attr( 'action' ),
                '$asset': this.options.asset_instance.getAssetContainer()
            } );
        },

        '.swc_back_button click': function( /*el, ev*/ ) {
            evt( 'swifty_editor_set_cursor', { '$asset': this.options.asset_instance.getAssetContainer() } );
            evt( 'swifty_editor_set_asset_in_edit_mode' );

            this._super();
        },

        '{window} evt_swc_swifty_editor_set_position': function( el, ev, data /*, dfd*/ ) {
            var assetData = this.options.asset_instance.getAssetData();
            var $assetEl = this.options.asset_instance.getAssetContainer();

            if( assetData.attr( 'swc_swifty_on' ) && $( data.el ).is( $assetEl ) ) {
                assetData.attr( 'swc_position', data.position );

                ev.stopImmediatePropagation();
            }
        }
    } );
} );


swifty.define('stache!js/panels/asset_main/asset_main.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/panels/asset_main/asset_main.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<div class="swc_panel_content_nowrap">\n    <swc_panel_button icon="&#xe03f;" action="edit_asset" name="{{__ \'Edit [lcname]\'}}"/>\n    <swc_panel_button icon="fa-exchange" action="change_layout" name="{{__ \'Change layout\'}}"/>\n    <swc_panel_button icon="fa-paint-brush" action="change_style" name="{{__ \'Change style\'}}"/>\n    {{#if is_block}}\n    <swc_panel_button icon="&#xe013;" action="move_asset" name="{{__ \'Move [lcname]\'}}"/>\n    <swc_panel_button icon="fa-copy" action="copy_asset" name="{{__ \'Copy [lcname]\'}}"/>\n    {{/if}}\n    <swc_panel_button icon="&#xe00b;" action="delete_asset" name="{{__ \'Delete [lcname]\'}}"/>\n    {{#if show_lock_ui}}\n    {{#if map.swc_locked}}\n    <swc_panel_button icon="fa-lock" action="unlock_asset" name="{{__ \'[ucname] is now locked\'}}"/>\n    {{/if}}\n    {{#if map.swc_unlocked}}\n    <swc_panel_button icon="fa-unlock" action="lock_asset" name="{{__ \'[ucname] is now unlocked\'}}"/>\n    {{/if}}\n    {{/if}}\n    {{#if is_block}}\n    {{#if show_add_p_tags}}\n    <!--<swc_panel_button icon="&#xe902" action="insert_p_above_asset" name="{{__ \'Insert text above\'}}"/>-->\n    <!--<swc_panel_button icon="&#xe901" action="insert_p_below_asset" name="{{__ \'Insert text below\'}}"/>-->\n    {{/if}}\n    {{/if}}\n</div>\n' ); return idn; });

swifty.define( 'js/panels/asset_main/asset_main',[
    'jquery',
    'swiftylib/evt',
    'js/diverse/page',
    'js/panels/asset_base/asset_base',
    'js/panels/panel_stack/panel_stack_instance',
    'js/panels/yes_no/yes_no',
    'js/panels/move_asset/move_asset',
    'swiftylib/i18n/__',
    'stache!js/panels/asset_main/asset_main.stache'
], function(
    $, evt, Page, AssetBase, panelStackInstance, YesNo, MoveAsset, __, tmpl
) {
    

    return AssetBase.extend( {
        'defaults': {
            'tmpl_content': tmpl,
            'title': '[ucname]'
        }
    }, {
        init: function() {
            this.options.show_lock_ui = scc_data.swifty_change_lock;

            this._super();

            this.options.map.attr( 'swc_locked', ( this.options.asset_data.attr( 'swc_locked' ) === '1' ? true : false ) );
            this.options.map.attr( 'swc_unlocked', ( this.options.asset_data.attr( 'swc_locked' ) === '1' ? false : true ) );

            evt( 'swifty_editor_set_asset_in_edit_mode', { '$asset': this.options.asset_instance.getAssetContainer() } );

            if( this.options.mode && ( this.options.mode === 'directedit' ) ) {
                this.markCloseOnFocus();
                $( '.swc_panel_button_edit_asset' ).click();
            }

            if( this.options.mode && ( this.options.mode === 'delete' ) ) {
                this.markCloseOnFocus();
                $( '.swc_panel_button_delete_asset' ).click();
            }

            if( this.options.mode && ( this.options.mode === 'move' ) ) {
                this.markCloseOnFocus();
                $( '.swc_panel_button_move_asset' ).click();
            }
        },

        '.swc_panel_button_edit_asset click': function() {
            //this.markCloseOnFocus();
            this.options.asset_instance.openEditPanel( 'edit' );
        },

        '.swc_panel_button_change_layout click': function() {
            //this.markCloseOnFocus();
            this.options.asset_instance.openEditPanel( 'position' );
        },

        '.swc_panel_button_change_style click': function() {
            //this.markCloseOnFocus();
            this.options.asset_instance.openEditPanel( 'style' );
        },

        '.swc_panel_button_delete_asset click': function() {
            //this.markCloseOnFocus();
            this.yesNoPanel = panelStackInstance.addPanel( YesNo, {
                'title': __( 'Delete [lcname]?' ),
                'yes_name': __( 'Delete [lcname] permanently' ),
                'no_name': __( 'Cancel. Do not delete' ),
                'evt_el': $( this.element ),
                'lcname': this.options.lcname
            } );
        },

        '.swc_panel_button_lock_asset click': function() {
            this.options.asset_instance.setLocked( 1 );
            this.options.map.attr( 'swc_locked', true );
            this.options.map.attr( 'swc_unlocked', false );
        },

        '.swc_panel_button_unlock_asset click': function() {
            this.options.asset_instance.setLocked( null );
            this.options.map.attr( 'swc_locked', false );
            this.options.map.attr( 'swc_unlocked', true );
        },

        '.swc_panel_button_copy_asset click': function() {
            this.options.asset_instance.copyToDB();
        },

        '.swc_panel_button_move_asset click': function() {
            //this.markCloseOnFocus();
            panelStackInstance.addPanel( MoveAsset, {
                'asset_instance': this.options.asset_instance,
                'lcname': this.options.lcname
            } );
        },

        ' evt_swc_yes': function( /*el, ev, opts*/ ) {
            evt( 'swifty_editor_set_cursor', { '$asset': this.options.asset_instance.getAssetContainer() } );
            evt( 'swifty_editor_set_asset_in_edit_mode' );
            this.options.asset_instance.deleteAsset();
            this.markCloseOnFocus();
            this.yesNoPanel.closePanel();
        },

        ' evt_swc_no': function( /*el, ev, opts*/ ) {
            //evt( 'swifty_editor_set_cursor', { '$asset': this.options.asset_instance.getAssetContainer() } );
            //evt( 'swifty_editor_set_asset_in_edit_mode' );
            this.yesNoPanel.closePanel();
        },

        '.swc_back_button click': function( /*el, ev*/ ) {
            evt( 'swifty_editor_set_cursor', { '$asset': this.options.asset_instance.getAssetContainer() } );
            evt( 'swifty_editor_set_asset_in_edit_mode' );

            this._super();
        },

        '.swc_panel_button_insert_p_above_asset click': function( /*el, ev*/ ) {
            evt( 'swifty_editor_insert_p_asset', {
                'action': 'above',
                '$asset': this.options.asset_instance.getAssetContainer()
            } );
        },

        '.swc_panel_button_insert_p_below_asset click': function( /*el, ev*/ ) {
            evt( 'swifty_editor_insert_p_asset', {
                'action': 'below',
                '$asset': this.options.asset_instance.getAssetContainer()
            } );
        }
    } );
} );


swifty.define('stache!js/panels/edit_asset/edit_asset.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/panels/edit_asset/edit_asset.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<div class="swc_panel_form_tabs_wrapper">\n    <div class="swc_panel_form_wrapper">\n        <div class="swc_panel_form_wrapper_inner">\n            <form class="swc_content_form swc_panel_content_nowrap" autocomplete="off">\n                <div class="swc_panel_form_tab_pane swc_panel_form_content swc_selected">\n                    {{#if editmap.tmpl_edit}}\n                        {{&renderStache editmap.tmpl_edit}}\n                    {{else}}\n                        <div class="swc_form_column">\n                            {{__ "One moment please..." }}\n                        </div>\n                    {{/if}}\n                </div>\n                {{#if is_block}}\n                <div class="swc_panel_form_tab_pane swc_panel_form_position">\n                {{#if asset_data.swc_swifty_on}}\n                    <div class="swc_form_column swc_form_inputs_w_100">\n                        <swifty_form_input name="swc_width" _value="asset_data.swc_width" label="{{__ \'Width (%)\'}}" />\n                        <swifty_form_radiobutton name="swc_position" _value="asset_data.swc_position" values="left^^fa-align-left|center^^fa-align-center|right^^fa-align-right" label="{{__ \'Align\'}}" />\n                    </div>\n                    <div class="swc_form_column swc_form_inputs_w_100">\n                        <swifty_form_input name="swc_margin_left" _value="asset_data.swc_margin_left" label="{{__ \'Margin left\'}}" />\n                        <swifty_form_input name="swc_margin_right" _value="asset_data.swc_margin_right" label="{{__ \'Margin right\'}}" />\n                    </div>\n                    <div class="swc_form_column swc_form_inputs_w_100">\n                        <swifty_form_input name="swc_margin_top" _value="asset_data.swc_margin_top" label="{{__ \'Margin top\'}}" />\n                        <swifty_form_input name="swc_margin_bottom" _value="asset_data.swc_margin_bottom" label="{{__ \'Margin bottom\'}}" />\n                    </div>\n                    <div class="swc_form_column swc_form_inputs_w_100">\n                        <swifty_form_input name="swc_padding_left" _value="asset_data.swc_padding_left" label="{{__ \'Padding left\'}}" />\n                        <swifty_form_input name="swc_padding_right" _value="asset_data.swc_padding_right" label="{{__ \'Padding right\'}}" />\n                    </div>\n                    <div class="swc_form_column swc_form_inputs_w_100">\n                        <swifty_form_input name="swc_padding_top" _value="asset_data.swc_padding_top" label="{{__ \'Padding top\'}}" />\n                        <swifty_form_input name="swc_padding_bottom" _value="asset_data.swc_padding_bottom" label="{{__ \'Padding bottom\'}}" />\n                    </div>\n                {{else}}\n                    <div class="swc_form_column" style="width: 300px;">\n                        <swc_icon_button icon="&#xe031;" action="enable_layout" text="{{__ \'Enable layout\'}}" />\n                        <div class="swifty_form_label">\n                            {{__ \'Adds the possibility to add layout (like padding, margin and alignment) to this item.\'}}\n                        </div>\n                    </div>\n                {{/if}}\n                </div>\n\n                <div class="swc_panel_form_tab_pane swc_panel_form_style">\n                {{#if asset_data.swc_swifty_on}}\n                    <div class="swc_form_column swc_form_inputs_w_100">\n                        <swifty_colorpicker name="swc_bg_color" _value="asset_data.swc_bg_color" label="{{__ \'Background color\'}}"/>\n                    </div>\n                    <div class="swc_form_column swc_form_inputs_w_100">\n                        <swifty_colorpicker name="swc_border_color" _value="asset_data.swc_border_color" label="{{__ \'Border color\'}}"/>\n                        <swifty_form_input name="swc_border_width" _value="asset_data.swc_border_width" label="{{__ \'Border width\'}}" />\n                    </div>\n                    <div class="swc_form_column swc_form_inputs_w_100">\n                        <swifty_colorpicker name="swc_shadow_color" _value="asset_data.swc_shadow_color" label="{{__ \'Shadow color\'}}"/>\n                        <swifty_form_input name="swc_shadow_blur" _value="asset_data.swc_shadow_blur" label="{{__ \'Shadow blur\'}}" />\n                    </div>\n                    <div class="swc_form_column swc_form_inputs_w_100">\n                        <swifty_form_input name="swc_shadow_offset_x" _value="asset_data.swc_shadow_offset_x" label="{{__ \'Shadow distance horizontal\'}}"/>\n                        <swifty_form_input name="swc_shadow_offset_y" _value="asset_data.swc_shadow_offset_y" label="{{__ \'Shadow distance vertical\'}}" />\n                    </div>\n                    <div class="swc_form_column">\n                        <swifty_form_radiobutton name="swc_scrolleffect" _value=\'asset_data.swc_scrolleffect\' values="none^{{__ \'None\'}}^|move^{{__ \'Move\'}}|fade^{{__ \'Fade\'}}|movefade^{{__ \'Move and fade\'}}" label="{{__ \'Scroll effect\'}}" direction="vertical"/>\n                    </div>\n                    {{#eq asset_data.swc_scrolleffect \'none\'}}\n                    {{else}}\n                        {{#eq asset_data.swc_scrolleffect \'move\'}}\n                            <div class="swc_form_column">\n                                <swifty_form_radiobutton name="swc_se_move_dir" _value=\'asset_data.swc_se_move_dir\' values="up^{{__ \'Up\'}}^|down^{{__ \'Down\'}}|left^{{__ \'Left\'}}|right^{{__ \'Right\'}}" label="{{__ \'Move direction\'}}" direction="vertical"/>\n                            </div>\n                        {{/eq}}\n                        {{#eq asset_data.swc_scrolleffect \'movefade\'}}\n                            <div class="swc_form_column">\n                                <swifty_form_radiobutton name="swc_se_move_dir" _value=\'asset_data.swc_se_move_dir\' values="up^{{__ \'Up\'}}^|down^{{__ \'Down\'}}|left^{{__ \'Left\'}}|right^{{__ \'Right\'}}" label="{{__ \'Move direction\'}}" direction="vertical"/>\n                            </div>\n                        {{/eq}}\n                        <div class="swc_form_column">\n                            <swifty_form_radiobutton name="swc_se_move_mot" _value=\'asset_data.swc_se_move_mot\' values="in^{{__ \'In\'}}^|out^{{__ \'Out\'}}|both^{{__ \'In and out\'}}" label="{{__ \'Action\'}}" direction="vertical"/>\n                        </div>\n                        {{#eq asset_data.swc_scrolleffect \'fade\'}}\n                            <div class="swc_form_column">\n                                <swifty_form_radiobutton name="swc_se_move_rev" _value=\'asset_data.swc_se_move_rev\' values="normal^{{__ \'Normal\'}}^|reverse^{{__ \'Reverse\'}}" label="{{__ \'Reverse\'}}" direction="vertical"/>\n                            </div>\n                        {{/eq}}\n                        {{#eq asset_data.swc_scrolleffect \'movefade\'}}\n                            <div class="swc_form_column">\n                                <swifty_form_radiobutton name="swc_se_move_rev" _value=\'asset_data.swc_se_move_rev\' values="normal^{{__ \'Normal\'}}^|reverse^{{__ \'Reverse\'}}" label="{{__ \'Reverse\'}}" direction="vertical"/>\n                            </div>\n                        {{/eq}}\n                        <div class="swc_form_column swc_form_inputs_w_100">\n                            <swifty_form_input name="swc_se_factor" _value="asset_data.swc_se_factor" label="{{__ \'Effect factor\'}}" />\n                            <swifty_form_input name="swc_se_offset" _value="asset_data.swc_se_offset" label="{{__ \'Effect offset\'}}" />\n                        </div>\n                    {{/eq}}\n                {{else}}\n                    <div class="swc_form_column" style="width: 300px;">\n                        <swc_icon_button icon="&#xe031;" action="enable_style" text="{{__ \'Enable style\'}}" />\n                        <div class="swifty_form_label">\n                            {{__ \'Adds the possibility to style this item.\'}}\n                        </div>\n                    </div>\n                {{/if}}\n                </div>\n                {{/if}}\n            </form>\n        </div>\n    </div>\n</div>\n' ); return idn; });


swifty.define('stache!js/panels/edit_asset/edit_asset_tabs.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/panels/edit_asset/edit_asset_tabs.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '{{#if is_block}}\n    <div class="swc_panel_form_tabs {{#is swifty_gui_mode \'advanced\'}}{{else}}swc_panel_frm_tabs_hidden{{/is}}">\n    <div class="swc_panel_form_tabs_inner">\n        <div class="swc_panel_form_tab swc_selected" data-swc_for=".swc_panel_form_content">{{__ "Content" }}</div>\n        <div class="swc_panel_form_tab" data-swc_for=".swc_panel_form_position">{{__ "Layout" }}</div>\n        <div class="swc_panel_form_tab" data-swc_for=".swc_panel_form_style">{{__ "Style" }}</div>\n    </div>\n</div>\n{{else}}\n    <div class="swc_panel_form_tabs" {{#is swifty_gui_mode \'advanced\'}}swc_panel_frm_tabs_hidden{{/is}} style="-webkit-flex-align:flex-start;-ms-flex-align:flex-start;-webkit-align-items:flex-start; align-items:flex-start;">\n        <div class="swc_panel_form_tabs_inner">\n            <div class="swc_panel_form_tab swc_selected" data-swc_for=".swc_panel_form_content" style="margin-top: 0;">{{__ "Content" }}</div>\n        </div>\n    </div>\n{{/if}}\n' ); return idn; });


swifty.define('css!js/panels/edit_asset/edit_asset',[],function(){});
swifty.define( 'js/panels/edit_asset/edit_asset',[
    'jquery',
    'swiftylib/evt',
    'swiftylib/view',
    'swiftylib/map',
    'js/panels/asset_base/asset_base',
    'swiftylib/i18n/__',
    'stache!js/panels/edit_asset/edit_asset.stache',
    'stache!js/panels/edit_asset/edit_asset_tabs.stache',
    'js/diverse/utils',
    // No return values:
    'css!js/panels/edit_asset/edit_asset.css'
], function(
    $, evt, View, Map, AssetBase, __, tmpl, tmplTabs, Utils
) {
    

    function getSWCreatorAjaxUrl() {
        return Utils.updateQueryString( 'swcreator_ajax', true, scc_data.view_url );
    }

    return AssetBase.extend( {
        'defaults': {
            'tmpl_content': tmpl,
            'tmpl_tabs': tmplTabs,
            'title': __( 'Edit [lcname]' ),
            'swifty_gui_mode': scc_data.swifty_gui_mode
        }
    }, {
        init: function() {
            var self = this;

            self.options.editmap = new Map( {
                'tmpl_edit': undefined
            } );

            var shortcode = self.options.asset_instance.getShortcode();

            $.post(
                getSWCreatorAjaxUrl(),
                {
                    'action': 'get_asset_edit_stache',
                    'shortcode_name': shortcode,
                    'id': scc_data.page_id,
                    'ajax_nonce': scc_data.ajax_nonce
                },
                function( data ) {
                    data = $.parseJSON( data );

                    // Add missing default values
                    if( self.options.asset_instance ) {
                        self.options.asset_instance.setDefaultAssetData( data.default_attributes );
                    }

                    var obj = {};
                    var objChanged = false;
                    $.each( data.default_attributes, function( key, value ) {
                        if( ! self.options.asset_data.attr( key ) ) {
                            obj[ key ] = value;
                            objChanged = true;
                        }
                    } );

                    // text asset is always using layout options
                    if( self.options.asset_instance && ( self.options.asset_instance.options.shortcode === 'swifty_text' ) ) {
                        obj.swc_swifty_on = 1;
                        objChanged = true;
                    }

                    // do we want to remove the extra p and br tags from the content?
                    if( self.options.asset_instance && ( data.content_removep === '1' ) ) {
                        if( window.wp.editor && window.wp.editor.removep ) {
                            var content_org = self.options.asset_data.attr( 'content' );
                            var content = window.wp.editor.removep( content_org );
                            if( content_org !== content ) {
                                obj[ 'content' ] = content;
                                objChanged = true;
                            }
                        }
                    }

                    if( objChanged ) {
                        self.options.asset_data.attr( obj );
                    }

                    var idn = '__stache_asset_' + shortcode + '__';
                    View.mustache( idn, data.stache );
                    self.options.editmap.attr( 'tmpl_edit', idn );

                    setTimeout( function() {
                        evt( 'fix_panel_heights', { 'redraw_element': $( self.element ).find( '.swc_panel_form_content' ) } );
                    }, 1 );
                    
                    self.on_load_edit_stache();
                }
            );

            self._super();
            self.options.map.attr( 'show_undo_redo', false );

            $( '.swc_panel_form_tab:first' ).click();
            $( '.swc_panel_form_tab[data-swc_for=".swc_panel_form_' + this.options.mode + '"]' ).click();

            evt( 'swifty_editor_set_focus', { 'focus': 0 } );
            evt( 'swifty_editor_unlock_selection', { '$asset': this.options.asset_instance.getAssetContainer() } );
            evt( 'swifty_editor_set_asset_in_edit_mode', { '$asset': this.options.asset_instance.getAssetContainer() } );
        },

        '.swc_back_button click': function( /*el, ev*/ ) {
            evt( 'swifty_editor_set_focus', { 'focus': 1 } );
            evt( 'swifty_editor_set_cursor', { '$asset': this.options.asset_instance.getAssetContainer() } );
            //evt( 'swifty_editor_set_asset_in_edit_mode' );
            //evt( 'reset_panel_stack' );

            this._super();
        },

        '.swc_panel_form_tab click': function( el/*, ev*/ ) {
            // Show clicked tab as selected
            $( this.element ).find( '.swc_panel_form_tab' ).removeClass( 'swc_selected' );
            $( el ).addClass( 'swc_selected' );

            // Show correct tab pane
            $( this.element ).find( '.swc_panel_form_tab_pane' ).removeClass( 'swc_selected' );
            $( this.element ).find( $( el ).attr( 'data-swc_for' ) ).addClass( 'swc_selected' );

            evt( 'fix_panel_heights', { 'redraw_element': $( this.element ).find( $( el ).attr( 'data-swc_for' ) ) } );
        },

        '.swc_enable_layout click': function( /*el, ev*/ ) {
            this.enableSwiftyOn();
        },

        '.swc_enable_style click': function( /*el, ev*/ ) {
            this.enableSwiftyOn();
        },

        enableSwiftyOn: function() {
            var assetData = this.options.asset_instance.getAssetData();

            assetData.attr( 'swc_swifty_on', 1 );
        },

        on_load_edit_stache: function() {
            // override to perform actions afters loading the edit stache from the server
        }
    } );
} );

swifty.define( 'js/diverse/asset',[
    'jquery',
    'swiftylib/evt',
    'swiftylib/control',
    'swiftylib/map',
    'js/panels/panel_stack/panel_stack_instance',
    'js/panels/asset_main/asset_main',
    'swiftylib/i18n/__',
    'js/diverse/utils',
    'js/panels/edit_asset/edit_asset',
    'js/libs/mout/src/function/throttle'
], function(
    $, evt, Control, Map, panelStackInstance, AssetMainPanel, __, Utils, EditPanel, throttle
) {
    

    return Control.extend( {
        'defaults': {
            'tmpl_content': undefined,
            'asset_name': '_ unknown _',
            'shortcode': undefined,
            'asset_data': undefined,
            'class_edit': EditPanel,
            'onchange': undefined,
            'force_close_tag': 0,
            'swc_shortcode_status': ''
        }

    }, {
        init: function() {
            var self = this;

            // Needed to be able to always find our assets element, even if it's changed by a new render.
            self.$myContainer = $( self.element ).closest( '.swc_asset,.swc_text' );

            // Keep track of earlier shortcode attributes, to remove unused ones.
            self.previousAttributes = null;

            var assetData = self.getAssetDataFromElement();
            self.options.asset_data = new Map( assetData );

            // Try to figure out for which shortcode we create this asset instance.
            if( self.options.asset_name === '_ unknown _' ) {
                if( self.options.shortcode ) {
                    self.options.asset_name = self.options.shortcode;

                    var shortcode_text = self.createShortcodeText( assetData );
                    self.options.asset_data.swc_shortcode_text = shortcode_text;
                    self.previousAttributes = self.parseShortCode( shortcode_text );
                    if( self.previousAttributes ) {
                        self.parsed_shortcode_valid();
                    } else {
                        self.parsed_shortcode_invalid();
                    }
                } else {
                    self.options.asset_name = 'unknown';
                }
            }

            self._super();

            if( self.options.shortcode !== 'swifty_text' ) {
                self.reloadFromServerNowThrottledObject = throttle( $.proxy( self.reloadFromServerNow, self ), 3000 );
            }

            self.on();
        },

        parsed_shortcode_valid: function() {
            this.options.asset_data.attr( 'swc_shortcode_status', __( 'Valid shortcode' ) );
        },

        parsed_shortcode_invalid: function() {
            this.options.asset_data.attr( 'swc_shortcode_status', __( 'Invalid shortcode' ) );
        },

        openMainPanel: function( mode ) {
            panelStackInstance.resetPanelStack( { 'left': true } );
            panelStackInstance.addPanel( AssetMainPanel, {
                'asset_instance': this,
                'mode': mode
            } );
        },

        openEditPanel: function( mode ) {
            var self = this;

            //panelStackInstance.resetPanelStack( { 'left': true } );
            panelStackInstance.addPanel(
                self.options.class_edit,
                {
                    'asset_instance': self,
                    'mode': mode
                }
            );
        },

        // save the current width of the asset to the server
        resizeToCurrentWidth: function() {
            var self = this;
            var $container;

            if( self.options.asset_data.attr( 'swc_position' ) === 'center' ) {
                $container = self.getAssetContainerContent();
            } else {
                $container = self.getAssetContainer();
            }

            if( $container.length ) {
                var percent = Math.ceil( 100 * $container.width() / $container.offsetParent().width() );

                self.changePositionAndWidth( '', percent );

                var $images = $container.find( 'img[swifty_src_org]' ).filter(':not([swifty_src])');
                if( $images.length ) {
                    $.each( $images, function( i, img ) {
                        img.setAttribute( 'swifty_src', img.getAttribute( 'swifty_src_org' ) );
                    } );
                    evt( 'add_exec', { 'fn': 'swifty_checkImages' } );
                }

                evt( 'swifty_editor_trigger_save', {} );
            }
        },

        setLocked: function( lock ) {
            var self = this;

            self.setAssetDataElement( 'swc_locked', ( lock ? '1' : '' ) );
            if( lock ) {
                self.getAssetContainer().addClass( 'swc_locked' );
            } else {
                self.getAssetContainer().removeClass( 'swc_locked' );
            }

            evt( 'swifty_editor_trigger_save', {} );
        },

        copyToDB: function() {
            var self = this;

            evt( 'animate_clipboard_copy', { '$element': self.$myContainer } );

            evt( 'convert_from_element_html', { '$element': self.$myContainer } ).done( function( content ) {
                evt( 'swifty_copy_content_to_db', { 'content': content, 'source': self.options.shortcode } );
            } );
        },

        getAssetData: function( opts ) {
            // swifty_text is always using the layout options, but needs this set for internal tests in edit panels
            if( this.options.shortcode === 'swifty_text' ) {
                this.options.asset_data.attr( 'swc_swifty_on', 1 );
            }

            return this.options.asset_data;
        },

        resetDefaultAssetData: function() {
            this.defAssetData = {
                'swc_margin_top': 5,
                'swc_margin_bottom': 5,
                'swc_margin_left': 10,
                'swc_margin_right': 0,
                'swc_padding_top': 0,
                'swc_padding_bottom': 0,
                'swc_padding_left': 0,
                'swc_padding_right': 0,
                'swc_position': 'right',
                'swc_width': 50,
                'swc_bg_color': '',
                'swc_border_color': '',
                'swc_border_width': 0,
                'swc_shadow_color': '',
                'swc_shadow_offset_x': 0,
                'swc_shadow_offset_y': 0,
                'swc_shadow_blur': 0,
                'swc_temporary': '',
                'swc_locked': '',
                'swc_scrolleffect': 'none',
                'swc_se_factor': 1,
                'swc_se_offset': 0,
                'swc_se_move_dir': 'up',
                'swc_se_move_mot': 'in',
                'swc_se_move_rev': 'normal'
            };
        },

        getDefaultAssetData: function( property ) {
            var self = this;
            if(! self.defAssetData ) {
                self.resetDefaultAssetData();
            }

            return property ? self.defAssetData[ property ] : self.defAssetData;
        },

        setDefaultAssetData: function( properties ) {
            var self = this;
            if(! self.defAssetData ) {
                self.resetDefaultAssetData();
            }
            $.each( properties, function( key, value ) {
                self.defAssetData[ key ] = value;
            } );
        },

        // decode the string with html entities like unicode &#xxxx;
        // see http://stackoverflow.com/questions/7394748/whats-the-right-way-to-decode-a-string-that-has-special-html-entities-in-it
        // using textarea will preserve html tags
        htmlDecode: function( value ) {
            return $( '<textarea/>' ).html( value ).text();
        },

        /**
         * Use the given assetData to construct a shortcode string.
         * 
         * @param assetData
         * @returns {string}
         */
        createShortcodeText: function( assetData ) {
            var self = this;
            var defaultData = self.getDefaultAssetData();
            var shortcode_atts = {};

            // Ignore keys that belong to SCC.
            $.each( assetData, function( key, value ) {
                if( typeof defaultData[key] === 'undefined' ) {
                    if( ( key !== 'swc_swifty_on' ) && ( key !== 'swc_cssid' ) && ( key !== 'swc_shortcode_status' ) ) {
                        shortcode_atts[key] = value;
                    }
                }
            } );

            var attribute_string = '';
            var content = '';
            $.each( shortcode_atts, function( key, val ) {
                if( key === 'content' ) {
                    content = val;
                } else if( parseFloat( key ) === key >>> 0 ) {  // Is this a integer?
                    attribute_string += ' ' + val;
                } else {
                    if( key !== 'swc_shortcode' ) {
                        attribute_string += ' ' + key + '="' + val + '"';
                    }
                }
            } );
            var shortcode = '[' + shortcode_atts.swc_shortcode + attribute_string + ']';

            if ( content || self.options.force_close_tag ) {
                shortcode += content + '[/' + shortcode_atts.swc_shortcode + ']';
            }

            return shortcode;
        },

        getAssetDataFromElement: function() {
            var self = this;
            var assetData;
            var $container = self.getAssetContainerContent();

            if( $container.length > 0 ) {
                assetData = $.parseJSON( Utils.atou( $container.attr( 'data-asset_data' ) ) );
            }

            if( ! assetData ) {
                assetData = {};
            }

            return assetData;
        },

        getAssetName: function() {
            if( this.options.asset_name ) {
                return this.options.asset_name;
            } else {
                return this.shortcode;
            }
        },

        getShortcode: function() {
            return this.options.shortcode;
        },

        getAssetNameTranslated: function() {
            var name = this.getAssetName();
            name = name.replace( /_/g, ' ' );
            name = name.charAt( 0 ).toUpperCase() + name.slice( 1 );

            return __( name );
        },

        getAssetContainer: function() {
            // The assets html is often changed because of new renders received fro the server.
            // This way we will always be able to find the latest (correct) dom element of our asset.
            return this.$myContainer;
        },

        getAssetContainerContent: function() {
            var $container = this.getAssetContainer();

            return $container.children( '.swc_asset_cntnt' );
        },

        assignCss: function() {
            var self = this;
            var assetData = self.getAssetDataFromElement();
            var defaultData = self.getDefaultAssetData();
            $.each( defaultData, function( key, value ) {
                self.handleAttributeAssignment( key, assetData[key] ? assetData[key] : value );
            } );
        },

        handleAttributeAssignment: function( attr, newVal ) {
            var handled = true;
            var self = this;
            switch( attr ) {
                case 'swc_position':
                    self.changePositionAndWidth( newVal, -1 );
                    break;
                case 'swc_width':
                    self.changePositionAndWidth( '', newVal );
                    break;
                case 'swc_margin_left':
                    self.changeAttrPx( 'margin-left', attr, newVal, false );
                    break;
                case 'swc_margin_right':
                    self.changeAttrPx( 'margin-right', attr, newVal, false );
                    break;
                case 'swc_margin_top':
                    self.changeAttrPx( 'margin-top', attr, newVal, false );
                    break;
                case 'swc_margin_bottom':
                    self.changeAttrPx( 'margin-bottom', attr, newVal, false );
                    break;
                case 'swc_padding_top':
                    self.changeAttrPx( 'padding-top', attr, newVal, true );
                    break;
                case 'swc_padding_bottom':
                    self.changeAttrPx( 'padding-bottom', attr, newVal, true );
                    break;
                case 'swc_padding_left':
                    self.changeAttrPx( 'padding-left', attr, newVal, true );
                    break;
                case 'swc_padding_right':
                    self.changeAttrPx( 'padding-right', attr, newVal, true );
                    break;
                case 'swc_bg_color':
                    self.changeAttrColor( 'background-color', attr, newVal, true );
                    break;
                case 'swc_border_color':
                case 'swc_border_width':
                    self.changeBorder( attr, newVal );
                    break;
                case 'swc_shadow_color':
                case 'swc_shadow_blur':
                case 'swc_shadow_offset_x':
                case 'swc_shadow_offset_y':
                    self.changeShadow( attr, newVal );
                    break;
                case 'swc_scrolleffect':
                case 'swc_se_factor':
                case 'swc_se_offset':
                case 'swc_se_move_dir':
                case 'swc_se_move_mot':
                case 'swc_se_move_rev':
                    self.changeScrolleffect( attr, newVal );
                    break;
                case 'swc_shortcode_text':
                    try {
                        var parsed = self.parseShortCode( newVal );
                        if( parsed ) {
                            var assetData = self.options.asset_data;
                            assetData.attr( {
                                'swc_shortcode': parsed.name,
                                'content': parsed.content
                            } );
                            assetData.attr( parsed.attributes );
                            if( self.previousAttributes && self.previousAttributes.attributes ) {
                                $.each( self.previousAttributes.attributes, function( key, val ) {
                                    if( ! parsed.attributes[ key ] ) {
                                        assetData.removeAttr( key );
                                    }
                                } );
                            }
                            self.previousAttributes = parsed.attributes;
                            self.parsed_shortcode_valid();
                        } else {
                            self.parsed_shortcode_invalid();
                        }
                    } catch( error ) {
                        self.parsed_shortcode_invalid();
                        // ignore errors
                    }
                    handled = false;
                    break;
                default:
                    handled = false;
                    break;
            }
            if( handled ) {
                self.setAssetDataElement( 'swc_temporary', '' );
            }
            return handled;
        },

        '{asset_data} change': function( dunno, ev, attr, how, newVal, oldVal ) {
            var self = this;
            var assetData;

            //console.log( '{asset_data} change', dunno, ev, attr, how, newVal, oldVal );

            if( attr === 'swc_position' ) {
                if( ( newVal === 'right' && ( oldVal === 'left'  || oldVal === 'center' ) ) ||
                    ( newVal === 'left'  && ( oldVal === 'right' || oldVal === 'center' ) )
                ) {
                    assetData = self.options.asset_data;

                    // When switching from align left to right (and visa verse) switch left and right margins also
                    assetData.attr( {
                        'swc_margin_left': assetData.attr( 'swc_margin_right' ),
                        'swc_margin_right': assetData.attr( 'swc_margin_left' )
                    } );
                }
            }

            if( attr !== 'swc_shortcode_status' ) {
                if( ! self.handleAttributeAssignment( attr, newVal ) ) {
                    if( typeof self.reloadFromServerNowThrottledObject !== 'undefined' ) {
                        this.reloadFromServer();
                    }
                }
            }
        },

        reloadFromServer: function() {
            var self = this;
            var d = new Date();
            var refreshNr = d.getTime();

            evt( 'asset_reload_from_server_queued', {
                'container': self.getAssetContainer(),
                'refreshnr': refreshNr
            } );

            this.reloadFromServerNowThrottledObject();
        },

        reloadFromServerNow: function() {
            var self = this;
            var d = new Date();
            var refreshNr = d.getTime();

            evt( 'asset_data_changed', {
                'container': self.getAssetContainer(),
                'asset_data': self.options.asset_data,
                'refreshnr': refreshNr
            } ).then( function( data ) {
                self.processServerInfo( data.info );
            } );
        },

        processServerInfo: function( /*info*/ ) {
            // Create derived method to use the return value in info.

            // Execute functions on each insertion / change.
            if(  this.options.onchange ) {

                $.each( this.options.onchange, function( i, value ) {
                    if( value === 'checkimages' ) {
                        evt( 'add_exec', { 'fn': 'swifty_checkImages' } );
                    }
                } );
            }
        },

        changeBorder: function( attr, newVal ) {
            var self  =this;

            var swc_border_color;
            if( attr === 'swc_border_color' ) {
                swc_border_color = newVal;
                self.changeAttrColor( '', attr, newVal, true );
            } else {
                swc_border_color = self.options.asset_data.attr( 'swc_border_color' );
            }
            if( swc_border_color === '' ) {
                swc_border_color = 'transparent';
            }

            var swc_border_width;
            if( attr === 'swc_border_width' ) {
                swc_border_width = newVal;
                self.changeAttrPx( '', attr, newVal, true );
            } else {
                swc_border_width = self.options.asset_data.attr( 'swc_border_width' );
            }

            self.changeAttrColor( 'border-color', '', swc_border_color, true );
            self.changeAttrPx( 'border-width', '', swc_border_width, true );
            self.changeAttr( 'solid', 'border-style', '', 'solid', true );
        },

        changeShadow: function( attr, newVal ) {
            var self  =this;

            var swc_shadow_color;
            if( attr === 'swc_shadow_color' ) {
                swc_shadow_color = newVal;
                self.changeAttrColor( '', attr, newVal, true );
            } else {
                swc_shadow_color = self.options.asset_data.attr( 'swc_shadow_color' );
            }
            if( swc_shadow_color === '' ) {
                swc_shadow_color = 'transparent';
            }

            var swc_shadow_blur;
            if( attr === 'swc_shadow_blur' ) {
                newVal = newVal || 0;
                swc_shadow_blur = newVal;
                self.changeAttrPx( '', attr, newVal, true );
            } else {
                swc_shadow_blur = self.options.asset_data.attr( 'swc_shadow_blur' ) || 0;
            }

            var swc_shadow_offset_x;
            if( attr === 'swc_shadow_offset_x' ) {
                newVal = newVal || 0;
                swc_shadow_offset_x = newVal;
                self.changeAttrPx( '', attr, newVal, true );
            } else {
                swc_shadow_offset_x = self.options.asset_data.attr( 'swc_shadow_offset_x' ) || 0;
            }

            var swc_shadow_offset_y;
            if( attr === 'swc_shadow_offset_y' ) {
                newVal = newVal || 0;
                swc_shadow_offset_y = newVal;
                self.changeAttrPx( '', attr, newVal, true );
            } else {
                swc_shadow_offset_y = self.options.asset_data.attr( 'swc_shadow_offset_y' ) || 0;
            }

            if( parseInt( swc_shadow_offset_x, 10 ) !== 0 || parseInt( swc_shadow_offset_y, 10 ) !== 0 ) {
                self.changeAttr( swc_shadow_offset_x + 'px ' + swc_shadow_offset_y + 'px ' + swc_shadow_blur + 'px ' + swc_shadow_color,
                    'box-shadow', '', '', true );
            }

            if( parseInt( swc_shadow_offset_x, 10 ) === 0 && parseInt( swc_shadow_offset_y, 10 ) === 0 ) {
                self.changeAttr( '', 'box-shadow', '', '', true );
            }
        },

        changeScrolleffect: function( attr, newVal ) {
            var self = this;
            var $container = self.getAssetContainer();
            var assetData = self.options.asset_data;

            self.changeAttr( '', '', attr, newVal, false );

            evt( 'swifty_reset_scrolleffect', 2 );
            
            var scrollEffect = assetData.attr( 'swc_scrolleffect' );
            if( scrollEffect === 'none' ) {
                $container.removeAttr( 'data-swc_scrolleffect' );
            } else {
                var obj = {
                    'effect': scrollEffect,
                    'factor': assetData.attr( 'swc_se_factor' ),
                    'offset': assetData.attr( 'swc_se_offset' ),
                    'direction': assetData.attr( 'swc_se_move_dir' ),
                    'motion': assetData.attr( 'swc_se_move_mot' ),
                    'reverse': assetData.attr( 'swc_se_move_rev' )
                };

                $container.attr( 'data-swc_scrolleffect', JSON.stringify( obj ) );
            }

            evt( 'swifty_update_scrolleffect' );
        },

        changeAttr: function( val, key, attr, newVal, setCssInContent ) {
            var self = this;
            var $container = self.getAssetContainer();

            if( attr !== '' ) {
                self.setAssetDataElement( attr, newVal );
            }

            if( setCssInContent ) {
                $container = self.getAssetContainerContent();
            }

            // do not update the margins left and right when the alignment is center or width =100, it should stay 'auto'
            var doCssUpdate = true;
            if( ( attr === 'swc_margin_left') || ( attr === 'swc_margin_right' ) ) {
                if( ( self.options.asset_data.attr( 'swc_position' ) === 'center' ) || ( parseInt(self.options.asset_data.attr( 'swc_width' ), 10 ) === 100 ) ) {
                    doCssUpdate = false;
                }
            }
            if( doCssUpdate ) {
                $container.css( key, val );
            }

            evt( 'swifty_editor_trigger_save', {} );
        },

        changeAttrPx: function( key, attr, newVal, setCssInContent ) {
            var val = parseInt( newVal, 10 );
            if( ! val > 0 ) {
                val = 0;
            }
            val += 'px';

            this.changeAttr( val, key, attr, newVal, setCssInContent );
        },

        changeAttrPercent: function( key, attr, newVal, setCssInContent ) {
            var val = parseInt( newVal, 10 );
            if( ! val > 0 ) {
                val = 0;
            }
            val += '%';

            this.changeAttr( val, key, attr, newVal, setCssInContent );
        },

        changeAttrColor: function( key, attr, newVal, setCssInContent ) {
            var val = newVal;
            if( newVal === '' ) {
                val = 'transparent';
            }

            this.changeAttr( val, key, attr, newVal, setCssInContent );
        },

        changePositionAndWidth: function( newVal, newWidth ) {
            var self = this;
            var $container = self.getAssetContainer();
            var $content = self.getAssetContainerContent();
            var $wrapper = $( $container[0].parentNode );
            var css;

            if( newVal === '' ) {
                newVal = self.options.asset_data.attr( 'swc_position' );
                if( ! newVal ) {
                    newVal = self.getDefaultAssetData( 'swc_position' );
                }
            }

            newWidth = parseInt( newWidth, 10 );
            if( newWidth === -1) {
                newWidth = parseInt( self.options.asset_data.attr( 'swc_width' ), 10 );
                if( ! newWidth ) {
                    newWidth = self.getDefaultAssetData( 'swc_width' );
                }
            }

            if( ( newVal === 'center' ) || ( newWidth === 100 ) ) {
                css = {
                    'clear': 'both'
                };
                $wrapper.css( css );

                css = {
                    'width': '100%',
                    'clear': 'both',
                    'margin-left': 0,
                    'margin-right': 0,
                    'float': 'none'
                };
                $container.css( css );

                css = {
                    'margin-left': 'auto',
                    'margin-right': 'auto',
                    'width': newWidth + '%'
                };
                $content.css( css );
            } else {
                css = {
                    'width': '100%',
                    'margin-left': 0,
                    'margin-right': 0
                };
                $content.css( css );

                css = {
                    'width': newWidth + '%',
                    'clear': 'none',
                    'margin-left': self.options.asset_data.attr( 'swc_margin_left' ) + 'px',
                    'margin-right': self.options.asset_data.attr( 'swc_margin_right' ) + 'px',
                    'float': newVal
                };
                $container.css( css );

                css = {
                    'clear': 'none'
                };
                $wrapper.css( css );
            }

            self.setAssetDataElement( 'swc_position', newVal );
            self.setAssetDataElement( 'swc_width', newWidth );

            evt( 'asset_was_resized' );

            evt( 'swifty_editor_trigger_save', {} );
        },

        setAssetDataElement: function( key, val ) {
            var self = this;
            var $container = self.getAssetContainerContent();
            var data = $.parseJSON( Utils.atou( $container.attr( 'data-asset_data' ) ) );

            if( ! data ) {
                data = {};
            }

            // skip default attribute values, except width
            var default_value = self.getDefaultAssetData( key );
            if( ( key === 'swc_width' ) || ( '' + default_value !== '' + val ) ) {
                data[key] = '' + val;
            } else {
                if( data[key] ) {
                    delete( data[key] );
                }
            }
            $container.attr( 'data-asset_data', Utils.utoa( JSON.stringify( data ) ) );
        },

        deleteAsset: function() {
            var self = this;
            var $el = self.getAssetContainer();
            var $wrapper = $el.closest( '.cke_widget_wrapper' );

            $wrapper.remove();

            evt( 'swifty_editor_content_modified' );
        },

        /**
         * Parse given shortcode string into name, attributes and content.
         * See https://www.sitepoint.com/unleash-the-power-of-the-wordpress-shortcode-api/ for some more information
         * about the shortcode API and attributes allowed.
         * 
         * @param shortCode
         * @returns {*}
         */
        parseShortCode: function( shortCode ) {
            var re = /(\s+|\W)|(\w+)/g;
            var match;
            var token;
            var curAttribute = '';
            var quoteChar;
            var mode = 'NOT STARTED';
            var closedIndex;
            var indexedValue = 0;
            var parsedValue = {
                name: '',
                attributes: {},
                content: ''
            };

            while( ( ( match = re.exec( shortCode )) != null ) && ! closedIndex ) {
                token = match[0];
                switch( mode ) {
                    case 'NOT STARTED':
                        if( token === '[' ) {
                            mode = 'GETNAME';
                        }
                        break;
                    case 'GETNAME':
                        if( ! (/\s/.test( token )) ) {
                            if( token === ']' ) {
                                mode = 'CLOSED';
                                closedIndex = match.index;
                            } else {
                                parsedValue.name += token;
                            }
                        } else if( parsedValue.name ) {
                            mode = 'PARSING';
                        }
                        break;
                    case 'PARSING':
                        // if non text char throw it
                        if( token === ']' ) {
                            mode = 'CLOSED';
                            if( curAttribute ) {
                                parsedValue.attributes[indexedValue ++] = curAttribute;
                                curAttribute = '';
                            }
                            closedIndex = match.index;
                        } else if( token === '=' ) {
                            if( ! curAttribute ) {
                                throw ('invalid token: "' + token + '" encountered at ' + match.index);
                            } else {
                                mode = 'GET ATTRIBUTE VALUE';
                            }
                        } else if( ! /\s/.test( token ) ) {
                            curAttribute += token;
                        } else if( curAttribute ) {
                            mode = 'SET ATTRIBUTE';
                        }
                        break;
                    case 'CLOSED':

                        break;
                    case 'SET ATTRIBUTE':
                        // these are always from match[1]
                        if( /\s/.test( token ) ) {
                            parsedValue.attributes[curAttribute] = null;
                        } else if( token === '=' ) {
                            mode = 'GET ATTRIBUTE VALUE';
                        } else {
                            // only value as attribute, start with next attribute
                            parsedValue.attributes[indexedValue++] = curAttribute;
                            curAttribute = token;
                            mode = 'PARSING';
                        }
                        break;
                    case 'GET ATTRIBUTE VALUE':
                        if( ! (/\s/.test( token )) ) {
                            if( /["']/.test( token ) ) {
                                quoteChar = token;
                                parsedValue.attributes[curAttribute] = '';
                                mode = 'GET QUOTED ATTRIBUTE VALUE';
                            } else {
                                parsedValue.attributes[curAttribute] = token;
                                curAttribute = '';
                                mode = 'PARSING';
                            }
                        }
                        break;
                    case 'GET QUOTED ATTRIBUTE VALUE':
                        if( /\\/.test( token ) ) {
                            mode = 'ESCAPE VALUE';
                        } else if( token === quoteChar ) {
                            mode = 'PARSING';
                            curAttribute = '';
                        } else {
                            parsedValue.attributes[curAttribute] += token;
                        }
                        break;
                    case 'ESCAPE VALUE':
                        if( /\\'"/.test( token ) ) {
                            parsedValue.attributes[curAttribute] += token;
                        } else {
                            parsedValue.attributes[curAttribute] += '\\' + token;
                        }
                        mode = 'GET QUOTED ATTRIBUTE VALUE';
                        break;

                }
            }
            if( curAttribute && ! parsedValue.attributes[curAttribute] ) {
                parsedValue.attributes[curAttribute] = '';
            }
            if( 'CLOSED' === mode ) {
                var remainder = shortCode.substr( closedIndex + 1 );
                if( remainder ) {
                    //find closing tag
                    var closeTag = '[/' + parsedValue.name + ']';
                    var closePos = remainder.toLowerCase().indexOf( closeTag.toLowerCase() );
                    if( closePos !== - 1 ) {
                        parsedValue.content = remainder.substr( 0, closePos );
                    } else {
                        return false;
                    }
                }
                return parsedValue;
            } else {
                return false;
            }
        }
    } );
} );

swifty.define('stache!js/panels/overlay_panel/overlay_panel.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/panels/overlay_panel/overlay_panel.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<div class="swc_panel swc_overlay_panel {{panel_css_class}}">\n    <div class="swc_panel_container">\n        <div class="swc_panel_content">\n            {{#if tmpl_content}}\n                {{&renderStache tmpl_content}}\n            {{/if}}\n        </div>\n        <div class="clearfix"></div>\n        <div class="swc_iframe_gradient"></div>\n    </div>\n\n    <div class="swc_panel_bottom_container">\n        <div class="swc_panel_back_container {{#eq back_action \'exit\'}}swc_back_exit{{/eq}}">\n            <div class="swc_back_button swc_button">\n                {{#eq panel_css_class \'swc_small_panel\'}}\n                    &#xe900;\n                {{else}}\n                    <i class="fa fa-chevron-left"></i>\n                {{/eq}}\n            </div>\n        </div>\n\n        <div class="swc_panel_title_container">\n            <div class="swc_panel_title_pos">\n                <div class="swc_title">\n                    {{__ title}}\n                    {{#if title_tooltip}}\n                        <i class="fa fa-question"></i>\n                        <swc_tooltip for_sel=".swc_title" {{#if title_tooltip_title}}title="{{__ title_tooltip_title}}"{{/if}} text="{{__ title_tooltip}}" />\n                    {{/if}}\n                </div>\n            </div>\n        </div>\n    </div>\n</div>' ); return idn; });


swifty.define('css!js/panels/overlay_panel/overlay_panel',[],function(){});
swifty.define( 'js/panels/overlay_panel/overlay_panel',[
    'js/panels/panel/panel',
    'stache!js/panels/overlay_panel/overlay_panel.stache',
    // No return values:
    'css!js/panels/overlay_panel/overlay_panel.css'
], function(
    Panel, tmpl
) {
    

    return Panel.extend( {
        'defaults': {
            'tmpl': tmpl
        }
    }, {
    } );
} );

swifty.define('stache!js/panels/add_content/add_content.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/panels/add_content/add_content.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<div class="swc_panel_content_wrap">\n    {{#each category_defs}}\n        <div class="swc_panel_category_title">{{name}}</div>\n        {{#eq action \'content_tmpl\'}}\n            <swc_panel_button icon="{{icon}}" action="{{action}}" name="{{name}}" />\n        {{else}}\n        <div class="swc_panel_category_wrapper swc_panel_category_wrapper_{{action}}"></div>\n        {{/eq}}\n    {{/each}}\n</div>\n' ); return idn; });


swifty.define('stache!js/panels/simple_panel/simple_panel.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/panels/simple_panel/simple_panel.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '{{#if tmpl_content}}\n    {{&renderStache tmpl_content}}\n{{/if}}\n' ); return idn; });


swifty.define('css!js/panels/simple_panel/simple_panel',[],function(){});
swifty.define( 'js/panels/simple_panel/simple_panel',[
    'js/panels/panel/panel',
    'stache!js/panels/simple_panel/simple_panel.stache',
    // No return values:
    'css!js/panels/simple_panel/simple_panel.css'
], function(
    Panel, tmpl
) {
    

    return Panel.extend( {
        'defaults': {
            'tmpl': tmpl
        }
    }, {
    } );
} );

swifty.define('stache!js/panels/add_shortcode/add_shortcode.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/panels/add_shortcode/add_shortcode.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<div class="swc_panel_form_wrapper">\n    <div class="swc_panel_form_wrapper_inner">\n        <form class="swc_content_form swc_panel_content_nowrap" autocomplete="off">\n            <div class="swc_form_column">\n                <swifty_form_textarea name="shortcode_text" _value="map.shortcode_text" preferred_width="500" label="{{__ \'Shortcode text\'}}"/>\n            </div>\n            <div class="swc_form_column">\n                <swc_icon_button action="insert" text="{{__ \'Insert Shortcode\'}}"/>\n            </div>\n        </div>\n    </div>\n</div>\n' ); return idn; });

swifty.define( 'js/panels/add_shortcode/add_shortcode',[
    'jquery',
    'swiftylib/evt',
    'js/panels/panel/panel',
    'swiftylib/i18n/__',
    'stache!./add_shortcode.stache'
], function(
    $, evt, Panel, __, tmpl
) {
    

    return Panel.extend( {
        'defaults': {
            'tmpl_content': tmpl,
            'title': __( 'Shortcode' ),
            'wrap_at_bottom': false,
            '$column': null
        }
    }, {
        init: function() {
            var self = this;

            self._super();
            self.options.map.attr( 'shortcode_text', '' );

            evt( 'swifty_editor_set_focus', { 'focus': 0 } );
        },
        
        '.swc_icon_button.swc_insert click': function() {
            var self = this;

            self.closePanel();

            var dfd = new $.Deferred();

            var is_preset = self.options.wrap_at_bottom;
            var is_column = self.options.$column ? true : false;

            dfd.done( function() {
                // insert shortcode text
                var content = self.options.map.attr( 'shortcode_text' );

                if( is_preset ) {
                    content =
                        '[swifty_grid_row][swifty_grid_column]' +
                        content +
                        '[/swifty_grid_column][/swifty_grid_row]';
                }

                evt( 'convert_preset_html', {
                    'html': content
                } ).then( function( html ) {

                    // Insert the html in the page.
                    evt( 'add_asset_to_content', {
                        'html': html,
                        'widget_class': null,
                        'inline': ! ( is_preset || is_column ),
                        'takeSnapshot': true,
                        'only_insert_at_root': false,
                        'force_html_insert': true,
                        '$column': is_column ? self.options.$column : null,
                        'is_preset': is_preset
                    } ).then( function( $newEl ) {
                        if( $newEl && ( $newEl.length === 1 ) ) {
                            evt( 'scroll_to_element', { $el: $newEl } );
                        }
                    } );
                } );
            } );

            if( is_column ) {
                evt( 'set_column_range_for_insert', {
                    '$column': self.options.$column
                } ).done( function() {
                    dfd.resolve();
                } );
            } else {
                dfd.resolve();
            }
        }
    } );
} );


swifty.define('stache!js/panels/add_asset/add_asset.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/panels/add_asset/add_asset.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<div class="swc_panel_add_asset">\n    {{#each asset_defs}}\n        {{#eq hide \'_HIDE_\'}}\n        {{else}}\n            {{#if is_shortcode}}\n                <swc_panel_button icon="{{icon}}" action="add_asset_{{shortcode}}" name="{{name}}" shortcode="{{shortcode}}" data-asset_type="{{shortcode}}" width="{{width}}" data-inline="{{inline}}" ribbon_paid="{{paid}}" ribbon_coming="{{coming}}" ribbon_expired="{{expired}}" />\n            {{else}}\n                <swc_panel_button icon="{{icon}}" action="{{action}}" name="{{name}}" />\n            {{/if}}\n        {{/eq}}\n    {{/each}}\n</div>\n' ); return idn; });


swifty.define('stache!js/panels/buy/buy.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/panels/buy/buy.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<swc_dialog {(map)}="map"></swc_dialog>' ); return idn; });

swifty.define( 'js/panels/buy/buy',[
    'jquery',
    'swiftylib/evt',
    'swiftylib/control',
    'swiftylib/view',
    'swiftylib/map',
    'swiftylib/i18n/__',
    'stache!js/panels/buy/buy.stache'
], function(
    $, evt, Control, View, Map, __, tmpl
) {
    

    return Control.extend( {
        'defaults': {
            'tmpl': tmpl,
            'map': new Map( {
                'title': __( 'Unlock more Super Powers' ),
                'show_iframe': true,
                'total_nr': 0,
                'url': '',
                'small_header': true
            } )
        }
    }, {
        init: function() {
            var self = this;

            self.options.map.attr( 'url', self.options.dialog_data.attr( 'url' ) );

            self.element.html( new View( self.options.tmpl )(
                self.options, {
            } ) );

            self._super();

            evt( 'swifty_editor_set_focus', { 'focus': 0 } );
        },

        '{window} evt_swc_dialog_close': function( /*el, ev, opts, dfd*/ ) {

            evt( 'swifty_editor_set_focus', { 'focus': 1 } );

            $( this.element ).remove();
        }
    } );
} );
swifty.define( 'js/panels/add_asset/add_asset',[
    'jquery',
    'swiftylib/evt',
    'swiftylib/map',
    'js/panels/simple_panel/simple_panel',
    'js/panels/add_shortcode/add_shortcode',
    'swiftylib/i18n/__',
    'js/diverse/utils',
    'stache!js/panels/add_asset/add_asset.stache',
    'js/panels/panel_stack/panel_stack_instance',
    'js/panels/buy/buy'
], function(
    $, evt, Map, Panel, PanelAddShortcode, __, Utils, tmpl, panelStackInstance, BuyPanel
) {
    

    return Panel.extend( {
        'defaults': {
            'tmpl_content': tmpl,
            'title': __( 'Add content' ),
            '$column': null,
            'locked': false,
            'allowance': '',
            'wrap_at_bottom': false
        }
    }, {
        init: function() {
            var self = this;

            evt( 'get_assets' ).then( function( categoryList ) {
                self.options.asset_defs = {};

                categoryList.each( function( cat /*, i*/ ) {
                    var category = self.options.category;

                    if( ! category || category === '' || cat.attr( 'name' ).toLowerCase() === category.toLowerCase() ) {
                        cat.attr( 'assets' ).each( function( asset /*, j*/ ) {
                            if( asset.attr( 'shortcode' ) ) {
                                asset.attr( self._getAssetDef( asset.attr( 'shortcode' ), asset ) );
                            } else {
                                asset.attr( self._getAssetDef( '', asset ) );
                            }

                            var hide = 0;

                            // We are already hiding the clipboard category, but when we stop doing this we want this
                            // check.
                            if( asset.attr( 'shortcode' ) === 'paste_content' ) {
                                if( ! scc_data.is_content_clipboard_available ) {
                                    hide = 1;
                                }
                            }

                            if( self.options.allowance === 'insize_text_asset' ) {
                                if( asset.attr( 'shortcode' ) === 'swifty_text' ) {
                                    hide = 1;
                                }
                            } else {
                                // Hide all CK elements outside text asset.
                                if( ! asset.attr( 'shortcode' ) ) {
                                    hide = 1;
                                }

                                if( asset.attr( 'shortcode' ) === 'swifty_bloglist' && scc_data.post_type !== 'page' ) {
                                    hide = 1;
                                }
                            }
                            asset.attr( 'hide', hide === 1 ? '_HIDE_' : '' );
                        } );

                        self.options.asset_defs = cat.attr( 'assets' );
                    }
                } );

                self._super();
            } );
        },

        '.swc_panel_button click': function( $el ) {
            var self = this;

            $el = $el.closest( 'swc_panel_button' );

            var asset_type = $el.attr( 'data-asset_type' );
            var shortcode = $el.attr( 'shortcode' );
            var inline = ( $el.attr( 'data-inline' ) === 'true' );
            var tag = inline ? 'span' : 'div';
            // var coming_soon = ( $el.attr( 'ribbon_coming' ) === 'scvp' || $el.attr( 'ribbon_coming' ) === 'scgp' );
            var expired = $el.attr( 'ribbon_expired' ) && ( $el.attr( 'ribbon_expired' ) !== '' );
            var dialogUrl = '';
            if( $el.attr( 'ribbon_coming' ) === 'scvp' ) {
                dialogUrl = 'https://www.swifty.online/plugins_inbox/scc/visuals-pack-upsell/?rss3=asst1&swifty_mode=view&swifty_site=' + scc_data.home_url;
            }
            if( $el.attr( 'ribbon_coming' ) === 'scgp' ) {
                dialogUrl = 'https://www.swifty.online/plugins_inbox/scc/goodies-pack-upsell/?rss3=asst2&swifty_mode=view&swifty_site=' + scc_data.home_url;
            }

            if( expired ) {
                alert( 'Content element is not available without valid license: ' + $el.attr( 'ribbon_expired' ) );
            } else if( dialogUrl !== '' ) {
                new BuyPanel(
                    $( '<div></div>' ).appendTo( 'body' ),
                    {
                        'dialog_data': new Map( {
                            'url': dialogUrl
                        } )
                    }
                );
            } else if( shortcode && ( shortcode === 'add_shortcode' ) ) {
                self.closePanel();

                panelStackInstance.addPanel( PanelAddShortcode, {
                    'wrap_at_bottom': self.options.wrap_at_bottom,
                    '$column': self.options.$column
                } );
                
            } else if( shortcode && ( shortcode === 'paste_content' ) ) {
                self.closePanel();

                evt( 'swifty_copy_content_from_db' ).done( function(data) {
                    if( data ) {

                        var is_preset = self.options.wrap_at_bottom || ( data.source === 'row' ) ||
                            ( ! self.options.$column && ( data.source === 'swifty_text' ) );

                        if( is_preset && ( data.source !== 'row' ) ) {
                            data.content =
                                '[swifty_grid_row][swifty_grid_column]' +
                                data.content +
                                '[/swifty_grid_column][/swifty_grid_row]';
                        }

                        evt( 'convert_preset_html', {
                            'html': data.content
                        } ).then( function( html ) {

                            // Insert the html in the page.
                            evt( 'add_asset_to_content', {
                                'html': html,
                                'widget_class': ( ( data.source === 'row' ) || ( data.source === 'swifty_text' ) ) ? null : 'swc_asset',
                                'inline': false,
                                'takeSnapshot': true,
                                'only_insert_at_root': false,
                                'force_html_insert': true,
                                '$column': ( data.source !== 'row' ) ? self.options.$column : null,
                                'is_preset': is_preset
                            } ).then( function( $newEl ) {
                                if( $newEl && ( $newEl.length === 1 ) ) {
                                    evt( 'scroll_to_element', { $el: $newEl } );
                                }

                                evt( 'add_exec', { 'fn': 'swifty_check_inserts' } );
                                setTimeout( function() {
                                    evt( 'add_exec', { 'fn': 'swifty_check_inserts' } );
                                }, 1000 );

                                evt( 'add_exec', { 'evt': 'update_slideshows' } );
                                evt( 'add_exec', { 'evt': 'update_sliders' } );
                                evt( 'add_exec', { 'evt': 'update_gallery_grid' } );
                                evt( 'add_exec', { 'evt': 'update_gallery_flex' } );

                                // Fix for adding video's via presets.
                                setTimeout( function() {
                                    evt( 'video_fitvids' );
                                }, 1 );
                            } );
                        } );

                    }
                } );
            } else if( shortcode ) {
                var width = $el.attr( 'width' );
                var margins = '';
                var paddings = '';
                var d = new Date();
                var n = d.getTime();
                var insertClass = 'swc_asset_state_inserting' + n;
                var cssid = n + '_' + Math.floor((Math.random() * 99999) + 1);
                var wrapperid = ' id="c' + cssid + '"';
                var lockedClass = self.options.locked ? ' swc_locked' : '';
                var lockedData = self.options.locked ? '"swc_locked":"1",' : '';
                var widgetClass;

                // are we going to insert into table or grid? yes then width = 100, no margins
                evt( 'is_current_insert_position_in_table_or_grid',{} ).then( function( data ) {

                    if( data || self.options.$column || self.options.wrap_at_bottom ) {
                        width = 100;
                        margins = '"swc_margin_top":"0",' +
                            '"swc_margin_bottom":"0",' +
                            '"swc_margin_left":"0",' +
                            '"swc_margin_right":"0",';
                        if( shortcode === 'swifty_divider' ) {
                            paddings = '"swc_padding_top":"20",' +
                                '"swc_padding_bottom":"20",' +
                                '"swc_padding_left":"0",' +
                                '"swc_padding_right":"0",';
                        }
                    }

                    var html;

                    if( shortcode === 'swifty_text' ) {
                        margins = '"swc_margin_top":"0",'
                            + '"swc_margin_bottom":"0",';

                        html =
                            '<div class="swc_text ' + insertClass + lockedClass + '"' +
                            ' data-asset_type="' + shortcode + '"' + wrapperid + '>' +
                            '<div class="swc_asset_cntnt" ' +
                            ' data-asset_data="' +
                            Utils.utoa(
                                '{' +
                                lockedData +
                                margins +
                                '"swc_cssid":"' + cssid + '",' +
                                '"swc_width":"' + width + '"' +
                                '}' ) +
                            '">' +
                            '<p>' + __( 'Type your text here' ) + '</p>' +
                            '</div>' +
                            '</div>';
                        widgetClass = 'swc_text';
                    } else {
                        html = '<' + tag + ' class="swc_asset ' + insertClass + lockedClass + '" data-asset_type="' + asset_type + '"' + wrapperid + '>' +
                            '<' + tag + ' ' +
                            'class="swc_asset_cntnt" ' +
                            'data-asset_data="' + Utils.utoa( '{' +
                                '"swc_shortcode":"' + shortcode + '",' +
                                lockedData +
                                '"swc_cssid":"' + cssid + '",' +
                                '"swc_width":"' + width + '",' +
                                margins + paddings +
                                '"swc_swifty_on":"1"' +
                                '}' ) + '">' +
                            '</' + tag + '>' +
                            '</' + tag + '>';
                        widgetClass = 'swc_asset';
                    }

                    if( self.options.wrap_at_bottom ) {
                        html =
                            '<div class="swc_grid_row " style="margin-bottom: 20px; overflow-y: visible;" data-grid_data="{}" >' +
                            '<div class="swc_grid_colwrapper " style="margin-right: 20px;">' +
                            '<div class="swc_grid_column" style="" data-grid_data="{}">' +
                            html +
                            '</div><div class="swc_grid_colclose"></div></div></div>';
                    }

                    evt( 'add_asset_to_content', {
                        'html': html,
                        'widget_class': widgetClass,
                        'insert_class': insertClass,
                        'inline': inline,
                        'only_insert_at_root': false,
                        'force_html_insert': false,
                        '$column': self.options.$column,
                        'is_preset': self.options.wrap_at_bottom
                    } ).then( function( $newEl ) {
                        if( $newEl && ( $newEl.length === 1 ) ) {
                            evt( 'scroll_to_element', { $el: $newEl } );
                        }
                        // First time is done without a setTimeout in ckeditor_helper_asset.js.
                        setTimeout( function() {
                            $newEl.parent().css( 'clear', $newEl.css( 'clear' ) );
                        }, 3000 );
                    } );

                    self.closePanel();
                } );
            } else {
                self.closePanel();

                var dfd = new $.Deferred();

                dfd.done( function() {
                    evt( 'ckeditor_command', {
                        'command': $el.attr( 'action' )
                    } );
                } );

                if( self.options.$column ) {
                    evt( 'set_column_range_for_insert', {
                        '$column': self.options.$column
                    } ).done( function() {
                        dfd.resolve();
                    } );
                } else {
                    dfd.resolve();
                }
            }
        },

        '{window} evt_swc_asset_added': function( /*el, ev, opts*/ ) {
            this.markCloseOnFocus();
        },

        _getAssetDef: function( shortcode, asset ) {
            return {
                'name': asset.attr( 'name' ),
                'shortcode': shortcode,
                'icon': asset.attr( 'icon' ),
                'action': asset.attr( 'action' ),
                'is_shortcode': asset.attr( 'shortcode' ) ? true : false,
                'width': asset.attr( 'width' ),
                'inline': asset.attr( 'type' ) === 'inline' ? true : false,
                'paid': asset.attr( 'paid' ),
                'expired': asset.attr( 'expired' ),
                'coming': asset.attr( 'coming' )
            };
        }
    } );
} );
swifty.define('js/libs/mout/src/lang/kindOf',[],function () {

    var _rKind = /^\[object (.*)\]$/,
        _toString = Object.prototype.toString,
        UNDEF;

    /**
     * Gets the "kind" of value. (e.g. "String", "Number", etc)
     */
    function kindOf(val) {
        if (val === null) {
            return 'Null';
        } else if (val === UNDEF) {
            return 'Undefined';
        } else {
            return _rKind.exec( _toString.call(val) )[1];
        }
    }
    return kindOf;
});

swifty.define('js/libs/mout/src/lang/isKind',['./kindOf'], function (kindOf) {
    /**
     * Check if value is from a specific "kind".
     */
    function isKind(val, kind){
        return kindOf(val) === kind;
    }
    return isKind;
});

swifty.define('js/libs/mout/src/lang/isString',['./isKind'], function (isKind) {
    /**
     */
    function isString(val) {
        return isKind(val, 'String');
    }
    return isString;
});

swifty.define('js/libs/mout/src/object/hasOwn',[],function () {

    /**
     * Safer Object.hasOwnProperty
     */
     function hasOwn(obj, prop){
         return Object.prototype.hasOwnProperty.call(obj, prop);
     }

     return hasOwn;

});

swifty.define('js/libs/mout/src/object/forIn',['./hasOwn'], function (hasOwn) {

    var _hasDontEnumBug,
        _dontEnums;

    function checkDontEnum(){
        _dontEnums = [
                'toString',
                'toLocaleString',
                'valueOf',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'constructor'
            ];

        _hasDontEnumBug = true;

        for (var key in {'toString': null}) {
            _hasDontEnumBug = false;
        }
    }

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forIn(obj, fn, thisObj){
        var key, i = 0;
        // no need to check if argument is a real object that way we can use
        // it for arrays, functions, date, etc.

        //post-pone check till needed
        if (_hasDontEnumBug == null) checkDontEnum();

        for (key in obj) {
            if (exec(fn, obj, key, thisObj) === false) {
                break;
            }
        }


        if (_hasDontEnumBug) {
            var ctor = obj.constructor,
                isProto = !!ctor && obj === ctor.prototype;

            while (key = _dontEnums[i++]) {
                // For constructor, if it is a prototype object the constructor
                // is always non-enumerable unless defined otherwise (and
                // enumerated above).  For non-prototype objects, it will have
                // to be defined on this object, since it cannot be defined on
                // any prototype objects.
                //
                // For other [[DontEnum]] properties, check if the value is
                // different than Object prototype value.
                if (
                    (key !== 'constructor' ||
                        (!isProto && hasOwn(obj, key))) &&
                    obj[key] !== Object.prototype[key]
                ) {
                    if (exec(fn, obj, key, thisObj) === false) {
                        break;
                    }
                }
            }
        }
    }

    function exec(fn, obj, key, thisObj){
        return fn.call(thisObj, obj[key], key, obj);
    }

    return forIn;

});

swifty.define('js/libs/mout/src/object/forOwn',['./hasOwn', './forIn'], function (hasOwn, forIn) {

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forOwn(obj, fn, thisObj){
        forIn(obj, function(val, key){
            if (hasOwn(obj, key)) {
                return fn.call(thisObj, obj[key], key, obj);
            }
        });
    }

    return forOwn;

});

swifty.define('js/libs/mout/src/lang/isArray',['./isKind'], function (isKind) {
    /**
     */
    var isArray = Array.isArray || function (val) {
        return isKind(val, 'Array');
    };
    return isArray;
});

swifty.define('js/libs/mout/src/lang/isEmpty',['../object/forOwn', './isArray'], function (forOwn, isArray) {

    function isEmpty(val){
        if (val == null) {
            // typeof null == 'object' so we check it first
            return true;
        } else if ( typeof val === 'string' || isArray(val) ) {
            return !val.length;
        } else if ( typeof val === 'object' ) {
            var result = true;
            forOwn(val, function(){
                result = false;
                return false; // break loop
            });
            return result;
        } else {
            return true;
        }
    }

    return isEmpty;

});


swifty.define('stache!js/panels/add_preset/add_preset.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/panels/add_preset/add_preset.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<div class="swc_panel_add_preset swc_panel_content_wrap">\n    {{#if data.is_loading}}\n        <div class="swc_panel_preview_preset_loading"><div><i class="fa fa-refresh fa-spin"></i></div></div>\n    {{else}}\n        {{#if data.is_categories}}\n            {{#if is_page_setup}}\n                <div class="swc_panel_category_title swc_panel_category_title_main">{{__ \'Start with a blank page\'}}</div>\n                <div class="swc_panel_category_title swc_panel_category_title_sub">{{__ \'I will fill it with content myself ;-)\'}}</div>\n                <div class="swc_panel_add_asset">\n                    <swc_panel_button icon="fa-file-o" action="blank_page" name="{{__ \'Blank Page\'}}" data-preset_type="blank_page" />\n                </div>\n                <div class="swc_panel_category_title swc_panel_category_title_main">{{__ \'Start with a preset page\'}}</div>\n                <div class="swc_panel_category_title swc_panel_category_title_sub">{{__ \'Inspire me with a set of content that I can edit and change\'}}</div>\n            {{else}}\n                <div class="swc_panel_category_title">{{__ \'Presets\'}}</div>\n                <div class="swc_panel_add_asset">\n                    {{#each preset_defs}}\n                        {{#if is_page_preset}}\n                        {{else}}\n                            {{#if is_category}}\n                                <swc_panel_button icon="{{icon}}" action="{{preset_type}}" name="{{name}}"\n                                                  data-preset_type="{{preset_type}}"/>\n                            {{/if}}\n                        {{/if}}\n                    {{/each}}\n                </div>\n                {{#if data.has_page_presets}}\n                    <div class="swc_panel_category_title">{{__ \'Page presets\'}}</div>\n                {{/if}}\n            {{/if}}\n            <div class="swc_panel_add_asset">\n                {{#each preset_defs}}\n                    {{#if is_page_preset}}\n                        {{#if is_category}}\n                            <swc_panel_button icon="{{icon}}" action="{{preset_type}}" name="{{name}}"\n                                              data-preset_type="{{preset_type}}"/>\n                        {{/if}}\n                    {{/if}}\n                {{/each}}\n            </div>\n        {{else}}\n            <div class="swc_panel_add_preset_previews">\n                <div class="swc_panel_add_preset_previews_content" style="width: {{data.content_width}}px;">\n                    {{#if data.allow_ext}}\n                        {{#each preset_defs}}\n                            {{#if data.is_page_preset}}\n                                {{#if is_active}}\n                                    <div class="swc_panel_preview_preset swc_panel_preview_preset_active swc_panel_preview_preset_code_{{preset_type}}">\n                                        <div class="swc_panel_preview_preset_html">\n                                            <div class="swc_panel_preview_preset_top"></div>\n                                            {{#if is_loading}}\n                                                <div class="swc_panel_preview_preset_loading"><div><i class="fa fa-refresh fa-spin"></i></div></div>\n                                            {{else}}\n                                                {{&html}}\n                                            {{/if}}\n                                            <div class="swc_panel_preview_preset_bottom"></div>\n                                        </div>\n                                        <div class="swc_panel_preview_preset_overlay"></div>\n                                    </div>\n                                {{/if}}\n                            {{else}}\n                            <div class="swc_panel_preview_preset {{#if is_active}}swc_panel_preview_preset_active{{/if}} swc_panel_preview_preset_code_{{preset_type}}">\n                                <div class="swc_panel_preview_preset_html">\n                                    <div class="swc_panel_preview_preset_top"></div>\n                                    {{#if is_loading}}\n                                        <div class="swc_panel_preview_preset_loading"><div><i class="fa fa-refresh fa-spin"></i></div></div>\n                                    {{else}}\n                                        {{&html}}\n                                    {{/if}}\n                                    <div class="swc_panel_preview_preset_bottom"></div>\n                                </div>\n                                <div class="swc_panel_preview_preset_overlay"></div>\n                            </div>\n                            {{/if}}\n                        {{/each}}\n                    {{else}}\n                        <div class="swc_preset_permission_ext">\n                            We would like your permission to check our servers for the latest versions of the Presets. These are regularly updated as our designers create new and creative sets of content for you to use. We also need your permission to gather anonymous stats of the way users use our software (helps us make it even better). You only have to click this button once.<br>\n                            <br><br>\n                            <div class="swc_msg_buttons">\n                                <div class="swc_button swc_btn_allow_ext">Yes, show me the good stuff!</div>\n                            </div>\n                        </div>\n                    {{/if}}\n                </div>\n            </div>\n        {{/if}}\n    {{/if}}\n</div>\n' ); return idn; });

swifty.define('js/libs/mout/src/object/keys',['./forOwn'], function (forOwn) {

    /**
     * Get object keys
     */
     var keys = Object.keys || function (obj) {
            var keys = [];
            forOwn(obj, function(val, key){
                keys.push(key);
            });
            return keys;
        };

    return keys;

});

// Wil create a deferred that contains an array of multiple deferreds.
// The deferred will only trigger it's done() when ALL deferreds are resolved.
//
// Usage:
//
// Create the deferred:
// var dfds = NewDfds(); // NewDfds = the function returned by this amd object.
//
// Add a deferred:
// var dfd = $.Deferred();
// dfds.add( dfd );
//
// Execute when all deferreds are resolved:
// dfds.done( function() { ... } );

swifty.define( 'swiftylib/deferreds',[
    'jquery'
], function( $ ) {
    

    return function() {
        // create an array constructor
        var Array2 = function() {
            // initialise the array
            var x = [], a = arguments;
            for( var i = 0; i < a.length; i++ ) {
                x.push( a[ i ] )
            }
            for( i in this ) {
                x[ i ] = this[ i ]
            }
            return x;
        };

        // inherit from Array
        Array2.prototype = [];

        Array2.prototype.add = function( dfd ) {
            this.push( dfd );
        };

        Array2.prototype.done = function( doneFunction ) {
            $.when.apply( $, this ).done( doneFunction );
        };

        return new Array2();
    };
} );


swifty.define('stache!js/panels/apply_preset/apply_preset.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/panels/apply_preset/apply_preset.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<div class="swc_panel_add_preset swc_panel_add_preset_approve swc_panel_content_nowrap">\n    {{#if preset_data.loading}}\n        {{__ "One moment please..." }}<br>\n        {{__ "We\'re getting the preset ready for your page. This can take a while, depending on complexity and the number of images." }}\n    {{else}}\n        <swc_panel_button icon="&#xe02f;" action="no" name="{{__ "Undo. Remove the preset." }}"/>\n        <swc_panel_button icon="&#xe033;" action="yes" name="{{__ "Great. Let\'s keep this." }}"/>\n        {{#if area_visibility_changed}}\n        <div class="swc_notice_msg">\n            <div>{{__ "This preset changes some of the areas on this page. You can change that later in the page options." }}</div>\n        </div>\n        {{/if}}\n        <div class="swc_notice_msg">\n            <div>{{__ "Keeping this preset implies you agree to the terms and conditions stated in the preset- and image licence." }}</div>\n            <div><a href="https://www.swifty.online/license/proprietary-license/?rss3=prst1" target="_blank">{{__ "Read more..." }}</a></div>\n        </div>\n    {{/if}}\n</div>\n' ); return idn; });


swifty.define('css!js/panels/apply_preset/apply_preset',[],function(){});
swifty.define( 'js/panels/apply_preset/apply_preset',[
    'jquery',
    'swiftylib/evt',
    'swiftylib/map',
    'swiftylib/list',
    'js/libs/mout/src/object/keys',
    'js/panels/panel/panel',
    'swiftylib/i18n/__',
    'js/diverse/utils',
    'swiftylib/deferreds',
    'js/panels/panel_stack/panel_stack_instance',
    'stache!js/panels/apply_preset/apply_preset.stache',
    // No return values:
    'css!js/panels/apply_preset/apply_preset.css'
], function(
    $, evt, Map, List, keys, Panel, __, Utils, NewDfds, panelStackInstance, tmpl
) {
    

    return Panel.extend( {
        'defaults': {
            'tmpl_content': tmpl,
            'title': __( 'Preset' ),
            'preset_path': '',
            'preset_data': new Map( { 'loading': true } ),
            'preset_areas': null,
            'areas': [ 'topbar', 'header', 'navbar', 'sidebar', 'extrasidebar', 'footer', 'bottombar' ]
        }
    }, {
        init: function() {
            var self = this;

            self.options.preset_data.attr( 'loading', true );
            self.options.preset_areas = new Map();
            self.options.area_visibility_changed = false;
            self.options.ssd_settings = null;

            self.removeLicenseFromPreset();
            self.getSSDSettingsFromPreset();
            self.applyPreset();

            self._super();
        },

        // Load and insert the preset in the content.

        applyPreset: function() {
            var self = this;

            evt( 'convert_preset_html', {
                'html': self.options.html
            } ).then( function( html ) {
                self.getAreasHTMLFromPreset( html );

                var presetAreasObj = self.options.preset_areas.attr();
                var main_html = '';

                if( scc_data.is_swifty_site_designer_active ) {
                    main_html = self.options.main_html;
                    if( ! $.isEmptyObject( presetAreasObj ) ) {
                        evt( 'change_current_areas', { 'preset_areas': self.options.preset_areas } );
                    }
                } else {
                    self.options.preset_areas.each( function( area_map, area_name ) {
                        main_html += area_map.attr( 'html' );
                        if( ( area_name === 'sidebar' ) && self.options.main_html ) {
                            main_html += self.options.main_html;
                        }
                    } );
                }

                if( main_html ) {
                    // Insert the html in the main area of the page.
                    evt( 'add_asset_to_content', {
                        'html': main_html,
                        'insert_class': null,
                        'inline': false,
                        'takeSnapshot': true,
                        'only_insert_at_root': true,
                        'force_html_insert': true,
                        'is_preset': true
                    } ).then( function( $newEl ) {
                        self.checkInsertedPreset( $newEl );
                    } );
                } else {
                    if( ! $.isEmptyObject( presetAreasObj ) ) {
                        var areaKeys = keys( presetAreasObj );

                        if( $.isArray( areaKeys ) && areaKeys.length === 1 ) {
                            var $iFrameContent = $( '#swc_iframe' ).contents();

                            self.checkInsertedPreset( $iFrameContent.find( '.swifty_area_' + areaKeys[ 0 ] ) );
                        }
                    }
                }
            } );
        },

        checkInsertedPreset: function( $el ) {
            var self = this;

            evt( 'scroll_to_element', { $el: $el } );
            evt( 'add_exec', { 'fn': 'swifty_check_inserts' } );

            setTimeout( function() {
                evt( 'add_exec', { 'fn': 'swifty_check_inserts' } );
            }, 1000 );

            // Fix for adding video's via presets.
            setTimeout( function() {
                evt( 'video_fitvids' );
            }, 1 );

            self.options.preset_data.attr( 'loading', false );
        },

        removeLicenseFromPreset: function() {
            var self = this;

            self.options.html = self.options.html.replace( /<!--\nBy using [^>]*>/gmi, '' );
        },

        getSSDSettingsFromPreset: function() {
            var self = this;
            var rgxSSD = new RegExp( '\<!--\\s*SSD\.SETTINGS\\s*(\{.*?\})\\s*--\>', 'gmi' );
            var ssd = rgxSSD.exec( self.options.html );

            if( $.isArray( ssd ) && ssd.length === 2 && ssd[ 1 ] ) {
                self.options.html = $.trim( self.options.html.replace( ssd[ 0 ], '' ) );
                self.options.ssd_settings = $.parseJSON( ssd[ 1 ] );
            }
        },

        getAreasHTML: function( area, html ) {
            // When autop is enabled, P tags surround the html comments.
            // When autop is disabled, no P tags exist around the html comments.
            var rgxAreas = new RegExp(
                '(<p>)?\<!--\\s*AREA\.' + area + '\.BEGIN\\s*--\>(<\/p>)?([\\s\\S]*?)(<p>)?\<!--\\s*AREA\.' + area + '\.END\\s*--\>(<\/p>)?',
                'gmi'
            );

            return rgxAreas.exec( html );
        },

        getAreasHTMLFromPreset: function( html ) {
            var self = this;
            var $iFrameContent = $( '#swc_iframe' ).contents();

            $.each( self.options.areas, function( i, area ) {
                var $curArea = $iFrameContent.find( '.swifty_area_' + area );
                var areaHtml = self.getAreasHTML( area, html );

                // If area html exists in the page preset, we use that html for the area and turn the area on.
                // areaHTML[ 0 ] contains the full area html including the area html comments.
                // areaHTML[ 3 ] contains only the html between the area html comments.
                if( $.isArray( areaHtml ) && areaHtml.length === 6 && areaHtml[ 3 ] ) {
                    if( area === scc_data.area ) {
                        html = areaHtml[3];
                    } else {
                        html = $.trim( html.replace( areaHtml[ 0 ], '' ) );

                        if( ! self.options.preset_areas.attr( area ) ) {
                            self.options.preset_areas.attr( area, new Map() );
                        }

                        self.options.preset_areas.attr( area ).attr( {
                            'html': $.trim( areaHtml[ 3 ] ),
                            'overrule': 'show'
                        } );

                        if( $curArea.is( ':hidden' ) ) {
                            self.options.area_visibility_changed = true;
                        }
                    }
                // No area html exists in the page preset, so we check the ssd settings from the page preset.
                // If the area has a visibility property and it differs from the current visibility, we will turn the
                // area on or off.
                } else {
                    var ssdSettings = self.options.ssd_settings;

                    if( ssdSettings &&
                        ssdSettings.areas &&
                        ssdSettings.areas[ area ] &&
                        ssdSettings.areas[ area ].hasOwnProperty( 'visibility' )
                    ) {
                        var visibility = ssdSettings.areas[ area ].visibility;
                        var visibilityChanged = false;

                        if( ( $curArea.is( ':visible' ) && ! visibility ) ||
                            ( $curArea.is( ':hidden' ) && visibility )
                        ) {
                            visibilityChanged = true;
                        }

                        if( visibilityChanged ) {
                            self.options.area_visibility_changed = true;

                            if( ! self.options.preset_areas.attr( area ) ) {
                                self.options.preset_areas.attr( area, new Map() );
                            }

                            self.options.preset_areas.attr( area ).attr( {
                                'html': null,
                                'overrule': visibility ? 'show' : 'hide'
                            } );
                        }
                    }
                }
            } );

            self.options.main_html = $.trim( html ) || '';
        },

        '.swc_back_button click': function( /*el, ev*/ ) {
            evt( 'restore_current_areas' );

            if( this.options.main_html ) {
                evt( 'ckeditor_undo_last_image' );
            }

            this.closePanel();
        },

        '.swc_panel_button_yes click': function() {
            var self = this;

            evt( 'save_current_areas', {
                'preset_areas': self.options.preset_areas
            } ).done( function() {
                panelStackInstance.resetPanelStack();
                self.closePanel();
            } );
        },

        '.swc_panel_button_no click': function() {
            evt( 'restore_current_areas' );

            if( this.options.main_html ) {
                evt( 'ckeditor_undo_last_image' );
            }

            this.closePanel();
        }

    } );

} );

swifty.define('stache!js/panels/add_preset/add_preset_panel.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/panels/add_preset/add_preset_panel.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<div class="swc_panel swc_overlay_panel {{panel_css_class}}">\n    <div class="swc_panel_container">\n        <div class="swc_panel_content">\n            {{#if tmpl_content}}\n                {{&renderStache tmpl_content}}\n            {{/if}}\n        </div>\n        <div class="clearfix"></div>\n        <div class="swc_iframe_gradient"></div>\n    </div>\n\n    <div class="swc_panel_bottom_container">\n        <div class="swc_panel_back_container {{#eq back_action \'exit\'}}swc_back_exit{{/eq}}">\n            <div class="swc_back_button swc_button">\n                {{#eq panel_css_class \'swc_small_panel\'}}\n                    &#xe900;\n                {{else}}\n                    <i class="fa fa-chevron-left"></i>\n                {{/eq}}\n            </div>\n        </div>\n\n        {{#if data.is_categories}}\n            <div class="swc_panel_title_container">\n                <div class="swc_panel_title_pos">\n                    <div class="swc_title">\n                        {{__ title}}\n                    </div>\n                </div>\n            </div>\n        {{else}}\n            <div class="swc_panel_title_container">\n                <div class="swc_panel_title_pos">\n                    <div class="swc_title">\n                        {{__ title}}\n                    </div>\n                    <div class="swc_title swc_preset_code">\n                        {{__ data.active_code}}\n                    </div>\n                </div>\n            </div>\n\n            {{#if data.allow_ext}}\n                <div class="swc_panel_presets_choose_container">\n                    <div class="swc_button swc_preset_previous">\n                        <i class="fa fa-chevron-left"></i>\n                    </div>\n                    <div class="swc_title swc_preset_nr_tot">\n                        {{data.active_nr}}/{{data.total_nr}}\n                    </div>\n                    <div class="swc_button swc_preset_next">\n                        <i class="fa fa-chevron-right"></i>\n                    </div>\n                    <div class="swc_button swc_preset_try_this_one">\n                        {{__ \'Try this one\'}}\n                    </div>\n                </div>\n            {{/if}}\n        {{/if}}\n    </div>\n</div>' ); return idn; });


swifty.define('css!js/panels/add_preset/add_preset',[],function(){});
swifty.define( 'js/panels/add_preset/add_preset',[
    'jquery',
    'swiftylib/evt',
    'swiftylib/map',
    'swiftylib/list',
    'swiftylib/sort',
    'js/libs/mout/src/lang/isString',
    'js/libs/mout/src/lang/isEmpty',
    'js/panels/overlay_panel/overlay_panel',
    'swiftylib/i18n/__',
    'js/diverse/utils',
    'stache!js/panels/add_preset/add_preset.stache',
    'js/panels/panel_stack/panel_stack_instance',
    'js/panels/apply_preset/apply_preset',
    'stache!js/panels/add_preset/add_preset_panel.stache',
    'js/libs/yepnope',
    // No return values:
    'css!js/panels/add_preset/add_preset.css'
], function(
    $, evt, Map, List, Sort, isString, isEmpty, Panel, __, Utils, tmpl, panelStackInstance, ApplyPresetPanel, tmplBottom, yepnope
) {
    

    function getSWCreatorAjaxUrl() {
        return Utils.updateQueryString( 'swcreator_ajax', true, scc_data.view_url );
    }

    var PresetPanel = Panel.extend( {
        'defaults': {
            'tmpl': tmplBottom,
            'tmpl_content': tmpl,
            'title': __( 'Add preset' ),
            'panel_css_class': 'swc_overlay_preset_panel',
            'preset_defs': null,
            'preset_path': '',
            'icons': [   // This is the order in which the icons must appear in the panel.
                { 'key': 'icons', 'name': __( 'Icons' ), 'icon': '&#xe926;' },
                { 'key': 'products', 'name': __( 'Products' ), 'icon': '&#xe90e;' },
                { 'key': 'services', 'name': __( 'Services' ), 'icon': '&#xe90f;' },
                // { 'key': 'portfolio', 'name': __( 'Portfolio' ), 'icon': '&#xe91c;' },
                { 'key': 'break_out', 'name': __( 'Break out' ), 'icon': '&#xe913;' },
                { 'key': 'social', 'name': __( 'Social' ), 'icon': '&#xe922;' },
                { 'key': 'meet_the_team', 'name': __( 'Meet the team' ), 'icon': '&#xe923;' },
                { 'key': 'images', 'name': __( 'Images' ), 'icon': '&#xe919;' },
                { 'key': 'video', 'name': __( 'Video' ), 'icon': '&#xe925;' },
                // { 'key': 'showcase', 'name': __( 'Showcase' ), 'icon': '&#xe921;' },
                // { 'key': 'features', 'name': __( 'Features' ), 'icon': '&#xe916;' },
                // { 'key': 'pricing_table', 'name': __( 'Pricing table' ), 'icon': '&#xe91d;' },
                // { 'key': 'faq', 'name': __( 'FAQ' ), 'icon': '&#xe915;' },
                // { 'key': 'testimonials', 'name': __( 'Testimonials' ), 'icon': '&#xe924;' },
                // { 'key': 'call_to_action', 'name': __( 'Call to action' ), 'icon': '&#xe914;' },
                { 'key': 'text', 'name': __( 'Text' ), 'icon': '&#xe927;' },
                // { 'key': 'logos', 'name': __( 'Logos' ), 'icon': '&#xe91a;' },
                { 'key': 'header', 'name': __( 'Header' ), 'icon': '&#xe918;' },
                { 'key': 'footer', 'name': __( 'Footer' ), 'icon': '&#xe917;' },
                // { 'key': 'blog', 'name': __( 'Blog' ), 'icon': '?' },
                // { 'key': 'opening_hours', 'name': __( 'Opening hours' ), 'icon': '&#xe91b;' },
                // { 'key': 'restaurant_menu', 'name': __( 'Restaurant menu' ), 'icon': '&#xe91f;' },
                // Page presets
                { 'key': 'page_homepage', 'name': __( 'Homepage' ), 'icon': '&#xe90b;' },
                { 'key': 'page_products', 'name': __( 'Products' ), 'icon': '&#xe90e;' },
                { 'key': 'page_services', 'name': __( 'Services' ), 'icon': '&#xe90f;' },
                { 'key': 'page_about_us', 'name': __( 'About us' ), 'icon': '&#xe908;' },
                { 'key': 'page_contact', 'name': __( 'Contact' ), 'icon': '&#xe90a;' },
                { 'key': 'page_our_team', 'name': __( 'Our team' ), 'icon': '&#xe923;' },
                { 'key': 'page_photos', 'name': __( 'Photos' ), 'icon': '&#xe919;' }
            ]
        }
    }, {
        init: function() {
            var self = this;

            $.each( self.options.icons, function( i /*, presetObj*/ ) {
                self.options.icons[ i ].order = i;
            } );

            self.options.data = new Map( {
                'is_categories': true,
                'is_page_preset': self.options.preset_path && /^\/page_/.test( self.options.preset_path ),
                'has_page_presets': false,
                'content_width': 800,
                'is_loading': true,
                'active_code': '',
                'active_nr': 1,
                'total_nr': 1,
                'allow_ext': false
            } );

            self.options.data.bind( 'active_code', $.proxy( self.activeCodeChanged, self ) );

            self.options.preset_defs = new List();
            self.options.preset_defs.attr( 'comparator', 'order' );

            evt( 'get_main_content_width' ).then( function( w ) {
                if( w > 0 ) {
                    self.options.data.attr( 'content_width', w );
                }
            } );

            // Add probe test category.

            if( self.options.preset_path === '' ) {
                if( typeof swiftyProbe !== 'undefined' ) {
                    self.options.preset_defs.push( {
                        'name': 'Probe',
                        'preset_type': 'probe',
                        'is_category': true,
                        'icon': '?',
                        'preset_defs': new Map()
                        //},
                        //{
                        //    'name': 'Test2',
                        //    'icon': '?',
                        //    'html': '[swifty_search_box swc_swifty_on="1"][swifty_box swc_swifty_on="1"]'
                    } );
                }
            }

            // Add probe tests.

            if( typeof swiftyProbe !== 'undefined' && self.options.preset_path === '/probe' ) {
                var tests = [ 'preset_test1', 'preset_test2', 'preset_test3' ];
                $.each( tests, function( i, test ) {
                    $.get( scc_data.swcreator_url + 'js/probe/test_data/' + test + '.txt', function( data ) {
                        self.options.preset_defs.push( {
                            'name': test,
                            'preset_type': test,
                            'is_category': false,
                            'icon': '?'
                        } );
                        self.convertAndAddPreset( test, data );

                        //self.options.map.preset_defs.attr( test, {
                        //    'name': test,
                        //    'icon': '?',
                        //    'html': data
                        //} );
                    } );
                } );
            }

            self.options.dfdWaitSlide = new $.Deferred();
            setTimeout( function() {
                self.options.dfdWaitSlide.resolve();
            }, 500 ); // Wait for the panel slide animation to finish.

            self.updatePresets();

            self._super();

            evt( 'reset_mobile_view' );
            
            // Get the css styles from the page and apply them here, so all presets will look right.
            var head = document.head || document.getElementsByTagName( 'head' )[0];
            if( $( head ).find( '#main_all_styles' ).length === 0 ) {
                evt( 'get_main_all_styles' ).then( function( css ) {

                    var style = document.createElement( 'style' );

                    style.id = 'main_all_styles';
                    style.type = 'text/css';
                    if( style.styleSheet ) {
                        style.styleSheet.cssText = css;
                    } else {
                        style.appendChild( document.createTextNode( css ) );
                    }
                    head.appendChild( style );
                } );

                evt( 'get_ssd_list_loadfont' ).then( function( list_loadfont ) {
                    yepnope.injectJs( { _url: '//ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js' }, function() {
                        try {
                            var ssdWebfonts = {
                                google: {
                                    families: list_loadfont
                                }
                            };
                            WebFont.load( ssdWebfonts );
                        } catch( e ) {}
                    } );

                } );
            }
        },

        // Load the preset defs for the current category (or root).

        updatePresets: function() {
            var self = this;

            self.options.data.attr( 'has_page_presets', false );

            evt( 'check_swifty_allow_external' ).then( function( allowExternal ) {
                if( allowExternal === 'allow' ) {
                    // Phone home specifically allowed.
                    self.options.data.attr( 'allow_ext', true );

                    $.ajax( {
                        url: "https://stuff.swifty.online/stuff/data/get.php",
                        type: "POST",
                        data: {
                            "do": "preset_list",
                            "path": self.options.preset_path
                        },
                        dataType: "json",
                        xhrFields: { withCredentials: true }
                    } ).then( function( data ) {
                        self.options.dfdWaitSlide.then( function() {
                            var aCats = 0;
                            var aItems = self.options.preset_defs.length;

                            $.each( data.result, function( i, preset ) {
                                var obj = self.getPresetObj( preset.name, preset._id, preset.tp, i );
                                if( obj ) {
                                    aItems ++;

                                    if( preset.tp === 'dir' ) {
                                        aCats ++;
                                    }

                                    if( obj.is_page_preset ) {
                                        self.options.data.attr( 'has_page_presets', true );
                                    }

                                    self.options.preset_defs.push( obj );
                                }
                            } );

                            if( ! aCats ) {
                                self.updateActive();
                                self.getPresetFromServer( 0 );
                            }

                            self.updateTotals( aCats !== 0, aItems );
                        } );
                    } );
                } else {
                    // Phone home is not specifically allowed.
                    var aItems = self.options.preset_defs.length;

                    if( self.options.preset_path === '' ) {
                        $.each( self.options.icons, function( i, icon ) {
                            var obj = self.getPresetObj( icon.name, icon.key, 'dir', i );
                            if( obj ) {
                                aItems ++;

                                if( obj.is_page_preset ) {
                                    self.options.data.attr( 'has_page_presets', true );
                                }

                                self.options.preset_defs.push( obj );
                            }
                        } );

                        self.updateTotals( true, aItems );
                    } else {
                        self.updateTotals( false, aItems );
                    }
                }
            } );
        },

        getPresetObj: function( name, id, tp, i ) {
            var self = this;

            var obj = {
                'name': name,
                'is_loading': true,
                'is_active': false,
                'preset_type': id
            };

            if( i === 0 ) {
                obj.is_active = true;
                self.options.data.attr( 'active_code', name );
            }

            if( tp === 'dir' ) {
                obj.is_category = true;

                var iconFiltered = null;
                $.each( self.options.icons, function( ii, icon ) {
                    if( icon.key === id ) {
                        iconFiltered = icon;
                    }
                } );

                if( iconFiltered ) {
                    obj.icon = iconFiltered.icon;
                    obj.name = iconFiltered.name;

                    if( iconFiltered.order >= 0 ) {
                        obj.order = iconFiltered.order;
                    }
                } else {
                    obj.icon = '?';
                }

                if( id.substr( 0, 5 ) === 'page_' ) {
                    obj.is_page_preset = true;
                }
            }
            // some checks to ensure only sensible options are added
            if( obj.is_category) {
                if( obj.is_page_preset ) {
                    // page presets only in main area
                    if( scc_data.area !== 'main' ) {
                        return null;
                    }
                } else {
                    if( scc_data.area !== 'main' ) {
                        // only show footer or header in the corresponding area (or main ofcourse)
                        if( ( id === 'footer' ) || ( id === 'header' ) ) {
                            if( scc_data.area !== id ) {
                                return null;
                            }
                        }
                    }
                }
            }
            return obj;
        },

        updateTotals: function( isCats, aItems ) {
            var self = this;

            self.options.data.attr( { 'is_categories': isCats, 'is_loading': false } );
            self.options.data.attr( 'total_nr', aItems );
        },

        convertAndAddPreset: function( presetId, data ) {
            var self = this;

            if( data && isString( data ) && ! isEmpty( data ) ) {
                var htmlSettings = {
                    'replaceImages': false,
                    'html': data
                };

                evt( 'convert_preset_html', { 'htmlSettings': htmlSettings } ).done( function( html ) {
                    var presetDef = self.getPresetFromList( presetId );

                    // Remove top level P-tags from the html.
                    // They contain html comments with settings or header definitions
                    var filteredHtml = '';

                    $( html ).filter( '.swc_grid_row' ).each( function() {
                        filteredHtml += $.trim( $( this ).prop( 'outerHTML' ) );
                    } );

                    if( presetDef ) {
                        presetDef.attr( {
                            'html': filteredHtml,
                            'html_code': data,
                            'is_loading': false
                        } );

                        self.checkPresetPreview();
                    }
                } );
            }
        },

        getPresetFromServer: function( index ) {
            var self = this;

            if( index < self.options.preset_defs.length ) {
                var preset = self.options.preset_defs.attr( index );
                var presetId = preset.attr( 'preset_type' );

                $.ajax( {
                    url: "https://stuff.swifty.online/stuff/data/get.php",
                    type: "POST",
                    data: {
                        "do": "preset_file",
                        "path": self.options.preset_path + '/' + presetId + '.html'
                    },
                    xhrFields: { withCredentials: true }
                } ).always( function( data ) {

                    self.convertAndAddPreset( presetId, data );

                    index++;

                    self.getPresetFromServer( index );
                } );
            }
        },

        checkPresetPreview: function() {
            setTimeout( function() {
                yepnope.injectJs( { _url: scc_data.view_js_url }, function() {
                    window.ssd_status_onload = 1;
                    swifty_check_inserts();

                    setTimeout( function() {
                        swifty_check_inserts();
                    }, 1000 );
                } );

                // Fix for video's.
                yepnope.injectJs( { _url: scc_data.swcreator_url + 'js/libs/jquery.fitvids.js' }, function() {
                    $( '.swc_video_wrapper' ).fitVids();

                    var $div = $( '<div class="frameOverlay"/>' );
                    $( '.swc_video_wrapper iframe' ).after( $div );
                } );
            }, 1 );
        },

        getPresetFromList: function( presetType ) {
            var presetList = this.options.preset_defs.filter( function( item /*, i, list*/ ) {
                return item.attr( 'preset_type' ) === presetType;
            } );

            return ( presetList.length === 1 ) ? presetList.attr( 0 ) : null;
        },

        activeCodeChanged: function( ev, newVal/*, oldVal*/ ) {
            var self = this;

            if ( self.options.data.attr( 'is_page_preset' ) && newVal ) {
                self.checkPresetPreview();
            }
        },

        '.swc_btn_allow_ext click': function( /*$el*/ ) {
            var self = this;

            evt( 'set_swifty_allow_external', { allow: 'allow' } ).then( function() {
                self.options.data.attr( 'allow_ext', true );

                evt( 'update_presets_in_panels' );
            } );
        },

        '.swc_panel_button click': function( $el ) {
            var self = this;

            $el = $el.closest( 'swc_panel_button' );

            var presetType = $el.attr( 'data-preset_type' );
            var presetDef = self.getPresetFromList( presetType );


            if( presetDef.is_category ) {
                // Clicked on a category. Open a panel with that categories presets.
                panelStackInstance.addPanel( PresetPanel, {
                    'preset_path': self.options.preset_path + '/' + presetType,
                    'title': presetDef.attr( 'name' )
                } );
            }
        },

        '.swc_preset_try_this_one click': function() {
            var self = this;

            evt( 'store_current_areas' );

            self.options.preset_defs.each( function( def /*, i*/ ) {
                if( def.attr( 'is_active' ) ) {
                    panelStackInstance.addPanel( ApplyPresetPanel, {
                        'preset_path': self.options.preset_path + '/' + def.attr( 'preset_type' ),
                        'html': def.attr( 'html_code' )
                    } );
                }
            } );

        },

        '.swc_preset_previous click': function() {
            var self = this;
            var n = self.options.data.attr( 'active_nr' );
            if( n > 1 ) {
                self.options.data.attr( 'active_nr', n - 1 );
                self.updateActive();
            }
        },

        '.swc_preset_next click': function() {
            var self = this;
            var n = self.options.data.attr( 'active_nr' );
            if( n < self.options.data.attr( 'total_nr' ) ) {
                self.options.data.attr( 'active_nr', n + 1 );
                self.updateActive();
            }
        },

        updateActive: function() {
            var self = this;
            var nr = 0;
            self.options.preset_defs.each( function( def /*, i*/ ) {
                nr++;
                if( nr === self.options.data.attr( 'active_nr' ) ) {
                    def.attr( 'is_active', true );
                    self.options.data.attr( 'active_code', def.attr( 'name' ) );
                    self.scrollActive( def.attr( 'preset_type' ) );
                } else {
                    def.attr( 'is_active', false );
                }
            } );
        },

        scrollActive: function( code ) {
            var $el = $( '.swc_panel_preview_preset_code_' + code );
            if( $el.length > 0 ) {
                var pos = $el.offset().top;
                var height = $el.height();
                var $elFirst = $( '.swc_panel_preview_preset:first' );
                var posFirst = $elFirst.offset().top;
                var $elPanel = $( '.swc_panel_add_preset' );
                var heightPanel = $elPanel.innerHeight();

                if( height < heightPanel ) {
                    pos -= ( heightPanel - height ) / 2;
                }

                $( $elPanel ).animate( {
                    scrollTop: pos - posFirst
                }, 300, 'swing', function() {
                } );
            }
        },

        '{window} evt_swc_update_presets_in_panels': function(/* el, ev, opts*/ ) {
            this.options.preset_defs.replace( [] );

            this.updatePresets();
        }
    } );

    return PresetPanel;
} );
swifty.define('js/libs/mout/src/function/identity',[],function () {

    /**
     * Returns the first argument provided to it.
     */
    function identity(val){
        return val;
    }

    return identity;

});

swifty.define('js/libs/mout/src/function/prop',[],function () {

    /**
     * Returns a function that gets a property of the passed object
     */
    function prop(name){
        return function(obj){
            return obj[name];
        };
    }

    return prop;

});

swifty.define('js/libs/mout/src/object/deepMatches',['./forOwn', '../lang/isArray'], function(forOwn, isArray) {

    function containsMatch(array, pattern) {
        var i = -1, length = array.length;
        while (++i < length) {
            if (deepMatches(array[i], pattern)) {
                return true;
            }
        }

        return false;
    }

    function matchArray(target, pattern) {
        var i = -1, patternLength = pattern.length;
        while (++i < patternLength) {
            if (!containsMatch(target, pattern[i])) {
                return false;
            }
        }

        return true;
    }

    function matchObject(target, pattern) {
        var result = true;
        forOwn(pattern, function(val, key) {
            if (!deepMatches(target[key], val)) {
                // Return false to break out of forOwn early
                return (result = false);
            }
        });

        return result;
    }

    /**
     * Recursively check if the objects match.
     */
    function deepMatches(target, pattern){
        if (target && typeof target === 'object' &&
            pattern && typeof pattern === 'object') {
            if (isArray(target) && isArray(pattern)) {
                return matchArray(target, pattern);
            } else {
                return matchObject(target, pattern);
            }
        } else {
            return target === pattern;
        }
    }

    return deepMatches;

});

swifty.define('js/libs/mout/src/function/makeIterator_',['./identity', './prop', '../object/deepMatches'], function(identity, prop, deepMatches) {

    /**
     * Converts argument into a valid iterator.
     * Used internally on most array/object/collection methods that receives a
     * callback/iterator providing a shortcut syntax.
     */
    function makeIterator(src, thisObj){
        if (src == null) {
            return identity;
        }
        switch(typeof src) {
            case 'function':
                // function is the first to improve perf (most common case)
                // also avoid using `Function#call` if not needed, which boosts
                // perf a lot in some cases
                return (typeof thisObj !== 'undefined')? function(val, i, arr){
                    return src.call(thisObj, val, i, arr);
                } : src;
            case 'object':
                return function(val){
                    return deepMatches(val, src);
                };
            case 'string':
            case 'number':
                return prop(src);
        }
    }

    return makeIterator;

});

swifty.define('js/libs/mout/src/array/findIndex',['../function/makeIterator_'], function (makeIterator) {

    /**
     * Returns the index of the first item that matches criteria
     */
    function findIndex(arr, iterator, thisObj){
        iterator = makeIterator(iterator, thisObj);
        if (arr == null) {
            return -1;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            if (iterator(arr[i], i, arr)) {
                return i;
            }
        }

        return -1;
    }

    return findIndex;
});

swifty.define( 'js/diverse/categories',[
    'jquery',
    'can',
    'swiftylib/construct',
    'swiftylib/i18n/__',
    'js/libs/mout/src/array/findIndex'
], function(
    $, can, Construct, __, findIndex
) {
    

    var Categories = Construct.extend( {
        categories: [
            { 'icon': '&#xe057;', 'name': __( 'Clipboard' ), 'action': 'clipboard' },
            { 'icon': '&#xe058;', 'name': __( 'Interactive' ), 'action': 'interactive' },
            { 'icon': '&#xe05b;', 'name': __( 'Text' ), 'action': 'textual' },
            { 'icon': '&#xe059;', 'name': __( 'Layout' ), 'action': 'layout' },
            { 'icon': '&#xe05a;', 'name': __( 'Other stuff' ), 'action': 'others' },
            { 'icon': '&#xe052;', 'name': __( 'Layout' ), 'action': 'presets' },
            { 'icon': '&#xe05c;', 'name': __( 'Visuals' ), 'action': 'visuals' },
            { 'icon': '&#xe05a;', 'name': __( 'Third Party' ), 'action': 'thirdparty' }
        ]
    }, {
        getCategory: function( category ) {
            var categories = this.constructor.categories;
            var cat = category.toLowerCase();
            var idx = findIndex( categories, { 'action': cat } );

            return ( idx >= 0 ) ? categories[ idx ] : {
                'icon': '&#xe015;',
                'name': __( can.capitalize( cat ) ),
                'action': cat
            };
        }
    } );

    return new Categories();
} );

swifty.define('stache!js/panels/pick_columns/pick_columns.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/panels/pick_columns/pick_columns.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<div class="swc_panel_content_wrap">\n    {{#each columns_defs}}\n        <div class="swc_panel_category_title {{#eq title \'\'}}swc_panel_category_t_empty{{/eq}}">{{title}}</div>\n        <div class="swc_panel_add_asset">\n            {{#each layouts}}\n                <swc_panel_button row_type="{{tp}}" action="columns" data-columns="{{tp}}" name="{{&replace tp \'-\' \'-<wbr>\'}}" />\n            {{/each}}\n        </div>\n    {{/each}}\n</div>\n' ); return idn; });

swifty.define( 'js/panels/pick_columns/pick_columns',[
    'jquery',
    'swiftylib/evt',
    'js/panels/overlay_panel/overlay_panel',
    'js/panels/panel_stack/panel_stack_instance',
    'swiftylib/i18n/__',
    'stache!./pick_columns.stache',
    'stache!js/panels/simple_panel/simple_panel.stache'
], function( $, evt, Panel, panelStackInstance, __, tmpl, simpleTmpl ) {
    

    var ThisPanel = Panel.extend( {
        'defaults': {
            'tmpl_content': tmpl,
            'title': __( 'Pick number of columns' ),
            'columns': 0,
            'columns_defs': {}
        }
    }, {
        init: function() {
            var self = this;

            //if( parseInt( self.options.columns + '', 10 ) < 1 ) {
            //    self.options.tmpl = simpleTmpl;
            //}

            for( var cls = 0; cls <= 8; cls++ ) {
                self.options.columns = cls;
                var clsName = cls;

                if( self.options.columns + '' === '0' ) {
                    self.options.columns_defs[ clsName ] = {
                        'title': 'Popular column layouts', 'layouts': [
                            { 'icon': '?', 'tp': '100' },
                            { 'icon': '?', 'tp': '20-60-20' },
                            { 'icon': '?', 'tp': '50-25-25' },
                            { 'icon': '?', 'tp': '33-66' },
                            { 'icon': '?', 'tp': '66-33' },
                            { 'icon': '?', 'tp': '33-33-33' },
                            { 'icon': '?', 'tp': '25-25-25-25' }
                        ]
                    };
                }

                if( self.options.columns + '' === '1' ) {
                    self.options.columns_defs[ clsName ] = {
                        'title': 'All column layouts', 'layouts': [
                            { 'icon': '?', 'tp': '100' }
                        ]
                    };
                }

                if( self.options.columns + '' === '2' ) {
                    self.options.columns_defs[ clsName ] = {
                        'title': '', 'layouts': [
                            { 'icon': '?', 'tp': '50-50' },
                            { 'icon': '?', 'tp': '33-66' },
                            { 'icon': '?', 'tp': '66-33' },
                            { 'icon': '?', 'tp': '25-75' },
                            { 'icon': '?', 'tp': '75-25' }
                        ]
                    };
                }

                if( self.options.columns + '' === '3' ) {
                    self.options.columns_defs[ clsName ] = {
                        'title': '', 'layouts': [
                            { 'icon': '?', 'tp': '33-33-33' },
                            { 'icon': '?', 'tp': '25-25-50' },
                            { 'icon': '?', 'tp': '25-50-25' },
                            { 'icon': '?', 'tp': '50-25-25' },
                            { 'icon': '?', 'tp': '20-20-60' },
                            { 'icon': '?', 'tp': '20-60-20' },
                            { 'icon': '?', 'tp': '60-20-20' },
                            { 'icon': '?', 'tp': '17-17-67' },
                            { 'icon': '?', 'tp': '17-67-17' },
                            { 'icon': '?', 'tp': '67-17-17' }
                        ]
                    };
                }

                if( self.options.columns + '' === '4' ) {
                    self.options.columns_defs[ clsName ] = {
                        'title': '', 'layouts': [
                            { 'icon': '?', 'tp': '25-25-25-25' },
                            { 'icon': '?', 'tp': '17-17-17-50' },
                            { 'icon': '?', 'tp': '50-17-17-17' },
                            { 'icon': '?', 'tp': '15-15-35-35' },
                            { 'icon': '?', 'tp': '35-35-15-15' }
                        ]
                    };
                }

                if( self.options.columns + '' === '5' ) {
                    self.options.columns_defs[ clsName ] = {
                        'title': '', 'layouts': [
                            { 'icon': '?', 'tp': '20-20-20-20-20' },
                            { 'icon': '?', 'tp': '17-17-17-17-34' },
                            { 'icon': '?', 'tp': '17-17-34-17-17' },
                            { 'icon': '?', 'tp': '34-17-17-17-17' }
                        ]
                    };
                }

                if( self.options.columns + '' === '6' ) {
                    self.options.columns_defs[ clsName ] = {
                        'title': '', 'layouts': [
                            { 'icon': '?', 'tp': '17-17-17-17-17-17' }
                        ]
                    };
                }

                if( self.options.columns + '' === '7' ) {
                    self.options.columns_defs[ clsName ] = {
                        'title': '', 'layouts': [
                            { 'icon': '?', 'tp': '14-14-14-14-14-14-14' }
                        ]
                    };
                }

                if( self.options.columns + '' === '8' ) {
                    self.options.columns_defs[ clsName ] = {
                        'title': '', 'layouts': [
                            { 'icon': '?', 'tp': '12-12-12-12-12-12-12-12' }
                        ]
                    };
                }
            }

            self._super();
        },

        '.swc_panel_button_columns click': function( $el /*, ev*/ ) {
            var self = this;
            var $row = self.options.$row;
            var columns = $el.closest( 'swc_panel_button' ).attr( 'data-columns' );

            if( columns.indexOf( '-' ) < 0 && columns + '' !== '100' && parseInt( columns, 10 ) > 1 ) {
                // Open the sub panel

                this.markCloseOnFocus();
                panelStackInstance.addPanel( ThisPanel, {
                    'columns': columns,
                    '$row': $row,
                    'swc_between_cols': self.options.swc_between_cols
                } );
            } else {
                // Apply the new column layout

                if( $row === null ) {
                    // The (new) row is not yet created. Do that first.

                    var d = new Date();
                    var n = d.getTime();
                    var insertClass = 'swc_asset_state_inserting' + n;

                    var swc_between_cols = 20;
                    if( self.options.swc_between_cols ) {
                        swc_between_cols = self.options.swc_between_cols;
                    }

                    var htmlRow = '<div class="swc_grid_row ' + insertClass + '" style="margin-bottom: ' + swc_between_cols + 'px;" data-grid_data="{}">' +
                        '</div>';

                    evt( 'add_row_to_content', {
                        'html': htmlRow,
                        'insert_class': insertClass
                    } ).then( function( $newRow ) {
                        evt( 'scroll_to_element', { $el: $newRow } );

                        self.changeColumns( $newRow, columns, true );
                    } );
                } else {
                    // The row already exists. Change the columns.

                    self.changeColumns( $row, columns, false );
                }
            }
        },

        changeColumns: function( $row, columns, closegridpanels ) {
            var self = this;
            var cols = columns.split( '-' );
            var nrColsWanted = cols.length;
            var nrColsNow = $row.find( '> .swc_grid_colwrapper' ).length;
            var $lastCol = null;
            var html = '';

            // Add flex classes to all columns
            var addFlexClasses = function( state ) {
                var dataPrev = null;
                var $elPrev = null;
                $row.find( '> .swc_grid_colwrapper' ).each( function( i, el ) {
                    var $el = $( el );

                    for( var j = 1; j < 100; j++ ) {
                        $el.removeClass( 'swc_flex_' + j );
                    }
                    $el.addClass( 'swc_flex_' + cols[ i ] );

                    var $col = $( el ).find( '.swc_grid_column' );
                    var data = $.parseJSON( $col.attr( 'data-grid_data' ) );

                    data.flex = '' + cols[ i ];

                    if( state === 1 ) {
                        // Columns added

                        if( $col.hasClass( 'swc_grid_column_new' ) ) {
                            // Newly added column.
                            // Extend the missing data with the data from from the previous column (like background).
                            // And copy it's css (for background etc).
                            if( dataPrev ) {
                                data = $.extend( true, {}, dataPrev, data );
                                $el.attr( 'style', $elPrev.attr( 'style' ) );
                            }
                        }
                    }

                    $col.attr( 'data-grid_data', JSON.stringify( data ) );

                    dataPrev = $.extend( true, {}, data );
                    $elPrev = $el;
                } );

                // do_change_col_margin triggers save
                evt( 'do_change_col_margin', { '$row': $row, 'value': self.options.swc_between_cols } )

                if( closegridpanels ) {
                    evt( 'reset_panel_stack' );
                } else {
                    self.closePanel();
                }
            };

            if( nrColsWanted < nrColsNow ) {
                // Remove one or more columns and move their content to the last remaining column

                $row.find( '> .swc_grid_colwrapper' ).each( function( i, el ) {
                    var $el = $( el );

                    if( i < nrColsWanted ) {
                        $lastCol = $el;
                    } else {
                        $el.find( '.swc_grid_column' ).children().appendTo( $lastCol.find( '.swc_grid_column' ) );
                        $el.remove();
                    }
                } );

                evt( 'swifty_editor_check_widgets', {} ).then( function() {
                    addFlexClasses( 2 );
                } );
            }

            if( nrColsWanted > nrColsNow ) {
                // Add one or more columns

                html = '';
                for( var i = nrColsNow; i < nrColsWanted; i++ ) {
                    var dat = "'" + '{"flex":"' + cols[ i ] + '"}' + "'";
                    var css = '';
                    if( i < nrColsWanted - 1 ) {
                        css += ' margin-right: ' + self.options.swc_between_cols + 'px;';
                    }
                    html += '<div class="swc_grid_colwrapper" style="' + css + '"><div class="swc_grid_column swc_grid_column_new" data-grid_data=' + dat + '></div><div class="swc_grid_colclose"></div></div>';
                }

                evt( 'add_columns_to_row', {
                    'html': html,
                    '$row': $row
                } ).then( function() {
                    addFlexClasses( 1 );
                } );
            }

            if( nrColsWanted === nrColsNow ) {
                addFlexClasses( 0 );
            }
        }

    } );

    return ThisPanel;
} );

swifty.define( 'js/panels/add_content/add_content',[
    'jquery',
    'swiftylib/evt',
    'js/panels/overlay_panel/overlay_panel',
    'js/panels/panel_stack/panel_stack_instance',
    'stache!js/panels/add_content/add_content.stache',
    'js/panels/add_asset/add_asset',
    'js/panels/add_preset/add_preset',
    'js/diverse/categories',
    'swiftylib/i18n/__',
    'js/libs/mout/src/array/findIndex',
    'js/panels/pick_columns/pick_columns'
], function(
    $, evt, Panel, panelStackInstance, tmpl, AddAsset, AddPreset, categories, __, findIndex, PickColumns
) {
    

    return Panel.extend( {
        'defaults': {
            'tmpl_content': tmpl,
            'title': __( 'Add content' ),
            'in_grid': false,
            '$column': null,
            'locked': false,
            'allowance': '',
            'wrap_at_bottom': false
        }
    }, {
        init: function() {
            var self = this;

            evt( 'get_assets' ).then( function( categoryList ) {
                self.options.category_defs = [];

                //if( ! self.options.in_grid ) {
                //    // Add the button for Grid system
                //    self.options.category_defs.push( {
                //        'icon': '&#xe014;',
                //        'name': __( 'Columns' ),
                //        'action': 'grid'
                //    } );
                //}

                categoryList.each( function( category /*, i*/ ) {
                    var categoryDef = categories.getCategory( category.attr( 'name' ).toLowerCase() );

                    // For now we assume there is only 1 asset in the clipboard category and that we want to hide that
                    // category when the asset is not available.
                    if( ( category.attr( 'name' ) !== 'clipboard' ) || scc_data.is_content_clipboard_available ) {
                        if( findIndex( self.options.category_defs, categoryDef ) < 0 ) {
                            self.options.category_defs.push( categoryDef );
                        }
                    }
                } );

                //if( ! self.options.in_grid ) {
                //    // Add the button for Presets
                //    self.options.category_defs.push( {
                //        'icon': '&#xe903;',
                //        'name': __( 'Presets' ),
                //        'action': 'content_tmpl'
                //    } );
                //}

                self._super();

                $.each( self.options.category_defs, function( ii, category_def ) {
                    if( category_def.action === 'grid' ) {
                        new PickColumns(
                            $( '<div></div>' ).appendTo( '.swc_panel_category_wrapper_' + category_def.action ),
                            { '$row': null, 'swc_between_cols': 20 }
                        );
                    } else {
                        new AddAsset(
                            $( '<div></div>' ).appendTo( '.swc_panel_category_wrapper_' + category_def.action ),
                            {
                                'category': category_def.action,
                                '$column': self.options.$column,
                                'locked': self.options.locked,
                                'allowance': self.options.allowance,
                                'wrap_at_bottom': self.options.wrap_at_bottom
                            }
                        );
                    }
                } );
            } );
        }
    } );
} );
swifty.define( 'js/panels/page_setup/page_setup',[
    'jquery',
    'swiftylib/evt',
    'js/panels/add_preset/add_preset',
    'swiftylib/i18n/__'
], function(
    $, evt, PresetPanel, __
) {
    

    return PresetPanel.extend( {
        'defaults': {
            'title': __( 'New page content' ),
            'is_page_setup': true
        }
    }, {
        init: function() {
            var self = this;

            self._super();
        },

        '.swc_panel_button click': function( $el ) {
            var self = this;

            $el = $el.closest( 'swc_panel_button' );

            var presetType = $el.attr( 'data-preset_type' );

            if( presetType === 'blank_page' ) {
                self.closePanel();
                self.fill_empty_page( false );
            } else {
                self._super( $el );
            }
        },

        '.swc_back_button click': function( /*el, ev*/ ) {
            var self = this;

            self.closePanel();
            self.fill_empty_page( true );
        },

        fill_empty_page: function ( temporary ) {

            var add_temp = ( temporary ? ' swc_temporary="1" swc_margin_top="0" swc_margin_bottom="0" swc_margin_left="0"' : '' );
            var add_temp_text = ( temporary ? ' swc_temporary="1"' : '' );

            evt( 'convert_preset_html', {
                'html': '[swifty_grid_row' + add_temp + '][swifty_grid_column flex="100"' + add_temp + '][swifty_text swc_width="100"' + add_temp_text + ' swc_margin_top="0" swc_margin_bottom="0" swc_margin_left="0"]&nbsp;[/swifty_text][/swifty_grid_column][/swifty_grid_row]'
            } ).then( function( html ) {

                var dfd = new $.Deferred();
                evt(
                    'swifty_editor_set_new_content',
                    {
                        'content': html,
                        'dfd': dfd
                    }
                );
                dfd.then( function() {
                    evt( 'swifty_editor_show_tooltip' );
                } );
            } );
        }
    } );
} );

swifty.define('stache!js/panels/info/info.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/panels/info/info.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<div>\n    {{__ info_text}}<br>\n    {{__ info_text2}}\n</div>\n' ); return idn; });

swifty.define( 'js/panels/info/info',[
    'jquery',
    'js/panels/panel/panel',
    'swiftylib/i18n/__',
    'stache!./info.stache'
], function(
    $, Panel, __, tmpl
) {
    

    return Panel.extend( {
        'defaults': {
            'tmpl_content': tmpl,
            'title': __( 'Info' ),
            'info_text': '',
            'info_text2': ''
        }
    }, {
    } );
} );

swifty.define( 'swiftylib/media_manager',[
    'jquery',
    'can/../can',
    'can/control',
    './i18n/__'
], function(
    $, can, Control, __
) {
    

    return Control.extend( {
        defaults: {
            selected_ids: '',
            swifty_mode: 0,
            show_caption: 0,
            show_alt: 1,
            ssd_id: null,
            media_image_prefix: null
        },
        _idReplacingSwiftyPatternImg: 0
    }, {
        init: function() {
            var self = this;

            self._customizeMediaManager();

            wp.media.view.Modal.prototype.on( 'close', function() {
                // Send the close event to the caller after a while.
                // Without the timeout it would come before the actual image is send to the caller.
                setTimeout( function() {
                    self.options.dfd.resolve( {
                        'act': 'close'
                    } );
                }, 5000 );
            } );

            self.media_manager = wp.media( {
                'title': self.options.multiple ? __( 'Choose images' ) : __( 'Choose image' ),
                'multiple': self.options.multiple,
                'button': {
                    'text': __( 'Insert' )
                },
                'library': {
                    'type': 'image'
                }
            } );

            self.media_manager.on( 'open', function( /*ev*/ ) {
                self._startReplacingSwiftyPatternImg();
                self._mediaOpened();
            } ).on( 'escape', function( /*ev*/ ) {
                self._stopReplacingSwiftyPatternImg();
                self._mediaEscaped();
            } ).on( 'select', function( /*ev*/ ) {
                self._stopReplacingSwiftyPatternImg();
                self._mediaSelected();
            } ).open();
        },

        /**
         * Creates a list of SSD images and use it to call the given cb functions.
         *
         * @param cb
         * @param media_image_prefix
         */
        getMediaImages: function ( cb, media_image_prefix ) {

            var images =
                [
                    {
                        'file': media_image_prefix + '0001_432_typewriter-801921_1920_Pixabay_license_2016-05-03.jpg',
                        'thumb': media_image_prefix + '110x110_0000_432_typewriter-801921_1920_Pixabay_license_2016-05-03.jpg'
                    },
                    {
                        'file': media_image_prefix + '0002_431_tractor-862923_1920_Pixabay_license_2016-05-03.jpg',
                        'thumb': media_image_prefix + '110x110_0011_431_tractor-862923_1920_Pixabay_license_2016-05-03.jpg'
                    },
                    {
                        'file': media_image_prefix + '0003_430_the-ball-488714_1920_Pixabay_license_2016-05-03.jpg',
                        'thumb': media_image_prefix + '110x110_0012_430_the-ball-488714_1920_Pixabay_license_2016-05-03.jpg'
                    },
                    {
                        'file': media_image_prefix + '0004_429_startup-594091_1920_Pixabay_license_2016-05-03.jpg',
                        'thumb': media_image_prefix + '110x110_0013_429_startup-594091_1920_Pixabay_license_2016-05-03.jpg'
                    },
                    {
                        'file': media_image_prefix + '0005_428_photographer-407068_1920_Pixabay_license_2016-05-03.jpg',
                        'thumb': media_image_prefix + '110x110_0014_428_photographer-407068_1920_Pixabay_license_2016-05-03.jpg'
                    },
                    {
                        'file': media_image_prefix + '0006_427_holding-hands-918990_1920_Pixabay_license_2016-05-03.jpg',
                        'thumb': media_image_prefix + '110x110_0015_427_holding-hands-918990_1920_Pixabay_license_2016-05-03.jpg'
                    },
                    {
                        'file': media_image_prefix + '0007_426_happy-children-876541_1280_Pixabay_license_2016-05-03.jpg',
                        'thumb': media_image_prefix + '110x110_0016_426_happy-children-876541_1280_Pixabay_license_2016-05-03.jpg'
                    },
                    {
                        'file': media_image_prefix + '0008_425_girl-1308309_1920_Pixabay_license_2016-05-03.jpg',
                        'thumb': media_image_prefix + '110x110_0017_425_girl-1308309_1920_Pixabay_license_2016-05-03.jpg'
                    },
                    {
                        'file': media_image_prefix + '0009_424_apple-256263_1920_Pixabay_license_2016-05-03.jpg',
                        'thumb': media_image_prefix + '110x110_0018_424_apple-256263_1920_Pixabay_license_2016-05-03.jpg'
                    },
                    {
                        'file': media_image_prefix + '0010_419_store-984393_1920_Pixabay_license_2016-05-03.jpg',
                        'thumb': media_image_prefix + '110x110_0002_419_store-984393_1920_Pixabay_license_2016-05-03.jpg'
                    },
                    {
                        'file': media_image_prefix + '0011_417_restaurant-690569_1280_Pixabay_license_2016-05-03.jpg',
                        'thumb': media_image_prefix + '110x110_0003_417_restaurant-690569_1280_Pixabay_license_2016-05-03.jpg'
                    },
                    {
                        'file': media_image_prefix + '0012_414_painting-911804_1920_Pixabay_license_2016-05-03.jpg',
                        'thumb': media_image_prefix + '110x110_0004_414_painting-911804_1920_Pixabay_license_2016-05-03.jpg'
                    },
                    {
                        'file': media_image_prefix + '0014_409_glass-facade-817732_1920_Pixabay_license_2016-05-03.jpg',
                        'thumb': media_image_prefix + '110x110_0005_409_glass-facade-817732_1920_Pixabay_license_2016-05-03.jpg'
                    },
                    {
                        'file': media_image_prefix + '0015_408_doctor-563429_1920_Pixabay_license_2016-05-03.jpg',
                        'thumb': media_image_prefix + '110x110_0006_408_doctor-563429_1920_Pixabay_license_2016-05-03.jpg'
                    },
                    {
                        'file': media_image_prefix + '0016_406_construction-703807_1920_Pixabay_license_2016-05-03.jpg',
                        'thumb': media_image_prefix + '110x110_0007_406_construction-703807_1920_Pixabay_license_2016-05-03.jpg'
                    },
                    {
                        'file': media_image_prefix + '0017_405_construction-692171_1280_Pixabay_license_2016-05-03.jpg',
                        'thumb': media_image_prefix + '110x110_0008_405_construction-692171_1280_Pixabay_license_2016-05-03.jpg'
                    },
                    {
                        'file': media_image_prefix + '0018_404_canada-784392_1920_Pixabay_license_2016-05-03.jpg',
                        'thumb': media_image_prefix + '110x110_0009_404_canada-784392_1920_Pixabay_license_2016-05-03.jpg'
                    },
                    {
                        'file': media_image_prefix + '0019_403_audience-868074_1920_Pixabay_license_2016-05-03.jpg',
                        'thumb': media_image_prefix + '110x110_0010_403_audience-868074_1920_Pixabay_license_2016-05-03.jpg'
                    }
                ];
            cb( images );
        },

        _mediaOpened: function() {
            var self = this;

            if( self.options.hasOwnProperty( 'selected_ids' ) ) {
                var selection = self.media_manager.state().get( 'selection' );

                $.each( self.options.selected_ids.split( ',' ), function( index, id ) {
                    var attachment = wp.media.attachment( id );

                    attachment.fetch();
                    selection.add( attachment ? [ attachment ] : [] );
                } );
            }
        },

        _mediaSelected: function() {
            var self = this;
            var selection = self.media_manager.state().get( 'selection' );

            if( !selection ) {
                return;
            }


            $.when.apply( $, selection.map( function( attachment ) {
                if( self.options.hasOwnProperty( 'selected_ids' ) ) {
                    return attachment;
                }
            }, this ) ).done( function() {

                var attributes = [];

                $.each( arguments, function( index, arg ) {
                   attributes.push( arg.attributes );
                } );

                // Send the html to the caller.
                self.options.dfd.resolve( {
                    'act': 'insert',
                    'attributes': attributes
                } );
            } );
        },

        _mediaEscaped: function() {
            var self = this;
            self.options.dfd.resolve( {
                'act': 'cancel'
            } );
        },

        _startReplacingSwiftyPatternImg: function() {
            var self = this;

            self._idReplacingSwiftyPatternImg = setInterval( function() {

                var $images = $( ".media-frame-content img:not(.handled)[src*='&swtp=pattern']" );
                if( $images.length > 0 ) {

                    // remove div[centered]
                    $images.unwrap();

                    // replace img with div[background-image]
                    $images.replaceWith( function( i, v ) {
                        return $( '<div/>', {
                            style: 'background-image: url(' + this.src + '); background-repeat: repeat; background-position: center;',
                            class: 'thumbnail handled'
                        } )
                    } );
                    $images.addClass( 'handled' );
                }

                var $images = $( ".media-frame-content .thumbnail .centered img:not(.handled)" );
                if( $images.length > 0 ) {
                    $images.css( 'max-height', '100%' );
                    $images.css( 'max-width', '100%' );
                    $images.addClass( 'handled' );
                }
            }, 250 );
        },

        _stopReplacingSwiftyPatternImg: function() {
            var self = this;
            clearInterval( self._idReplacingSwiftyPatternImg );
        },

        _customizeMediaManager: function() {
            var self = this;
            var mediaManager = this;
            var wpAttachmentDisplay = wp.media.view.Settings.AttachmentDisplay;
            var wpAttachmentDetails = wp.media.view.Attachment.Details;
            var wpAttachmentCompat = wp.media.view.AttachmentCompat;
            var wpAttachmentsBrowser = wp.media.view.AttachmentsBrowser;
            var wpMediaFrameSelect = wp.media.view.MediaFrame.Select;

            // change the collection of attachments:
            // - read directly from stuff server
            // - get all in one go
            // - build attachment model for them
            // - only support reading, skip: update, delete, create
            var SwiftyAttachments = wp.media.model.Query.extend( {
                sync: function( method, model, options ) {

                    var self = this;
                    var args = self.args || {};

                    var addImage = function( file, url, thumb, args ) {
                        self.add( {
                            'id': file,
                            'title': 'test',
                            'url': url,
                            'link': file,
                            'mime': 'image/jpeg',
                            'type': 'image',
                            'subtype': 'jpeg',
                            'sizes': {
                                'full': {
                                    'url': thumb
                                }
                            },
                            'nonces': {
                                'update': false,
                                'delete': false,
                                'edit': false
                            },
                            'editLink': false,
                            'meta': false,
                            'swifty_cmd': args.cmd,
                            'swifty_tp': args.tp,
                            'swifty_params': args.params
                        } );
                    };

                    if ( 'read' === method ) {

                        // Only use this when ssd has provided us with the proper uri to load them.
                        if( mediaManager.options.media_image_prefix && ( args.cmd === 'img_list' ) ) {
                            mediaManager.getMediaImages( function( images ) {
                                $.each( images, function( ii, img ) {
                                        addImage( img.file, img.file, img.thumb, args );
                                    } );
                                },
                                mediaManager.options.media_image_prefix );
                        }

                        $.ajax( {
                            url: 'https://stuff.swifty.online/stuff/data/get.php',
                            type: 'POST',
                            data: {
                                'do': args.cmd,
                                'tp': args.tp
                            },
                            dataType: 'json',
                            xhrFields: {
                                withCredentials: true
                            }
                        } ).then( function( data ) {
                            $.each( data.result, function( ii, img ) {
                                addImage( img.file, img.file + (args.tp ? '&ssd_tp=' + args.tp : ''), img.file + args.params, args );
                            } );
                        } );
                    }
                    return jQuery.Deferred().resolveWith( this ).promise();
                },

                more: function( options ) {

                    var self = this;

                    if ( ! this.hasMore() ) {
                        return jQuery.Deferred().resolveWith( this ).promise();
                    }

                    options = options || {};
                    options.remove = false;

                    // fetch all at once, so we can stop right after this
                    this._hasmore = false;
                    return this._more = this.fetch( options ).done( function() {
                        self._hasMore = false;
                    });
                }
            } );

            // We need to lower the attachments browser, so we have space for the 'CTRL + Click' text.
            wp.media.view.AttachmentsBrowser = wpAttachmentsBrowser.extend( {
                initialize: function() {
                    wpAttachmentsBrowser.prototype.initialize.apply( this, arguments );

                    if( self.options.multiple ) {
                        this.$el.find( 'ul' ).css( 'top', '80px' );
                    }
                }
            } );

            // our own tabs can not upload content, so we replace this view with our own
            wp.media.view.AttachmentsBrowserSwifty = wp.media.view.AttachmentsBrowser.extend( {
                initialize: function() {
                    wp.media.view.AttachmentsBrowser.prototype.initialize.apply( this, arguments );
                },

                // our own uploader view, will be shown as long as the script is retrieving the images
                createUploader: function() {

                    this.uploader = new wp.media.View({
                        controller: this.controller,
                        tagName: 'p'
                    });

                    this.uploader.$el.addClass( 'hidden no-media' );
                    this.uploader.$el.html( __( 'One moment...' ) );

                    this.views.add( this.uploader );
                }
            } );

            wp.media.view.MediaFrame.Select = wpMediaFrameSelect.extend( {

                // we will extend this frame with new tabs by adding controllers etc
                initialize: function() {
                    // Call 'initialize' directly on the parent class.
                    wpMediaFrameSelect.prototype.initialize.apply( this, arguments );

                    // check of the last used router is available, if not we will change it to 'browse'
                    var mode = window.getUserSetting( 'libraryContent', 'browse' );
                    var org_mode = mode;

                    // add our own tabs to the normal browse route
                    if( self.options.swifty_mode === 1 ) {
                        this.on( 'router:render:browse', this.browseRouter2, this );
                        this.on( 'content:create:header_images', this.browseContent_swifty_header_images, this );
                        mode = 'browse';
                    } else {
                        if( mode === 'header_images' ) {
                            mode = 'browse';
                        }
                    }
                    if( self.options.swifty_mode === 2 ) {
                        this.on( 'router:render:browse', this.browseRouter3, this );
                        this.on( 'content:create:header_patterns', this.browseContent_swifty_header_patterns, this );
                        this.on( 'content:create:header_stripe_patterns', this.browseContent_swifty_header_stripe_patterns, this );
                        this.on( 'content:create:header_shape_patterns', this.browseContent_swifty_header_shape_patterns, this );
                        if(( mode !== 'header_patterns' ) && ( mode !== 'header_stripe_patterns' )  && ( mode !== 'header_shape_patterns' )) {
                            mode = 'header_patterns';
                        }
                    } else {
                        if( (mode === 'header_patterns') || (mode === 'header_stripe_patterns') || (mode === 'header_shape_patterns') ) {
                            mode = 'browse';
                        }
                    }

                    // remove non used tabs
                    if( self.options.swifty_mode !== 1 ) {
                        this.off( 'router:render:browse', this.browseRouter2, this );
                        this.off( 'content:create:header_images', this.browseContent_swifty_header_images, this );
                    }
                    if( self.options.swifty_mode !== 2 ) {
                        this.off( 'router:render:browse', this.browseRouter3, this );
                        this.off( 'content:create:header_patterns', this.browseContent_swifty_header_patterns, this );
                        this.off( 'content:create:header_stripe_patterns', this.browseContent_swifty_header_stripe_patterns, this );
                        this.off( 'content:create:header_shape_patterns', this.browseContent_swifty_header_shape_patterns, this );
                    }

                    if( org_mode !== mode ) {
                        window.setUserSetting( 'libraryContent', mode );
                    }
                },

                browseRouter2: function( routerView ) {
                    routerView.set( {
                        'header_images': {
                            'text': __( 'Swifty Images' ),
                            'priority': 40
                        }
                    } );
                },

                browseRouter3: function( routerView ) {
                    routerView.set( {
                        'header_patterns': {
                            'text': __( 'Swifty Patterns' ),
                            'priority': 50
                        }
                    } );

                    routerView.set( {
                        'header_stripe_patterns': {
                            'text': __( 'Swifty Stripe Patterns' ),
                            'priority': 50
                        }
                    } );

                    routerView.set( {
                        'header_shape_patterns': {
                            'text': __( 'Swifty Shape Patterns' ),
                            'priority': 50
                        }
                    } );
                },

                /**
                 * Render callback for the content region in the `browse` mode.
                 *
                 * @param {wp.media.controller.Region} contentRegion
                 */
                browseContent_swifty_header_images: function( contentRegion ) {

                    var args = {
                        cmd: 'img_list',
                        tp: '',
                        params: '&ssw=186'
                    };
                    this.browseContent_swifty( contentRegion, 'swifty_header_images', args );
                },

                browseContent_swifty_header_patterns: function( contentRegion ) {
                    var args = {
                        cmd: 'pattern_list',
                        tp: 'img',
                        params: ''
                    };
                    this.browseContent_swifty( contentRegion, 'swifty_header_patterns', args );
                },

                browseContent_swifty_header_stripe_patterns: function( contentRegion ) {
                    var args = {
                        cmd: 'pattern_list',
                        tp: 'stripe',
                        params: '&ssc1=FFFFFF&ssc2=000000'
                    };
                    this.browseContent_swifty( contentRegion, 'swifty_header_stripe_patterns', args );
                },

                browseContent_swifty_header_shape_patterns: function( contentRegion ) {
                    var args = {
                        cmd: 'pattern_list',
                        tp: 'shape',
                        params: '&ssc1=FFFFFF&ssc2=000000'
                    };
                    this.browseContent_swifty( contentRegion, 'swifty_header_shape_patterns', args );
                },

                browseContent_swifty: function( contentRegion, collectionName, args ) {
                    var state = this.state();

                    if( !state.get( collectionName ) ) {
                        state.set( collectionName,
                            new SwiftyAttachments( null,
                                {
                                    props: { query: true },
                                    args: args
                                }
                            )
                        );
                    }

                    this.$el.removeClass( 'hide-toolbar' );

                    $( '.media-frame-content' ).html( __( 'One moment...' ) );

                    // Browse our library of attachments.
                    contentRegion.view = new wp.media.view.AttachmentsBrowserSwifty( {
                        controller: this,
                        collection: state.get( collectionName ),
                        selection: state.get( 'selection' ),
                        model: state,
                        sortable: false,
                        search: false,
                        filters: false,
                        sidebar: false,
                        date: false,
                        display: state.has( 'display' ) ? state.get( 'display' ) : state.get( 'displaySettings' ),
                        dragInfo: state.get( 'dragInfo' ),

                        idealColumnWidth: state.get( 'idealColumnWidth' ),
                        suggestedWidth: state.get( 'suggestedWidth' ),
                        suggestedHeight: state.get( 'suggestedHeight' ),

                        AttachmentView: state.get( 'AttachmentView' )
                    } );
                }

            } );

            // Hides the Image Details pane.
            wp.media.view.Settings.AttachmentDisplay = wpAttachmentDisplay.extend( {
                initialize: function() {
                    wpAttachmentDisplay.prototype.initialize.apply( this, arguments );

                    this.$el.hide();
                }
            } );

            // Hide the 'Edit Image' link and other settings, except ALT and CAPTION-text.
            wp.media.view.Attachment.Details = wpAttachmentDetails.extend( {
                render: function() {
                    wpAttachmentDetails.prototype.render.apply( this, arguments );

                    this.$el.find( '.edit-attachment' ).hide();
                    this.$el.find( '.setting' ).hide();
                    if( self.options.show_caption ) {
                        this.$el.find( '.setting[data-setting="caption"]' ).show();
                    }
                    if( self.options.show_alt ) {
                        this.$el.find( '.setting[data-setting="alt"]' ).show();
                    }
                    this.$el.find( '.button-link.delete-attachment' ).html(
                        __( 'Permanently remove this image here and from all pages.' )
                    );
                    this.$el.find( '.button-link.delete-attachment' ).css( {
                            'white-space': 'normal',
                            'text-align': 'left',
                            'text-decoration': 'underline',
                            'margin-top': '50px',
                            'color': 'black'
                        }
                    );
                    // move delete link below the details
                    this.$el.find( '.button-link.delete-attachment' ).appendTo( this.$el );

                }
            } );

            // Hide the view that displays fields added via the `attachment_fields_to_edit` filter.
            wp.media.view.AttachmentCompat = wpAttachmentCompat.extend( {
                render: function() {
                    wpAttachmentCompat.prototype.render.apply( this, arguments );

                    this.$el.hide();
                }
            } );

            // Sets the Media selection dropdown default to images.
            // Hide the Media selection dropdown.
            wp.media.view.Toolbar.prototype.on( 'ready', function() {
                var $mediaToolbar = $( '.' + this.className ).filter( function( /*index*/ ) {
                    return $( this ).parent().hasClass( 'attachments-browser' );
                } );
                var $toolbarSecondary = $mediaToolbar.find( '.media-toolbar-secondary' );

                $toolbarSecondary.find( 'select:last' ).css( 'max-width', '100%' );
            } );
        },

        destroy: function() {
            this.media_manager = null;
            this._super();
        }
    } );
} );
swifty.define( 'assets/image_viewer/image_viewer_edit',[
    'jquery',
    'js/panels/edit_asset/edit_asset',
    'swiftylib/media_manager'
], function(
    $, EditPanel, MediaManager
) {
    

    return EditPanel.extend( {
        'defaults': {
            'show_caption': false,
            'show_alt': false
        }
    }, {
        '.swc_select_images click': function() {
            var self = this;
            var $newEl = $( '<div></div>' ).appendTo( this.element );
            var dfd = new $.Deferred();

            new MediaManager( $newEl, {
                'selected_ids': self.options.asset_data.attr( 'selected_ids' ),
                'multiple': 'add',
                'show_caption': self.options.show_caption,
                'show_alt': self.options.show_alt,
                'dfd': dfd,
                'swifty_mode': ( ( ( scc_data.ss2_hosting_name === 'AMH' ) && ( self.options.asset_data.attr( 'swc_swifty_on' ) === '1' ) ) ? 1 : 0 ),
                'media_image_prefix': scc_data.media_image_prefix
            } );

            dfd.then( function( data ) {
                if( data && data.act === 'insert' ) {
                    if( $.isArray( data.attributes ) && data.attributes.length ) {
                        var selectedIds = [];

                        var swifty_attachments = [];

                        // when swifty_cmd==='img_list' then import as attachment
                        $.each( data.attributes, function( index, image ) {
                            if( image.swifty_cmd === 'img_list' ) {
                                swifty_attachments.push( image.url );
                            }
                        } );

                        // there are attachments needed to be imported, do this first
                        if( swifty_attachments.length ) {

                            // show feedback spinner
                            $( '#swc-spinner' ).show();
                            $( '#swc-screen-cover' ).show();

                            $.post(
                                scc_data.ajax_url,
                                {
                                    'action': 'insert_attachment_from_url',
                                    'urls': JSON.stringify( swifty_attachments ),
                                    'id': scc_data.page_id,
                                    'ajax_nonce': scc_data.ajax_nonce
                                }
                            ).done( function( attachments_data ) {

                                    $.each( data.attributes, function( index, image ) {
                                        if( image.swifty_cmd === 'img_list' ) {
                                            $.each( attachments_data, function( index, attachment ) {
                                                if( attachment.image_url === image.url ) {
                                                    selectedIds.push( attachment.id );
                                                }
                                            } );
                                        } else {
                                            selectedIds.push( image.id );
                                        }
                                    } );

                                    self.options.asset_data.attr( {
                                        'selected_ids': selectedIds.join( ',' )   // Must be a string.
                                    } );

                                    // Make sure a reload is done. Needed when only the catpion or tag is updated.
                                    self.options.asset_instance.reloadFromServer();
                                }
                            ).always( function() {
                                    // hide feedback spinner
                                    $( '#swc-spinner' ).hide();
                                    $( '#swc-screen-cover' ).hide();
                                }
                            );
                        } else {
                            // no need to import attachments, just continue
                            $.each( data.attributes, function( index, image ) {
                                selectedIds.push( image.id );
                            } );

                            self.options.asset_data.attr( {
                                'selected_ids': selectedIds.join( ',' )   // Must be a string.
                            } );

                            // Make sure a reload is done. Needed when only the catpion or tag is updated.
                            self.options.asset_instance.reloadFromServer();
                        }
                    }
                }

                $newEl.remove();   // Destroy the MediaManager
            } );
        }
    } );
} );
swifty.define( 'assets/image_viewer/image_viewer',[
    'jquery',
    'swiftylib/evt',
    'js/diverse/asset',
    './image_viewer_edit'
], function(
    $, evt, Asset, EditPanel
) {
    

    return Asset.extend( {
        'defaults': {
            'asset_name': 'image_viewer',
            'class_edit': EditPanel
        }
    }, {
        processServerInfo: function( /*info*/ ) {
            this._super();

            // Execute functions on each insertion / change.
            if(  this.options.onchange ) {

                $.each( this.options.onchange, function( i, value ) {
                    if( value === 'updateslideshow' ) {
                        evt( 'add_exec', { 'evt': 'update_slideshows' } );
                    } else if( value === 'updateslider' ) {
                        evt( 'add_exec', { 'evt': 'update_sliders' } );
                    } else if( value === 'updategallerygrid' ) {
                        evt( 'add_exec', { 'evt': 'update_gallery_grid' } );
                    } else if( value === 'updategallerygrid' ) {
                        evt( 'add_exec', { 'evt': 'update_gallery_grid' } );
                    } else if( value === 'updategalleryflex' ) {
                        evt( 'add_exec', { 'evt': 'update_gallery_flex' } );
                    }
                } );
            }
        }
    } );
} );
swifty.define( 'assets/video/video_edit',[
    'jquery',
    'js/panels/edit_asset/edit_asset'
], function(
    $, EditPanel
) {
    

    return EditPanel.extend( {
    }, {
        init: function() {
            var self = this;

            self.options.info_data = self.options.asset_instance.getAssetInfoData();

            self._super();
        }
    } );

} );
swifty.define( 'assets/video/video',[
    'jquery',
    'swiftylib/evt',
    'js/diverse/asset',
    './video_edit',
    'swiftylib/map'
], function(
    $, evt, Asset, EditPanel, Map
) {
    

    return Asset.extend( {
        'defaults': {
            'asset_name': 'video',
            'class_edit': EditPanel
        }
    }, {
        init: function() {
            var self = this;
            var mode = 1;
            var assetData;

            self.options.info_data = new Map();
            self._super();

            assetData = self.options.asset_data;

            if( parseInt( assetData.attr( 'o_width' ), 10 ) > 0 &&
                parseInt( assetData.attr( 'o_height' ), 10 ) > 0
            ) {
                mode = 0;
            }

            self.getInfoFromYoutube( mode );
        },

        '{asset_data} change': function( huh, ev, attr, how, newVal, oldVal ) {
            var self = this;
            var assetData = self.options.asset_data;
            var res;

            if( attr === 'url' ) {
                var obj = {
                    'is_youtube': false,
                    'video_id': '',
                    'o_width': '',
                    'o_height': ''
                };

                if( newVal.indexOf( 'youtu' ) >= 0 ) {
                    obj.is_youtube = true;

                    if( newVal.indexOf( 'youtube' ) >= 0 ) {
                        res = newVal.match( /v=([^&]+)/i );

                        if( res && res.length > 1 && res[1] !== '' ) {
                            obj.video_id = res[1];
                        } else {
                            res = newVal.match( /\/v\/([^&]+)/i );

                            if( res && res.length > 1 && res[1] !== '' ) {
                                obj.video_id = res[1];
                            }
                        }
                    } else if( newVal.indexOf( 'youtu.be' ) >= 0 ) {
                        res = newVal.split( '/' );

                        if( res && res.length > 0 && res[res.length - 1] !== '' ) {
                            obj.video_id = res[res.length - 1];
                        }
                    }
                }

                assetData.attr( obj );

                this.getInfoFromYoutube( 1 );
            }

            self._super( huh, ev, attr, how, newVal, oldVal );
        },

        getInfoFromYoutube: function( mode ) {
            var self = this;
            var assetData = self.options.asset_data;

            var protocol = window.location.protocol;
            var queryStr = 'select * from json where url ="' + protocol + '//www.youtube.com/oembed?url=' + protocol + '//www.youtube.com/watch?v=';

            self.options.info_data.attr( {
                'typ': '',
                'title': '',
                'author': '',
                'author_url': ''
            } );

            $.ajax( {
                'url': protocol + '//query.yahooapis.com/v1/public/yql',
                'data': {
                    'q': queryStr + assetData.attr( 'video_id' ) + '&format=json"',
                    'format': 'json'
                },
                'dataType': 'jsonp',
                'success': function( data ) {
                    if( typeof data === 'object' ) {
                        if( typeof data.query === 'object' ) {
                            if( data.query.results && typeof data.query.results === 'object' ) {
                                var json = data.query.results.json;

                                if( typeof json === 'object' ) {
                                    var obj = {};

                                    if( mode === 1 ) {
                                        if( parseInt( json.width, 10 ) > 0 ) {
                                            obj.o_width = parseInt( json.width, 10 );
                                        }

                                        if( parseInt( json.height, 10 ) > 0 ) {
                                            obj.o_height = parseInt( json.height, 10 );
                                        }

                                        assetData.attr( obj );
                                    }

                                    self.options.info_data.attr( {
                                        'typ': json.provider_name,
                                        'title': json.title,
                                        'author': json.author_name,
                                        'author_url': json.author_url
                                    } );
                                }
                            }
                        }
                    }

                },
                error: function( /*result*/ ) {
                }
            } );
        },

        getAssetInfoData: function() {
            return this.options.info_data;
        }
    } );
} );
swifty.define( 'assets/contact_form/contact_form',[
    'jquery',
    'js/diverse/asset',
    'js/panels/edit_asset/edit_asset'
], function(
    $, Asset, EditPanel
) {
    

    return Asset.extend( {
        'defaults': {
            'asset_name': 'contact_form',
            'class_edit': EditPanel
        }
    }, {
        // trigger the change for the asset data
        init: function() {
            var self = this;
            var assetData;

            self._super();

            assetData = self.options.asset_data;
            if( assetData.attr( 'form_id' ) === '-2' ) {

                // this will trigger single render of asset, which is needed to get the id
                // without it the whole page is rendered but the return value with the form id is not saved into the
                // asset data. For this the render of only the asset is needed

                assetData.attr( {
                    'form_id': -1
                } );
            }
        }
    } );
} );
swifty.define( 'assets/image/image_edit',[
   'jquery',
   'js/panels/edit_asset/edit_asset',
   'swiftylib/media_manager'
], function(
   $, EditPanel, MediaManager
) {
    

    return EditPanel.extend( {
    }, {
        '.swc_select_image click': function() {
            this.select_image();
        },

        select_image: function() {
            var self = this;
            var $newEl = $( '<div></div>' ).appendTo( this.element );
            var dfd = new $.Deferred();

            $.post(
                scc_data.ajax_url,
                {
                    'action': 'get_attachment_id_from_url',
                    'url': self.options.asset_data.attr( 'url' ),
                    'id': scc_data.page_id,
                    'ajax_nonce': scc_data.ajax_nonce
                }
            ).done( function( attachmentId ) {
                new MediaManager( $newEl, {
                    'selected_ids': attachmentId || '',
                    'multiple': false,
                    'dfd': dfd,
                    'show_caption': true,
                    'show_alt': true,
                    'swifty_mode': ( ( ( scc_data.ss2_hosting_name === 'AMH' ) && ( self.options.asset_data.attr( 'swc_swifty_on' ) === '1' ) ) ? 1 : 0 ),
                    'media_image_prefix': scc_data.media_image_prefix
                } );

                dfd.then( function( data ) {
                    if( data && data.act === 'insert' ) {
                        if( $.isArray( data.attributes ) && data.attributes.length ) {
                            //var imageSize = '';
                            //
                            //if( data.attributes[ 0 ].width && data.attributes[ 0 ].height ) {
                            //    imageSize = data.attributes[ 0 ].width + ' x ' + data.attributes[ 0 ].height + ' px';
                            //}

                            var swifty_attachments = [];

                            // when swifty_cmd==='img_list' then import as attachment
                            $.each( data.attributes, function( index, image ) {
                                if( image.swifty_cmd === 'img_list' ) {
                                    swifty_attachments.push( image.url );
                                }
                            } );

                            if( swifty_attachments.length ) {
                                // show feedback spinner
                                $( '#swc-spinner' ).show();
                                $( '#swc-screen-cover' ).show();

                                $.post(
                                    scc_data.ajax_url,
                                    {
                                        'action': 'insert_attachment_from_url',
                                        'urls': JSON.stringify( swifty_attachments ),
                                        'id': scc_data.page_id,
                                        'ajax_nonce': scc_data.ajax_nonce
                                    }
                                ).done( function( attachments ) {
                                        if( attachments && ( attachments.length > 0 )) {
                                            self.options.asset_data.attr( {
                                                'url': attachments[0].url,
                                                'alt': attachments[0].alt,
                                                'caption': attachments[0].caption
                                            } );
                                        }
                                    }
                                ).always( function() {
                                        // hide feedback spinner
                                        $( '#swc-spinner' ).hide();
                                        $( '#swc-screen-cover' ).hide();
                                    }
                                );
                            } else {
                                self.options.asset_data.attr( {
                                    'url': data.attributes[ 0 ].url,
                                    'alt': data.attributes[ 0 ].alt,
                                    'caption': data.attributes[ 0 ].caption
                                    //                            'file_name': data.attributes[ 0 ].filename,
                                    //                            'file_size': data.attributes[ 0 ].filesizeHumanReadable,
                                    //                            'image_size': imageSize,
                                    //                            'date': data.attributes[ 0 ].dateFormatted
                                } );
                            }
                        }
                    } else if( data && data.act === 'cancel' ) {
                        // delete when a newly inserted image cancels the image selection
                        if( self.options.mode && ( self.options.mode === 'added_new' ) ) {
                            self.options.asset_instance.deleteAsset();
                            self.closePanel();
                        }
                    }

                    $newEl.remove();   // Destroy the MediaManager
                } );
            } );
        },

        on_load_edit_stache: function() {
            // override to perform actions afters loading the edit stache from the server
            if( this.options.asset_data.attr( 'url' ) === '' ) {
                this.select_image();
            }
        }
    } );
} );
swifty.define( 'assets/image/image',[
    'jquery',
    'swiftylib/evt',
    'js/diverse/asset',
    './image_edit'
], function(
    $, evt, Asset, EditPanel
) {
    

    return Asset.extend( {
        'defaults': {
            'asset_name': 'image',
            'class_edit': EditPanel,
            'onchange': ['checkimages']
        }
    }, {
        processServerInfo: function( /*data*/ ) {
            this._super();

            if( this.options.asset_data.attr( 'url' ) ) {
                this.element.find( 'img' ).css( { 'vertical-align': 'bottom' } );
            }
        }
    } );
} );
swifty.define( 'js/diverse/page',[
    'jquery',
    'swiftylib/evt',
    'swiftylib/map',
    'swiftylib/list',
    'swiftylib/sort',
    'js/diverse/asset',
    'js/panels/panel_stack/panel_stack_instance',
    'js/panels/add_content/add_content',
    'js/panels/page_setup/page_setup',
    'js/panels/info/info',
    'swiftylib/control',
    'js/libs/mout/src/function/throttle',
    'js/diverse/utils',
    'swiftylib/i18n/__',
    'swiftylib/deferreds',
    // Assets
    'assets/image_viewer/image_viewer',
    'assets/video/video',
    'assets/contact_form/contact_form',
    'assets/image/image'
], function(
    $, evt, Map, List, Sort, Asset, panelStackInstance, AddContentPanel, PageSetupPanel, InfoPanel, Control, throttle, Utils, __,
    NewDfds,
    // Assets
    ImageViewer, Video, ContactForm, Image
) {
    

    var _categories = ',textual,clipboard,visuals,layout,interactive,others,presets,thirdparty,';
    var categoryList = new List();

    categoryList.attr( 'comparator', 'cat_order' );

    var map = new Map( {
        'published_content': null,
        'initial_content': null,
        'is_published_same': true,
        'is_style_changed': false,
        'publish_title': __( 'Publish' ),
        'show_button_publish': true,
        'is_saving': false,
        'area_has_been_edited': false,
        'show_button_manage_versions': false,
        'show_button_notifications': true,
        'show_button_page_options': true,
        'show_button_swifty': false,
        'images_sizes_to_be_determined': []
    } );

    return Control.extend( { }, {
        init: function() {
            var self = this;

            if( ! self.isEditingMain() ) {
                self.getMap().attr( 'publish_title', __( 'Publish' ) + ' ' + scc_data.area );
                self.getMap().attr( 'show_button_publish', false );
                self.getMap().attr( 'show_button_manage_versions', false );
                self.getMap().attr( 'show_button_notifications', false );
                self.getMap().attr( 'show_button_page_options', false );
            }

            if( scc_data.ss2_hosting_name === 'AMH' ) {
                self.getMap().attr( 'show_button_notifications', false );
            }

            self.registerComingSoonAssets();

            self.registerAssets( scc_data.asset_list );

            self.registerAsset( {
                'shortcode': 'paste_content',
                'name': __( 'Paste' ),
                'category': 'clipboard',
                'icon': 'fa-paste'
            }, 1 );

            self.registerAsset( {
                'shortcode': 'add_shortcode',
                'name': __( 'Shortcode' ),
                'category': 'thirdparty',
                'icon': 'fa-edit'
            }, 1 );

            // Register all available assets that have their own class
            self.registerAsset( {
                'asset_class': Video,
                'trigger_view_fn': true,
                'shortcode': 'swifty_video'
            }, 1 );

            self.registerAsset( {
                'asset_class': ContactForm,
                'shortcode': 'swifty_contact_form'
            }, 1 );

            self.registerAsset( {
                'asset_class': Image,
                'shortcode': 'swifty_image'
            }, 1 );

            self.loadPublishedModel();

            self._super();

            self.savePageThrottledObject = throttle( $.proxy( self.savePage, self ), 5000 );

            self.addAutosaveFunctionality();

            self.on();
        },

        // will get the post content when the post is public, otherwise it will get '_-NOT-PublisheD-_'
        // result is set in self.getMap().attr( 'published_content'
        loadPublishedModel: function() {
            var self = this;

            $.post(
                scc_data.ajax_url, {
                    'action': 'swcreator_get_published_data',
                    'ajax_nonce': scc_data.ajax_nonce,
                    'id': scc_data.page_id
                }
            ).then( function( data ) {
                if( data ) {
                    // force line ending when comparing for changes
                    data = data.replace( /\r\n/g, '\n' );
                }
                self.getMap().attr( 'published_content', data );
                self.checkPubStatus( null, false );

                // page has loaded, now change the wrapper heights (if needed)
                evt( 'swifty_editor_set_wrappers_height' );
            } );
        },

        registerSwiftyEditorAssets: function( assetList ) {
            var self = this;

            $.each( assetList, function( index, assetDef ) {
                self.registerSwiftyEditorAsset( assetDef );
            } );
        },

        registerSwiftyEditorAsset: function( register ) {
            var self = this;
            var isCKE = 1;
            var newAsset = self.getAssetFromCategories( register, isCKE );

            if( register.name ) {
                newAsset.attr( 'name', register.name );
            }

            if( !newAsset.attr( 'name' ) ) {
                newAsset.attr( 'name', register.action );
            }

            if( register.category ) {
                newAsset.attr( 'category', register.category );
            }

            if( register.icon ) {
                newAsset.attr( 'icon', register.icon );
            }

            if( !newAsset.attr( 'icon' ) ) {
                newAsset.attr( 'icon', '???' );
            }

            if( register.coming ) {
                newAsset.attr( 'coming', register.coming );
            }

            if( register.order ) {
                newAsset.attr( 'order', parseInt( register.order, 10 ) );
            }

            if( !newAsset.attr( 'order' ) ) {
                newAsset.attr( 'order', 9999 );
            }
        },

        registerComingSoonAssets: function() {
            var self = this;

            // swifty-content-visuals-pack

            self.registerAsset( {
                'shortcode': 'swifty_gallery_flex',
                'name': __( 'Flex Gallery' ),
                'category': 'visuals',
                'icon': '&#xe929;',
                'coming': 'scvp'
            }, 1 );

            self.registerAsset( {
                'shortcode': 'swifty_gallery_grid',
                'name': __( 'Grid Gallery' ),
                'category': 'visuals',
                'icon': '&#xe92a;',
                'coming': 'scvp'
            }, 1 );

            self.registerAsset( {
                'shortcode': 'swifty_slider',
                'name': __( 'Slider' ),
                'category': 'visuals',
                'icon': '&#xe012;',
                'coming': 'scvp'
            }, 1 );

            self.registerAsset( {
                'shortcode': 'swifty_slideshow',
                'name': __( 'Slideshow' ),
                'category': 'visuals',
                'icon': '&#xe01c;',
                'coming': 'scvp'
            }, 1 );

            // swifty-content-goodies-pack

            self.registerAsset( {
                'shortcode': 'swifty_box',
                'name': __( 'Box' ),
                'category': 'layout',
                'icon': '&#xe050;',
                'coming': 'scgp'
            }, 1 );

            self.registerAsset( {
                'shortcode': 'swifty_maps',
                'name': __( 'Map' ),
                'category': 'interactive',
                'icon': '&#xe043;',
                'coming': 'scgp'
            }, 1 );

            self.registerAsset( {
                'shortcode': 'swifty_search_box',
                'name': __( 'Search box' ),
                'category': 'interactive',
                'icon': '&#xe01e;',
                'coming': 'scgp'
            }, 1 );

            self.registerAsset( {
                'shortcode': 'swifty_sitemap',
                'name': __( 'Sitemap' ),
                'category': 'others',
                'icon': '&#xe01d;',
                'coming': 'scgp'
            }, 1 );
        },

        registerAssets: function( assetList ) {
            var self = this;

            $.each( assetList, function( shortcode, asset ) {
                self.registerAsset( {
                    'name': asset.name,
                    'category': asset.category,
                    'icon': asset.icon,
                    'shortcode': shortcode,
                    'order': asset.order,
                    'width': asset.width,
                    'type': asset.type,
                    'paid': asset.paid,
                    'expired': asset.expired,
                    'coming': asset.coming,
                    'onchange': ( ( asset.onchange ) ? asset.onchange.split( ',' ) : null ),
                    'force_close_tag': asset.force_close_tag
                }, 0 );
            } );
        },

        registerAsset: function( register, prio ) {
            var self = this;
            var isCKE = 0;
            var newAsset = self.getAssetFromCategories( register, isCKE );

            if( typeof newAsset.attr( 'class' ) === 'undefined' || prio === 1 ) {
                if( register.asset_class ) {
                    newAsset.attr( 'class', register.asset_class );
                } else {
                    newAsset.attr( 'class', Asset );
                }
            }

            if( register.name ) {
                newAsset.attr( 'name', register.name );
            }

            if( ! newAsset.attr( 'name' ) ) {
                var name = register.shortcode;

                if( name.indexOf( 'swcreator_' ) === 0 ) {
                    name = name.substr( 'swcreator_'.length );
                }

                if( name.indexOf( 'swifty_' ) === 0 ) {
                    name = name.substr( 'swifty_'.length );
                }

                name = ( name.charAt( 0 ).toUpperCase() + name.slice( 1 ) ).replace( '_', ' ' );
                newAsset.attr( 'name', name );
            }

            if( register.category ) {
                newAsset.attr( 'category', register.category );
            }

            if( register.icon ) {
                newAsset.attr( 'icon', register.icon );
            }

            if( ! newAsset.attr( 'icon' ) ) {
                newAsset.attr( 'icon', '???' );
            }

            if( register.order ) {
                newAsset.attr( 'order', parseInt( register.order, 10 ) );
            }

            if( ! newAsset.attr( 'order' ) ) {
                newAsset.attr( 'order', 9999 );
            }

            if( register.width ) {
                newAsset.attr( 'width', parseInt( register.width, 10 ) );
            }

            if( ! newAsset.attr( 'width' ) ) {
                newAsset.attr( 'width', 50 );
            }

            if( register.type ) {
                newAsset.attr( 'type', register.type );
            }

            if( ! newAsset.attr( 'type' ) ) {
                newAsset.attr( 'type', 'inline' );
            }

            if( register.trigger_view_fn ) {
                newAsset.attr( 'view', register.trigger_view_fn );
            }

            if( register.paid ) {
                newAsset.attr( 'paid', register.paid );
                newAsset.attr( 'coming', null );
            } else {
                if( register.coming ) {
                    newAsset.attr( 'coming', register.coming );
                }
            }

            if( register.expired && ( scc_data.ss2_hosting_name === '' ) ) {
                newAsset.attr( 'expired', register.expired );
                newAsset.attr( 'paid', null );
                newAsset.attr( 'coming', null );
            }

            if( register.onchange ) {
                newAsset.attr( 'onchange', register.onchange );
            }

            if( register.force_close_tag ) {
                newAsset.attr( 'force_close_tag', register.force_close_tag );
            }
        },

        getCategoryFromList: function( category ) {
            var categories = categoryList.filter( function( cat /*, i, list*/ ) {
                return cat.attr( 'name' ) === category;
            } );

            return ( categories.length === 1 ) ? categories.attr( 0 ) : null;
        },

        getAssetFromCategories: function( register, isCKE ) {
            var self = this;
            var prop = isCKE ? 'action' : 'shortcode';
            var assetFound;
            var categoryFound;

            if( register.category ) {
                categoryFound = self.getCategoryFromList( register.category );

                if( ! categoryFound ) {
                    categoryList.push( {
                        'name': register.category,
                        'assets': new List(),
                        'cat_order': _categories.indexOf( ',' + register.category + ',' )
                    } );
                }
            }

            categoryList.each( function( cat /*, i*/ ) {
                if( assetFound ) {
                    return false;
                }

                cat.attr( 'assets' ).each( function( asset /*, j*/ ) {
                    if( asset.attr( prop ) === register[ prop ] ) {
                        assetFound = asset;
                        return false;
                    }
                } );
            } );

            if( ! assetFound ) {
                assetFound = new Map();
                assetFound.attr( prop, register[ prop ] );

                if( register.category ) {
                    categoryFound = self.getCategoryFromList( register.category );
                    categoryFound.attr( 'assets' ).push( assetFound );
                }
            }

            return assetFound;
        },

        getAssetDefOfType: function( typ ) {
            var ret = Asset;

            categoryList.each( function( cat /*, i*/ ) {
                cat.attr( 'assets' ).each( function( asset /*, j*/ ) {
                    var shortcode = asset.attr( 'shortcode' );

                    if( shortcode && (
                            shortcode === typ ||
                            'swcreator_' + shortcode === typ ||
                            'swifty_' + shortcode === typ
                        )
                    ) {
                        ret = asset;
                    }
                } );
            } );

            return ret;
        },

        getAssetClassOfType: function( typ ) {
            var assetDef = this.getAssetDefOfType( typ );

            return ( typeof assetDef === 'function' ) ? assetDef : assetDef.attr( 'class' );
        },

        getAssetViewOfType: function( typ ) {
            var assetDef = this.getAssetDefOfType( typ );

            return ( typeof assetDef === 'function' ) ? null : assetDef.attr( 'view' );
        },

        getAssetNameOfType: function( typ ) {
            var assetDef = this.getAssetDefOfType( typ );

            return ( typeof assetDef === 'function' ) ? '' : assetDef.attr( 'name' );
        },

        getAssetOnChangeOfType: function( typ ) {
            var assetDef = this.getAssetDefOfType( typ );

            return ( typeof assetDef === 'function' ) ? null : assetDef.attr( 'onchange' );
        },

        getAssetForceCloseTags: function() {
            var list = {};

            categoryList.each( function( cat /*, i*/ ) {
                cat.attr( 'assets' ).each( function( asset /*, j*/ ) {
                    var shortcode = asset.attr( 'shortcode' );

                    if( shortcode ) {
                        list[ shortcode ] = ( typeof asset === 'function' ) ? 0 : asset.attr( 'force_close_tag' );
                    }
                } );
            } );
            return list;
        },

        isEditingMain: function() {
            return scc_data && ( scc_data.area === 'main' );
        },

        createAssetClassForElement: function( $el, inline ) {
            var $assetContainer = $el.closest( '.swc_asset,.swc_text' );
            var assetType = $assetContainer.attr( 'data-asset_type' );
            var AssetClass = this.getAssetClassOfType( assetType );

            if ( AssetClass ) {
                var name = this.getAssetNameOfType( assetType );
                var obj = {};

                obj.is_block = inline ? false : true;
                obj.in_grid = $el.closest( '.swc_grid_row' ).length > 0;

                if( name + '' !== '' ) {
                    obj.asset_name = name;
                }
                if( assetType + '' !== '' ) {
                    obj.shortcode = assetType;
                }
                var asset = new AssetClass( $el, obj );

                // Combine the default onchange array with registered onchange.
                var onchange = this.getAssetOnChangeOfType( assetType );
                if( onchange ) {
                    if( asset.options.onchange ) {
                        // combine only unique values
                        $.each( asset.options.onchange, function( i, value ) {
                            if( $.inArray( value, onchange ) === - 1 ) {
                                onchange.push( value );
                            }
                        } );
                    }
                    asset.options.onchange = onchange;
                }

                return asset;
            }
            return null;
        },

        openAssetPanel: function( $el, mode, inline, initCss ) {

            var asset = this.createAssetClassForElement( $el, inline );

            if ( asset ) {
                if( initCss ) {
                    asset.assignCss();
                }

                if( mode === 'added_new' ) {
                    asset.openEditPanel( mode );
                } else if( mode === 'icon_resized' ) {
                    asset.resizeToCurrentWidth();
                } else {
                    asset.openMainPanel( mode );
                }
            }
        },

        setAssetLock: function( $el, locked ) {

            var asset = this.createAssetClassForElement( $el );

            if ( asset ) {
                asset.setLocked( locked );
            }
        },

        contentLocked: function() {
            panelStackInstance.resetPanelStack( { 'left': true } );
            panelStackInstance.addPanel( InfoPanel, {
                'info_text': __( 'This content has been locked by an administrator.' ),
                'info_text2': __( 'Contact the administrator to change it.' )
            } );
        },

        setRowLock: function( $row, locked ) {

            var data = $.parseJSON( $row.attr( 'data-grid_data' ) );

            if ( data ) {
                if( locked ) {
                    data.swc_locked = '1';
                    $row.addClass( 'swc_locked' );
                } else {
                    delete data.swc_locked;
                    $row.removeClass( 'swc_locked' );
                }
                $row.attr( 'data-grid_data', JSON.stringify( data ) );

                var $assets_in_row = $row.find( '.swc_asset,.swc_text' );
                $.each( $assets_in_row, function( ii, element ) {
                    var $container = $( element );
                    var $containerContent = $container.children( '.swc_asset_cntnt' );
                    if( $containerContent.length === 1 ) {
                        var assetData = $.parseJSON( Utils.atou( $containerContent.attr( 'data-asset_data' ) ) );
                        if( locked ) {
                            assetData.swc_locked = '1';
                            $container.addClass( 'swc_locked' );
                        } else {
                            delete assetData.swc_locked;
                            $container.removeClass( 'swc_locked' );
                        }
                        $containerContent.attr( 'data-asset_data', Utils.utoa( JSON.stringify( assetData ) ) );
                    }
                } );

                evt( 'swifty_editor_trigger_save', {} );
            }
        },

        copyAsset: function( $el ) {
            var asset = this.createAssetClassForElement( $el );

            if ( asset ) {
                asset.copyToDB();
            }
        },

        copyRow: function( $row ) {
            var self = this;

            evt( 'animate_clipboard_copy', { '$element': $row } );

            evt( 'convert_from_element_html', { '$element': $row } ).done( function( content ) {
                self.swiftyCopyContentToDB( { 'content': content, 'source': 'row' } );
            } );
        },

        swiftyCopyContentToDB: function( options, dfd ) {

            dfd || ( dfd = new $.Deferred() );

            $.post(
                Utils.getSWCreatorAjaxUrl(),
                {
                    'action': 'set_content_clipboard',
                    'id': scc_data.page_id,
                    'ajax_nonce': scc_data.ajax_nonce,
                    'content': options.content,
                    'source': options.source
                    // 'options': JSON.stringify( options ) // Trello G9LnVipB: Gave issues with ModSecurity
                },
                function( data ) {
                    scc_data.is_content_clipboard_available = true;
                    dfd.resolve( $.parseJSON( data ) );
                }
            );
            return dfd;
        },

        swiftyCopyContentFromDB: function( dfd ) {

            dfd || ( dfd = new $.Deferred() );

            $.post(
                Utils.getSWCreatorAjaxUrl(),
                {
                    'action': 'get_content_clipboard',
                    'id': scc_data.page_id,
                    'ajax_nonce': scc_data.ajax_nonce
                },
                function( data ) {
                    data = $.parseJSON( data );

                    if( data.status ) {
                        delete data.status;
                        dfd.resolve( data );
                    } else {
                        scc_data.is_content_clipboard_available = false;
                        dfd.resolve( false );
                    }
                }
            );

            return dfd;
        },


        '{window} evt_swc_swifty_copy_content_to_db': function( el, ev, opts, dfd ) {
            this.swiftyCopyContentToDB( opts, dfd );
        },

        '{window} evt_swc_swifty_copy_content_from_db': function( el, ev, opts, dfd ) {
            this.swiftyCopyContentFromDB( dfd );
        },

        '{window} evt_swc_swifty_editor_asset_dialog': function( el, ev, opts ) {
            this.openAssetPanel( $( opts.el ), opts.mod, opts.inline, opts.init_css );
        },

        '{window} evt_swc_swifty_editor_asset_edit_dialog': function( el, ev, opts ) {
            this.openAssetPanel( $( opts.el ), 'directedit', opts.inline, opts.init_css );
        },

        '{window} evt_swc_swifty_editor_asset_delete_dialog': function( el, ev, opts ) {
            this.openAssetPanel( $( opts.el ), 'delete', opts.inline, opts.init_css );
        },

        '{window} evt_swc_swifty_editor_asset_lock': function( el, ev, opts ) {
            this.setAssetLock( $( opts.el ), opts.locked );
        },

        '{window} evt_swc_swifty_editor_row_lock': function( el, ev, opts ) {
            this.setRowLock( $( opts.$row ), opts.locked );
        },

        '{window} evt_swc_swifty_editor_asset_locked': function( /*el, ev, opts*/ ) {
            this.contentLocked();
        },

        '{window} evt_swc_swifty_editor_row_locked': function( /*el, ev, opts*/ ) {
            this.contentLocked();
        },

        '{window} evt_swc_swifty_editor_asset_move_dialog': function( el, ev, opts ) {
            this.openAssetPanel( $( opts.el ), 'move', opts.inline, opts.init_css );
        },

        '{window} evt_swc_swifty_editor_asset_copy': function( el, ev, opts ) {
            this.copyAsset( $( opts.el ) );
        },

        '{window} evt_swc_swifty_editor_row_copy': function( el, ev, opts ) {
            this.copyRow( $( opts.$row ) );
        },

        '{window} evt_swc_get_asset_force_close_tags': function( el, ev, opts, dfd ) {
            var self = this;
            dfd.resolve( self.getAssetForceCloseTags( ) );
        },

        triggerAssetReload: function( $el ) {
            var $assetContainer = $el.closest( '.swc_asset' );
            var assetType = $assetContainer.attr( 'data-asset_type' );
            var AssetClass = this.getAssetClassOfType( assetType );

            if ( AssetClass ) {
                var asset = new AssetClass( $el, {} );
                asset.reloadFromServerNow();
            }
        },

        '{window} evt_swc_swifty_editor_change_window_location': function( el, ev, opts ) {
            window.location = opts.url;
        },

        '{window} evt_swc_swifty_editor_asset_inserted': function( el, ev, opts ) {
            this.triggerAssetReload( $( opts.el ) );
        },

        // Outcommented this event handler. Can't find the event element_moved call in the source.
        // '{window} evt_swc_element_moved': function( el, ev, opts ) {
        //     this.scrollTo( opts.$el, false );
        // },

        // Outcommented this event handler. Can't find the event asset_added call in the source.
        // '{window} evt_swc_asset_added': function( el, ev, opts ) {
        //     this.openAssetPanel( opts.$el, 'added_new', false, false );
        //     this.scrollTo( opts.$el, true );
        // },

        getAssetFromServer: function( $container, opts, refreshNr ) {
            var self = this;
            var dfd = new $.Deferred();

            $.post(
                Utils.getSWCreatorAjaxUrl(),
                {
                    'action': 'get_asset_content_by_data',
                    'id': scc_data.page_id,
                    'ajax_nonce': scc_data.ajax_nonce,
                    'data': JSON.stringify( opts.attr() )
                },
                function( data ) {
                    try {
                        data = $.parseJSON( data );
                        var $html = $( data.html );
                        var contentHtml = $html.html();
                        var wrapperStyle = $html.attr( 'style' );
                        var wrapperClasses = $html.attr( 'class' );
                        var triggerViewFn = self.getAssetViewOfType( opts.swc_shortcode );

                        evt( 'process_css_and_js_additions', { 'data': data } );

                        evt( 'new_asset_content_received', {
                            'container': $container,
                            'html': contentHtml,
                            'style': wrapperStyle,
                            'classes': wrapperClasses,
                            'refreshnr': refreshNr
                        } );

                        if( triggerViewFn ) {
                            setTimeout( function() {
                                evt( 'trigger_view_fn', {
                                    '$el': $container.find( '.' + opts.swc_shortcode )
                                } );
                            }, 1 );
                        }
                        dfd.resolve( data );
                    } catch( exception ) {
                        // Remove the spinner, otherwise it looks like there is still something to wait for.
                        evt( 'swifty_editor_remove_refresh_spinner' );
                        dfd.reject();
                    }
                }
            );

            return dfd;
        },

        addAutosaveFunctionality: function() {
            var self = this;
            var getPostData;
            var save;

            if ( typeof wp !== 'undefined' && wp.autosave && wp.autosave.__swifty_override ) {
                // WYJIjAay maybe there is a better way to disable autosave?
                if( self.isEditingMain() ) {
                    getPostData = function( /*type*/ ) {
                        return {
                            post_id: scc_data.page_id,
                            post_type: 'page',
                            content: self.newest_content,
                            post_title: scc_data.page_title
                        };
                    };

                    save = function() {
                        var postData = getPostData();
                        postData._wpnonce = window.autosaveL10n.swcreator_wp_nonce;
                        if( postData.content == null /*|| postData.content === ''*/ ) {
                            // This is important, otherwise WP autosave will save empty content!
                            // Not sure when and why this is triggered though.
                            // WYJIjAay remove
                            //if( console ) { console.log( '===============================', postData.content ) };
                            return false;
                        }
                        return postData;
                    };

                    wp.autosave.__swifty_override( getPostData );
                    wp.autosave.server.__swifty_override( save );
                } else {
                    getPostData = function( /*type*/ ) {
                        return {
                            post_id: scc_data.page_id,
                            post_type: 'page',
                            content: '',
                            post_title: ''
                        };
                    };

                    save = function() {
                        return false;
                    };

                    wp.autosave.__swifty_override( getPostData );
                    wp.autosave.server.__swifty_override( save );
                }
            }
        },

        savePage: function() {
            var self = this;

            if( typeof wp !== 'undefined' && wp.autosave && this.isEditingMain() ) {
                evt( 'saving_started' );
                self.getMap().attr( 'is_saving', true );

                wp.autosave.server.triggerSave();
            }
        },

        getAssets: function() {
            categoryList.each( function( cat /*, i*/ ) {
                cat.attr( 'assets' ).attr( 'comparator', 'order' );
            } );

            return categoryList;
        },

        getMap: function() {
            return map;
        },

        checkPubStatus: function( currentContent, overwrite_initial_content ) {
            var self = this;
            var publishedContent = self.getMap().attr( 'published_content' );
            var areaHasBeenChanged = self.getMap().attr( 'area_has_been_edited' );

            if( overwrite_initial_content ) {
                self.getMap().attr( 'initial_content', currentContent );
            }
            if( publishedContent === '_-NOT-PublisheD-_' ) {
                if( self.getMap().attr( 'initial_content' ) === null ) {
                    self.getMap().attr( 'initial_content', currentContent );
                }
                self.getMap().attr( 'is_published_same', '' === currentContent );
            } else {
                if( currentContent === null ) {
                    currentContent = self.getMap().attr( 'initial_content' );
                }

                //if( (currentContent) && (publishedContent) ) {
                //    console.log( currentContent.length );
                //    console.log( publishedContent.length );
                //
                //    var prefix = function( a, b ) {
                //        return a && a[0] === b[0] ? a[0] + prefix( a.slice( 1 ), b.slice( 1 ) ) : '';
                //    };
                //
                //    var diff = function( a, b ) {
                //        return a === b ? - 1 : prefix( a, b ).length;
                //    };
                //
                //    var hexEncode = function( str ) {
                //        var hex, i, result = '';
                //        for( i = 0; i < str.length; i ++ ) {
                //            hex = str.charCodeAt( i ).toString( 16 );
                //            result += ('000' + hex).slice( - 4 );
                //        }
                //        return result;
                //    }
                //
                //    var diffpos = diff( publishedContent, currentContent );
                //    if( diffpos !== - 1 ) {
                //        console.log( 'diff at: ' + diffpos );
                //        var txt1 = currentContent.substr( Math.max( 0, diffpos - 4 ), 10 );
                //        var txt2 = publishedContent.substr( Math.max( 0, diffpos - 4 ), 10 );
                //        var txt1hex = hexEncode( txt1 );
                //        var txt2hex = hexEncode( txt2 );
                //        txt1 = txt1.replace( /(\r)/g, '\\r' ).replace( /(\n)/g, '\\n' ).replace( /(\t)/g, '\\t' ).replace( /(\u000b)/g, '\\v' );
                //        txt2 = txt2.replace( /(\r)/g, '\\r' ).replace( /(\n)/g, '\\n' ).replace( /(\t)/g, '\\t' ).replace( /(\u000b)/g, '\\v' );
                //        console.log( 'currentContent   :' + txt1hex + ':' + txt1 );
                //        console.log( 'publishedContent :' + txt2hex + ':' + txt2 );
                //    } else {
                //        var txt1 = currentContent.replace( /(\r)/g, '\\r' ).replace( /(\n)/g, '\\n' );
                //        console.log( txt1 );
                //    }
                //}

                // areas always contain the latest published content, only a (auto)save will give updated content to be published
                if( areaHasBeenChanged || self.isEditingMain() ) {
                    self.getMap().attr( 'is_published_same', ( currentContent === null ) || ( publishedContent === currentContent ) );
                } else {
                    self.getMap().attr( 'is_published_same', true );
                }
            }
        },

        publishPageNow: function() {
            var self = this;

            // Update the page styles object.

            self.savePageStyleObject();

            // Publish the normal content.

            return $.post(
                scc_data.ajax_url, {
                    'action': 'swcreator_publish',
                    'ajax_nonce': scc_data.ajax_nonce,
                    'id': scc_data.page_id
                }
            ).then( function( data ) {
                if( data ) {
                    // force line ending when comparing for changes
                    data = data.replace( /\r\n/g, '\n' );
                }
                self.getMap().attr( 'published_content', data );
                self.checkPubStatus( data, true );
            } );
        },

        // Update the page styles object.

        savePageStyleObject: function() {
            var ky = 'page_';

            if( scc_data.area !== 'main' ) {
                ky = scc_data.area + '_' + ( scc_data.area_template ? scc_data.area_template : '' );
            }

            evt( 'get_page_style_object', ky ).then( function( obj ) {
                if( obj ) {
                    obj = JSON.stringify( obj );
                    $.post(
                        Utils.getSWCreatorAjaxUrl(),
                        {
                            'action': 'set_area_template_style',
                            'id': scc_data.page_id,
                            'ajax_nonce': scc_data.ajax_nonce,
                            'style': obj,
                            'name': ky === 'page_' ? 'page' : scc_data.area,
                            'template': ky === 'page_' ? scc_data.page_id : scc_data.area_template
                        },
                        function( data ) {
                        }
                    );
                }
            } );
        },

        publishContentNow: function() {
            var self = this;

            // Update the page styles object.

            self.savePageStyleObject();

            // Publish the normal content.

            return $.post(
                scc_data.ajax_url, {
                    'action': 'swcreator_publish',
                    'ajax_nonce': scc_data.ajax_nonce,
                    'id': scc_data.page_id,
                    'view_id': scc_data.view_id,
                    'content': self.newest_content,
                    'area': scc_data.area,
                    'area_template': scc_data.area_template
                }
            ).then( function( data ) {
                    if( data ) {
                        // force line ending when comparing for changes
                        data = data.replace( /\r\n/g, '\n' );
                    }
                    self.getMap().attr( 'published_content', data );
                    self.checkPubStatus( data, true );
                } );
        },

        deleteArea: function() {
            return $.post(
                scc_data.ajax_url, {
                    'action': 'swcreator_delete_area',
                    'ajax_nonce': scc_data.ajax_nonce,
                    'id': scc_data.page_id  // this is the id of the area post
                }
            );
        },

        getPublishedVersions: function() {
            return $.post(
                scc_data.ajax_url, {
                    'action': 'swcreator_get_published_versions',
                    'ajax_nonce': scc_data.ajax_nonce,
                    'id': scc_data.page_id
                }
            );
        },

        restorePageRevision: function( revisionID ) {
            return $.post(
                scc_data.ajax_url, {
                    'action': 'swcreator_get_revision',
                    'ajax_nonce': scc_data.ajax_nonce,
                    'id': scc_data.page_id,
                    'revision_id': revisionID
                }
            ).then( function( data ) {
                evt(
                    'swifty_editor_set_new_content',
                    {
                        'content': data
                    }
                );
            } );
        },

        getAreaSettings: function() {
            return $.post(
                scc_data.ajax_url, {
                    'action': 'swcreator_get_area_settings',
                    'ajax_nonce': scc_data.ajax_nonce,
                    'id': scc_data.page_id
                }
            ).then( function( data ) {
                return data;
            } );
        },

        saveAreaSettings: function( areaSettings ) {
            return $.post(
                scc_data.ajax_url, {
                    'action': 'swcreator_save_area_settings',
                    'ajax_nonce': scc_data.ajax_nonce,
                    'id': scc_data.page_id,
                    'area_settings': areaSettings
                }
            ).then( function( data ) {
                return data;
            } );
        },

        swiftyremovep: function ( html ) {
            var swifty_comments = [];
            html = html + '';

            /*
             * swifty asset content shouldn't be touched by removep.
             * Replace swifty asset content with placeholders and bring them back after removep.
             */
            if( html.indexOf( '<!--keep_swifty_content_start-->' ) !== - 1 ) {
                var pee_parts = html.split( '<!--keep_swifty_content_end-->' );
                var last_pee = pee_parts.pop();
                html = '';

                $.each( pee_parts, function( i, pee_part ) {
                    var start = pee_part.indexOf( '<!--keep_swifty_content_start-->' );

                    // Malformed html?
                    if( start === - 1 ) {
                        html = html + pee_part;
                        return false;
                    }

                    var name = '<!--SwIftrEplace-{' + i + '}-->';
                    swifty_comments.push( { name: name, value: pee_part.slice( start ) + '<!--keep_swifty_content_end-->' } );

                    html = html + pee_part.slice( 0, start ) + name;
                } );

                html = html + last_pee;
            }

            if( window.wp.editor && window.wp.editor.removep ) {
                html = window.wp.editor.removep( html );
            }

            $.each( swifty_comments, function( i, slice ) {
                html = html.split( slice.name ).join( slice.value );
            } );

            return html;
        },

        findUsedFonts: function( html ) {
            evt( 'get_list_google_fonts' ).then( function( googleFonts ) {
                var regx = /font-family:(.*?),/g;
                var fontFinds;
                var usedFonts = [];
                while( ( fontFinds = regx.exec( html ) ) !== null ) {
                    if( fontFinds.length > 1 ) {
                        var font = fontFinds[ 1 ];
                        var isGoogleFont = '';
                        googleFonts.each( function( gFontGroup ) {
                            gFontGroup.each( function( gFont ) {
                                if( gFont.toLowerCase() === font.toLowerCase() ) {
                                    isGoogleFont = gFont;
                                }
                            } );
                        } );
                        if( isGoogleFont !== '' ) {
                            usedFonts.push( isGoogleFont );
                        }
                    }
                }

                evt( 'apply_found_fonts', usedFonts );
            } );
        },

        html_to_content: function( html ) {

//console.log('html_to_content');
//console.log(html);

            // convert caption tags back to caption shortcode for html5 support see img_caption_shortcode in wp-includes\media.php
            html = html.replace( /<figure class="wp-caption (alignnone|alignleft|aligncenter|alignright)"(.*?) style="width: (.+)px">(.*)(\s*)<figcaption class="wp-caption-text">(.*?)<\/figcaption>(\s*)<\/figure>/gi, '[caption$2  align="$1" width="$3"]$4$6[/caption]' );
            // convert caption tags back to caption shortcode for non html5 support see img_caption_shortcode in wp-includes\media.php
            html = html.replace( /<div class="wp-caption (alignnone|alignleft|aligncenter|alignright)"(.*?) style="width: (.+)px">(.*)(\s*)<p class="wp-caption-text">(.*?)<\/p>(\s*)<\/div>/gi, '[caption$2  align="$1" width="$3"]$4$6[/caption]' );

            // remove responsive makeup of wp 4.4+
            html = html.replace( /(<img .*) srcset=".*?"(.*\/>)/gi, '$1$2');
            html = html.replace( /(<img .*) sizes=".*?"(.*\/>)/gi, '$1$2');

            html = html.replace( /<!--keep_swifty_start-->/gi, '' );
            html = html.replace( /<!--keep_swifty_end-->/gi, '' );

// dorh May be removed. This trick is not needed and might make things worse. Committed outcommented so it can be retreived if needed later on.
            //// Remove line-ends between rows and columns, but not insode columns. Because otherwise wpautop might make a mess.
            //html = html.replace( /(\r\n|\n|\r)?(<swifty_grid_row_replacer|<\/swifty_grid_column_replacer)+(([\s\S])*?)(<swifty_grid_column_replacer|<\/swifty_grid_row_replacer)+(([\s\S])*?)>(\r\n|\n|\r)?/g, function( match, enters1, openTag, p1, none1, closeTag, p3 ) {
            //  return openTag +
            //      p1.replace( /(\r\n|\n|\r)/gm, '' ) +
            //      closeTag + p3 + '>';
            //} );

            // we will save p an br tags converted to newlines, the same as tiny mce
            if( scc_data.wpautop_active === '1' ) {
                // force line ending
                html = html.replace( /\r\n/g, '\n' );
                // keep empty p tags by using p tag with &nbsp;
                html = html.replace( /<p>(?:<br ?\/?>|\u00a0|\uFEFF| )*<\/p>/g, '<p>&nbsp;</p>' );
                html = this.swiftyremovep( html );
            }

            html = html.replace( /<!--keep_swifty_content_start-->/gi, '' );
            html = html.replace( /<!--keep_swifty_content_end-->/gi, '' );

            // For showing the blue border round a table when hovering it, the css class 'swc_table_outline' is used.
            // It happens that this class gets saved within the content. Here we replace it with an empty string.
            html = html.replace( 'swc_table_outline', '' );

            html = html.replace( /<swifty_(block|inline)_replacer>(\n)*/g, '' );
            html = html.replace( /<\/swifty_(block|inline)_replacer>(\n)*/g, '' );

            html = html.replace( /<swifty_grid_row_replacer data-grid-row-shortcode_data="(([\s\S])*?)">(\s)*/g, '[swifty_grid_row$1]' );
            html = html.replace( /<\/swifty_grid_row_replacer>/g, '[/swifty_grid_row]' ); // Must NOT contain (\n)* or (\s)* at the end!

            html = html.replace( /<swifty_grid_column_replacer data-grid-column-shortcode_data="(([\s\S])*?)">(\s)*/g, '[swifty_grid_column$1]' );
            html = html.replace( /<\/swifty_grid_column_replacer>/g, '[/swifty_grid_column]' ); // Must NOT contain (\n)* or (\s)* at the end!

            html = html.replace( /<swifty_text_replacer data-text_data="(([\s\S])*?)">(\s)*/g, '[swifty_text$1]' );
            html = html.replace( /<\/swifty_text_replacer>/g, '[/swifty_text]' ); // Must NOT contain (\n)* or (\s)* at the end!

            // Trick to prevent quotes in encoded json being saved as &quote;
            html = html.replace( /_=QUoTe=-/g, '"' );

            // Remove the column wrappers. They must NOT be saved!
            html = html.replace( /(\s)*<div([^<]*?)class="swc_grid_colwrapper([^>]*?)>(\s)*/g, '' );
            html = html.replace( /(\s)*<div([^<]*?)class="swc_grid_colclose([^>]*?)>(\s)*<\/div>(\s)*<\/div>(\s)*/g, '' );

            // Remove the incorrectly added <p> </p> that CKeditor inserted inside rows but outside columns
            html = html.replace( /\[swifty_grid_row(([\s\S])*?)](\s)*<p>(\s)*<\/p>(\s)*\[swifty_grid_column/g, '[swifty_grid_row$1][swifty_grid_column' );

            // Remove the style wrappers. They must NOT be saved!
            html = html.replace( /(\s)*<style([^<]*?)class="swc_custom_css"([^>]*?)>([\s\S])*?<\/style>([\s\S])*?<div([^<]*?)class="swc_custom_cssclose"([^>]*?)>(\s)*<\/div>(\s)*/g, '' );

            // Remove the row effect elements. They must NOT be saved!
            html = html.replace( /(\s)*<div([^<]*?)class="swc_rw_in_effect"([^>]*?)>([\s\S])(\s)*<\/div>/g, '' );

            // Trick to prevent enters messing up shortcode data.
            html = html.replace( /_=EnTEr=-/g, '\n' );

            // Replace trailing &nbsp; after a ] to be more compatible with the output of WP Tiny visual mode.
            html = html.replace( /]&nbsp;$/g, ']\n\n&nbsp;' );

            // Add nbsp to empty p tag to be more compatible with the output of WP Tiny visual mode.
            html = html.replace( /<p>(\s)*<\/p>/g, '<p>&nbsp;</p>' );

            // This fixes an inconsistency with WP Tiny output.
            // Not sure why a double /n appears in our output, but it could cause trouble for wpautop.
            // So replacing it by a single \n makes sure wpautop stays out of trouble and the resulting output is
            // the same as WP Tiny saves.
            html = html.replace( /<\/p>\n\n\[\/swifty_grid_column/g, '</p>\n\[/swifty_grid_column' );

            // This fixes an inconsistency with WP Tiny output.
            html = html.replace( /]<h/g, ']\n<h' );

            return html;
        },

        '{window} evt_swc_set_row_lock': function( el, ev, opts/*, dfd*/ ) {
            this.setRowLock( opts.$row, opts.locked );
        },

        '{window} evt_swc_register_asset': function( el, ev, opts/*, dfd*/ ) {
            this.registerAsset( opts, 1 );
        },

        '{window} evt_swc_ready_for_register_asset': function( el, ev, opts, dfd ) {
            dfd.resolve( 1 );
        },

        '{window} evt_swc_get_amd_items': function( el, ev, opts, dfd ) {

            var items = {};
            if( opts.asset ) {
                items.asset = Asset;
            }
            if( opts.image_viewer ) {
                items.image_viewer = ImageViewer;
            }
            dfd.resolve( items );
        },

        '{window} evt_swc_get_area_settings': function( el, ev, opts, dfd ) {
            this.getAreaSettings().then( function( data ) {
                dfd.resolve( data );
            } );
        },

        '{window} evt_swc_save_area_settings': function( el, ev, opts, dfd ) {
            this.saveAreaSettings( opts ).then( function( data ) {
                dfd.resolve( data );
            } );
        },

        '{window} evt_swc_publish_page_now': function( el, ev, opts, dfd ) {
            this.publishPageNow().then( function( data ) {
                dfd.resolve( data );
            } );
        },

        '{window} evt_swc_publish_content_now': function( el, ev, opts, dfd ) {
            this.publishContentNow().then( function( data ) {
                dfd.resolve( data );
            } );
        },

        '{window} evt_swc_delete_area': function( el, ev, opts, dfd ) {
            this.deleteArea().then( function( data ) {
                dfd.resolve( data );
            } );
        },

        '{window} evt_swc_get_published_versions': function( el, ev, opts, dfd ) {
            this.getPublishedVersions().then( function( data ) {
                dfd.resolve( data );
            } );
        },

        '{window} evt_swc_restore_page_revision': function( el, ev, opts, dfd ) {
            this.restorePageRevision( opts.revision_id ).then( function( data ) {
                dfd.resolve( data );
            } );
        },

        '{window} evt_swc_get_assets': function( el, ev, opts, dfd ) {
            var assets = this.getAssets();

            dfd.resolve( assets );
        },

        '{window} evt_swc_register_swifty_editor_assets': function( el, ev, opts /*, dfd*/ ) {
            this.registerSwiftyEditorAssets( opts.assets );
        },

        '{window} evt_swc_asset_data_changed': function( el, ev, opts, dfd ) {
            this.getAssetFromServer(
                opts.container,
                opts.asset_data,
                opts.refreshnr
            ).then( function( data ) {
                dfd.resolve( data );
            } );
        },

        '{window} evt_swc_swifty_editor_content_changed': function( el, ev, data /*, dfd*/ ) {
            //console.log( 'going to save', data.content );

            if( data && ( data.content != null ) ) {
                // Set new content and trigger WP autosave
                this.heartbeat_content = null;

                data.content = this.html_to_content( data.content );

                this.findUsedFonts( data.content );

                this.newest_content = data.content;
                if( this.isEditingMain() ) {
                    evt( 'saving_throttled_started' );
                    this.getMap().attr( 'is_saving', true );

                    this.savePageThrottledObject();

                    this.checkPubStatus( data.content, false );
                } else {
                    this.getMap().attr( 'area_has_been_edited', true );
                }
            }

            evt( 'swifty_update_scrolleffect' );
        },

        '{window} evt_swc_swifty_editor_before_init': function( el, ev, data /*, dfd*/ ) {
            if( data && ( data.content != null ) ) {

                data.content = this.html_to_content( data.content );

                this.findUsedFonts( data.content );

                this.checkPubStatus( data.content, true );
            }
        },

        '{window} evt_swc_swifty_html_to_content': function( el, ev, data, dfd ) {
            if( data && ( data.content != null ) ) {
                dfd.resolve( this.html_to_content( data.content ) );
            } else {
                dfd.resolve( '' );
            }
        },

        '{document} heartbeat-send': function( el,  ev, data ) {
            if( data.wp_autosave && ( data.wp_autosave.content != null ) ) {
                this.heartbeat_content = data.wp_autosave.content;
            }
        },

        '{document} heartbeat-tick': function( el,  ev, data ) {
            var self = this;

            // Autosave record is deleted when equal to published data and a false is returned as succes. That is why
            // we need to compare the content with published content ourselves.
            if( data.wp_autosave && ( ( data.wp_autosave.success === true ) || ( this.newest_content === self.getMap().attr( 'published_content' ) ) ) ) {
                if( this.newest_content === this.heartbeat_content ) {
                    evt( 'saving_done' ).done( function() {
                            self.getMap().attr( 'is_saving', false );
                        }
                    );
                }
            } else if( data.wp_autosave && ( data.wp_autosave.success === false ) ) {
                evt( 'saving_failed' );
            }
        },

        '{window} evt_swc_new_determine_image_sizes': function( el, ev, data /*, dfd*/ ) {
            if( data && data.sizes ) {
                window.swiftyCheckImageSizesToBeDetermined( scc_data.page_id, data.sizes );
            }
        },

        '{window} evt_swc_add_content_panel': function( el, ev, data /*, dfd*/ ) {
            panelStackInstance.addPanel( AddContentPanel,
                {
                    'in_grid': data ? data.in_grid : false,
                    '$column': data ? data.$column : null,
                    'locked': data ? data.locked : false,
                    'allowance': data ? data.allowance : null
                } );
        },

        '{window} evt_swc_show_page_setup': function( /*el, ev, opts*/ ) {
            var self = this;

            if( self.isEditingMain() ) {
                panelStackInstance.addPanel( PageSetupPanel, {} );
            } else {
                evt( 'swifty_editor_show_tooltip' );
            }
        },

        // conversion from content with shortcodes to html

        convertPresetHtml: function( htmlSettings ) {
            var self = this;
            var dfd = $.Deferred();

            // Convert the html because it can contain shortcodes, like [swifty_box].
            // The shortcodes will be rendered by the server and included in the returned html.
            $.post(
                Utils.getSWCreatorAjaxUrl(),
                {
                    'action': 'convert_html_with_shortcodes',
                    'id': scc_data.page_id,
                    'ajax_nonce': scc_data.ajax_nonce,
                    'data': htmlSettings.html
                },
                function( data ) {
                    data = $.trim( data );

                    if( data.substr( 0, 1 ) === '{' ) {
                        data = $.parseJSON( data );

                        // Remove trailing line-end, because that wil cause an extra p tag in CKeditor.
                        data.html = data.html.replace( /\n$/, '' );

                        if( data.plugin_slug ) {
                            var insert_asset_error = __( 'Pasting not allowed. Paste content contains expired license content element(s):' ) +
                                '\n' + data.plugin_slug +
                                '\n\n';
                            if( typeof swiftyProbe === 'undefined' ) {
                                alert( insert_asset_error );
                            } else {
                                htmlSettings.html = insert_asset_error.replace( '\n', '<br>' );

                                self.replaceHtml( htmlSettings ).done( function() {
                                    dfd.resolve();
                                } );
                            }
                        } else {
                            evt( 'replace_ids', { 'html': data.html } ).then( function( html ) {
                                data.html = html;

                                evt( 'get_swifty_ssd_data' ).then( function( swifty_ssd_data ) {
                                    // Replace colors etc.
                                    self.options.replaceList = [];

                                    if( swifty_ssd_data && swifty_ssd_data.colors && swifty_ssd_data.colors.length > 2 ) {
                                        self.options.replaceList.push( ['#1e3c7c', swifty_ssd_data.colors[2]] );
                                    }

                                    htmlSettings.html = data.html;

                                    self.replaceHtml( htmlSettings ).done( function() {
                                        dfd.resolve();
                                    } );
                                } );
                            } );
                        }
                    }
                }
            );

            return dfd;
        },

        // Replace colors etc in the html by the colors from the SSD palet.

        replaceHtml: function( htmlSettings ) {
            var self = this;

            // There can be multiple strings that can only be replaced deferred.
            // For instance an image on the stuff server must be uploaded to the uploads dir,
            // which takes time. Only after the upload the final url is known and the stuff url
            // must be replaced by this new url.
            // dfds contains a list of all deferreds that occur.
            // Only after ALL deferreds are resolved, dfds will trigger it's done() function.
            var dfds = NewDfds();

            // Add a default deferred so that dfds.done() will be triggered even if there are no deferred replaces.
            var dfd = $.Deferred();
            dfds.add( dfd );

            // Replace strings in both normal html and in base64 encoded asset_data.
            for( var i = 0; i < 2; i++ ) {
                self._replaceHtmlAll( dfds, htmlSettings );
            }

            // The normal replaces have been done.
            // Other replaces might still be going on.
            dfd.resolve();

            return dfds;
        },

        // Replace strings in both normal html and in base64 encoded asset_data.

        _replaceHtmlAll: function( dfds, htmlSettings ) {
            var self = this;

            // Replace all strings.
            htmlSettings.html = self._replaceHtmlHelper( htmlSettings.html, htmlSettings );

            // Replace the strings that are inside base64 encoded  asset_data.
            htmlSettings.html = htmlSettings.html.replace( /data-asset_data="([A-Za-z0-9+\/=]*?)"/g, function( match, p1 ) {

                // Decode base64
                p1 = Utils.atou( p1 );

                // Convert to object
                var p1Data = JSON.parse( p1 );

                // Does the asset_data contain an url item?
                if( p1Data && typeof p1Data.url === 'string' ) {

                    // Does the url point to the stuff server?
                    if( p1Data.url.indexOf( 'https://stuff.swifty.online/static/' ) === 0 ) {

                        if( htmlSettings.replaceImages ) {
                            if( ! self._isInReplaceList( p1Data.url ) ) {
                                // A new deferred replace will occur.
                                // dfds.done() must not be triggered before this deferred is resolved.
                                var dfd = $.Deferred();
                                dfds.add( dfd );

                                self._addToReplaceList( p1Data.url, '_==PENDING=_=', htmlSettings );

                                // Limit the max width of an uploaded image to 1920.
                                var downloadUrl = p1Data.url;
                                if( !( downloadUrl.indexOf( '?swifty=' ) > 0 ) ) {
                                    downloadUrl += '?swifty=1&ssw=1920';
                                }

                                // Upload the image from the stuff server to the uploads dir.
                                $.post(
                                    scc_data.ajax_url,
                                    {
                                        'action': 'insert_attachment_from_url',
                                        'urls': JSON.stringify( [ downloadUrl ] ),
                                        'id': scc_data.page_id,
                                        'ajax_nonce': scc_data.ajax_nonce
                                    }
                                ).done(
                                    function( attachments ) {
                                        if( attachments && ( attachments.length > 0 ) ) {
                                            // The image was uploaded and the final url is known (attachments[ 0 ].url).
                                            self._addToReplaceList( p1Data.url, attachments[ 0 ].url, htmlSettings );

                                            // Replace strings in both normal html and in base64 encoded asset_data.
                                            self._replaceHtmlAll( dfds, htmlSettings );
                                        }

                                        // The deferred replace has been done.
                                        dfd.resolve();
                                    }
                                );
                            }
                        } else {
                            if( !( p1Data.url.indexOf( '?swifty=' ) > 0 ) ) {
                                self._addToReplaceList( p1Data.url + '"', p1Data.url + '?swifty=1&ssw=300"', htmlSettings );
                                self._addToReplaceList( p1Data.url + '\'', p1Data.url + '?swifty=1&ssw=300\'', htmlSettings );

                                p1Data.url += '?swifty=1&ssw=300';
                            }
                        }

                        // Convert the object back into a string
                        p1 = JSON.stringify( p1Data );
                    }
                }

                // Replace all strings.
                // These can occur in the encoded asset_data.
                p1 = self._replaceHtmlHelper( p1, htmlSettings );

                // Encode base64
                p1 = Utils.utoa( p1 );

                // Replace the original asset_data by the new asset_data with all replacements.
                return 'data-asset_data="' + p1 + '"';
            } );
        },

        // Replace all strings.

        _replaceHtmlHelper: function( html, htmlSettings ) {
            var self = this;

            $.each( self.options.replaceList, function( ii, replaceItem ) {
                if( replaceItem[ 1 ] !== '_==PENDING=_=' ) {
                    var reg = new RegExp( replaceItem[ 0 ], 'g' );
                    html = html.replace( reg, replaceItem[ 1 ] );
                }
            } );

            return html;
        },

        // Add a find/replace combination to the list of string to be replaced.

        _isInReplaceList: function( fnd ) {
            var self = this;

            var exists = null;
            $.each( self.options.replaceList, function( ii, replaceItem ) {
                if( replaceItem[ 0 ] === fnd ) {
                    exists = replaceItem;
                }
            } );

            return exists;
        },

        // Add a find/replace combination to the list of string to be replaced.

        _addToReplaceList: function( fnd, repl, htmlSettings ) {
            var self = this;

            var exists = self._isInReplaceList( fnd );
            if( ! exists ) {
                self.options.replaceList.push( [ fnd, repl ] );
            } else if( exists[ 1 ] === '_==PENDING=_=' ) {
                exists[ 1 ] = repl;
            }
        },

        '{window} evt_swc_convert_preset_html': function( el, ev, opts, dfd ) {
            var self = this;

            var htmlSettings = opts.htmlSettings ?  opts.htmlSettings : { 'replaceImages': true, 'html': opts.html };
            self.convertPresetHtml( htmlSettings ).then( function() {
                dfd.resolve( htmlSettings.html );
            } );
        },

        '{window} evt_swc_check_swifty_allow_external': function( el, ev, opts, dfd ) {
            $.post(
                scc_data.ajax_url,
                {
                    'action': 'get_set_swifty_allow_external',
                    'swifty_allow_external': '',
                    'id': scc_data.page_id,
                    'ajax_nonce': scc_data.ajax_nonce
                }
            ).then( function( data ) {
                dfd.resolve( data.swifty_allow_external );
            } );
        },

        '{window} evt_swc_set_swifty_allow_external': function( el, ev, opts, dfd ) {
            $.post(
                scc_data.ajax_url,
                {
                    'action': 'get_set_swifty_allow_external',
                    'swifty_allow_external': opts.allow,
                    'id': scc_data.page_id,
                    'ajax_nonce': scc_data.ajax_nonce
                }
            ).then( function( data ) {
                dfd.resolve( data.swifty_allow_external );
            } );
        },

        '{window} evt_swc_change_scc_data': function( el, ev, opts/*, dfd*/ ) {
            scc_data[ opts.key ] = opts.val;
        },

        '{window} evt_swc_set_is_style_changed': function( el, ev, opts/*, dfd*/ ) {
            this.getMap().attr( 'is_style_changed', opts );
        },

        '{window} evt_swc_get_asset_name': function( el, ev, opts, dfd ) {
            var asset = this.createAssetClassForElement( $( opts.el ), opts.inline );
            dfd.resolve( asset.getAssetNameTranslated() );
        }

    } );
} );

swifty.define('stache!js/panels/main/main.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/panels/main/main.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<div class="swc_panel_content_nowrap swc_panel_main_add_buttons">\n{{#if map.show_main_menu}}\n    <swc_panel_button icon="&#xe031;" action="add_content" name="{{__ \'Add content\'}}"/>\n    <swc_panel_button icon="&#xe031;" action="add_column" name="{{__ \'Add columns\'}}"/>\n    <swc_panel_button icon="&#xe031;" action="add_preset" name="{{__ \'Add preset\'}}"/>\n    {{#if page_model_map.show_button_options}}\n        <div class="swc_panel_btn_divider"></div>\n        <swc_panel_button icon="&#xe031;" action="page_options" name="{{__ \'Options\'}}"/>\n    {{/if}}\n    {{#if page_model_map.show_button_style}}\n        <div class="swc_panel_btn_divider"></div>\n        <swc_panel_button icon="fa-paint-brush" action="change_style" name="{{__ \'Style\'}}"/>\n    {{/if}}\n{{else}}\n    <div class="swc_button swc_main_scrsize swc_enabled swc_spinner_icon">\n        <i class="fa fa-spinner fa-spin fa-fw margin-bottom"></i>\n    </div>\n    <div class="swc_panel_notice_msg">{{page_model_map.show_main_menu_msg}}</div>\n{{/if}}\n</div>' ); return idn; });

swifty.define( 'js/panels/publish/publish',[
    'jquery',
    'swiftylib/evt',
    '../yes_no/yes_no',
    'swiftylib/i18n/__'
], function(
    $, evt, YesNo, __
) {
    

    return YesNo.extend( {
        'defaults': {
            'title': __( 'Publish page so it can be seen by others' ),
            'yes_name': __( 'Publish page' ),
            'no_name': __( 'Cancel. Do not publish' ),
            'yes_icon': '&#xe033;'
        }
    }, {
        '.swc_panel_button_yes click': function() {
            var self = this;

            self.element.find( '.swc_panel_content' )
                .css( 'font-size', '18px' )
                .html( __( 'Publishing. Please wait...' ) );

            evt( 'publish_page_now' ).then( function( /*data*/ ) {
                evt( 'determine_image_sizes' );

                self.element.find( '.swc_panel_content' )
                    .css( {
                        'color': '#00a000',
                        'font-weight': 'bold'
                    } )
                    .html( __( 'Done! Your page is published and can now be seen by others' ) );
            } );
        },

        '.swc_panel_button_no click': function() {
            this.closePanel();
        }

    } );
} );


swifty.define('stache!js/panels/manage_versions/manage_versions.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/panels/manage_versions/manage_versions.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<div class="swc_panel_content_nowrap">\n    {{#if revisions.data}}\n        {{^page_model_map.is_published_same}}\n        <div class="swc_revision_warning">\n            {{{__ \'There are unpublished changes on this page.<br />If you restore an older page version,<br />these changes will be lost permanently.\'}}}\n        </div>\n        {{/page_model_map.is_published_same}}\n        {{#each revisions.data}}\n            <div class="swc_revision_button_wrapper">\n                <div class="swc_revision_button" data-revision_id="{{ID}}">\n                    <div class="swc_text">\n                        {{swc_date_string}}<br><br>\n                        {{swc_time_string}}\n                    </div>\n                </div>\n            </div>\n        {{/each}}\n    {{else}}\n        {{__ \'One moment please...\'}}\n    {{/if}}\n</div>' ); return idn; });


swifty.define('css!js/panels/manage_versions/manage_versions',[],function(){});
(function (factory) {
if (typeof swifty.define === 'function' && swifty.define.amd) {
    // AMD. Register as an anonymous module.
    swifty.define('js/libs/stdlib_date',['jquery'], factory);
} else {
    // Browser globals
    factory(jQuery);
}
}(function (jQuery) {



// **************************************************************************
// Copyright 2007 - 2008 The JSLab Team, Tavs Dokkedahl and Allan Jacobs
// Contact: http://www.jslab.dk/contact.php
//
// This file is part of the JSLab Standard Library (JSL) Program.
//
// JSL is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// any later version.
//
// JSL is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.
// ***************************************************************************
// File created 2009-02-05 02:38:59

// Name of the months
Date.nameOfMonths = ['January','February','March','April','May','June','July','August','September','October','November','December'];

// Format a date according to a specified format
Date.prototype.format =
  function(s,utc) {
    // Split into array
    s = s.split('');
    var l = s.length;
    var r = '';
    var n = m = null;
    for (var i=0; i<l; i++) {
      switch(s[i]) {
        // Day of the month, 2 digits with leading zeros: 01 to 31
        case 'd':
          n = utc ? this.getUTCDate() : this.getDate();
          if (n * 1 < 10)
            r += '0';
          r += n;
          break;
        // A textual representation of a day, three letters:  Mon through Sun 
        case 'D':
          r += this.getNameOfDay(utc).substring(0,3);
          break;
        // Day of the month without leading zeros:   1 to 31
        case 'j':
          r += utc ? this.getUTCDate() : this.getDate();
          break;
        // Lowercase l A full textual representation of the day of the week: Sunday (0) through Saturday (6) 
        case 'l':
          r += this.getNameOfDay(utc);
          break;
        // ISO-8601 numeric representation of the day of the week: 1 (for Monday) through 7 (for Sunday) 
        case 'N':
          r += this.getISODay(utc);
          break;
        // English ordinal suffix for the day of the month, 2 characters
        case 'S':
          r += this.getDaySuffix(utc);
          break;
        // Numeric representation of the day of the week: 0 (for Sunday) through 6 (for Saturday) 
        case 'w':
          r += utc ? this.getUTCDay() : this.getDay();
          break;
        // The day of the year (starting from 0) 0 through 365
        case 'z':
          n = 0;
          m = utc ? this.getUTCMonth() : this.getMonth();
          for(var i=0; i<m; i++)
            n += Date.daysInMonth[i]
          if (this.isLeapYear())
            n++;
          n += utc ? this.getUTCDate() : this.getDate();
          n--;
          r += n;
          break;
        //   break;
        // ISO-8601 week number of year, weeks starting on Monday
        case 'W':
          r += this.getISOWeek(utc);
          break;
        // A full textual representation of a month, such as January or March:  January through December 
        case 'F':
          r += this.getNameOfMonth(utc);
          break;
        // Numeric representation of a month, with leading zeros 01 through 12 
        case 'm':
          n = utc ? this.getUTCMonth() : this.getMonth();
          n++;
          if (n < 10)
            r += '0';
          r += n;
          break;
        // A short textual representation of a month, three letters:  Jan through Dec 
        case 'M':
          r += this.getNameOfMonth(utc).substring(0,3);
          break;
        // Numeric representation of a month, without leading zeros:  1 through 12 
        case 'n':
          n = utc ? this.getUTCMonth() : this.getMonth();
           r += ++n;
          break;
        // Number of days in the given month: 28 through 31 
        case 't':
          r += this.getDaysInMonth(utc);
          break;
        // Whether it's a leap year:  1 if it is a leap year, 0 otherwise.
        case 'L':
          if (this.isLeapYear(utc))
            r += '1';
          else
            r += '0';
          break;
        // ISO-8601 year number. This has the same value as Y, except that if the ISO week number (W) belongs to the previous or next year, that year is used instead
        /*
        case 'o':
          break;
        */
        // A full numeric representation of a year, 4 digits
        case 'Y':
          r += utc ? this.getUTCFullYear() : this.getFullYear();
          break;
        // A two digit representation of a year
        case 'y':
          n = utc ? this.getUTCFullYear() : this.getFullYear();
          r += (n + '').substring(2);
          break;
        // Lowercase Ante meridiem and Post meridiem am or pm 
        case 'a':
          n = utc ? this.getUTCHours() : this.getHours();
          r += n < 12 ? 'am' : 'pm';
          break;
        // Uppercase Ante meridiem and Post meridiem AM or PM 
        case 'A':
          n = utc ? this.getUTCHours() : this.getHours();
          r += n < 12 ? 'AM' : 'PM';
          break;
        // Swatch Internet time 000 through 999 
        // case 'B':
        //   break;
        // 12-hour format of an hour without leading zeros
        case 'g':
          n = utc ? this.getUTCHours() : this.getHours();
          if (n > 12)
            n -= 12;
          r += n;
          break;
        // 24-hour format of an hour without leading zeros 0 through 23
        case 'G':
          r += this.getHours();
          break;
        //  12-hour format of an hour with leading zeros 01 through 12 
        case 'h':
          n = utc ? this.getUTCHours() : this.getHours();
          if (n > 12)
            n -= 12;
          if (n < 10)
            r += '0';
          r += n;
          break;
        // 24-hour format of an hour with leading zeros 00 through 23 
        case 'H':
          n = utc ? this.getUTCHours() : this.getHours();
          if (n < 10)
            r += '0';
          r += n;
          break;
        // i Minutes with leading zeros 00 to 59 
        case 'i':
          n = utc ? this.getUTCMinutes() : this.getMinutes();
          if (n < 10)
            r += '0';
          r += n;
          break;
        // s Seconds, with leading zeros 00 through 59 
        case 's':
          n = utc ? this.getUTCSeconds() : this.getSeconds();
          if (n < 10)
            r += '0';
          r += n;
          break;
        // Milliseconds
        case 'u':
          r += utc ? this.getUTCMilliseconds() : this.getMilliseconds();
          break;
        // Timezone identifier
        // case 'e':
        //   break;
        // Whether or not the date is in daylight saving time 1 if Daylight Saving Time, 0 otherwise. 
        case 'I':
          if (this.getMinutes() != this.getUTCMinutes)
            r += '1';
          else
            r += '0';
          break;
        // Difference to Greenwich time (GMT) in hours
        case 'O':
          n = this.getTimezoneOffset() / 60;
          if (n >= 0)
            r += '+';
          else
            r += '-';
          n = Math.abs(n);
          if (Math.abs(n) < 10)
            r += '0';
           r += n + '00';
          break;
        // Difference to Greenwich time (GMT) with colon between hours and minutes: Example: +02:00 
        case 'P':
          n = this.getTimezoneOffset() / 60;
          if (n >= 0)
            r += '+';
          else
            r += '-';
          n = Math.abs(n);
          if (Math.abs(n) < 10)
            r += '0';
           r += n + ':00';
          break;
        // T Timezone abbreviation EST, MDT etc. 
        // case 'T':
        //   break;
        // Z Timezone offset in seconds. The offset for timezones west of UTC is always negative, and for those east of UTC is always positive. 
        case 'Z':
          r += this.getTimezoneOffset() * 60;
          break;
        // ISO 8601 date: 2004-02-12T15:19:21+00:00 
        case 'c':
          r += this.format('Y-m-d',utc) + 'T' + this.format('H:i:sP',utc);
          break;
        // RFC 2822 formatted date Example: Thu, 21 Dec 2000 16:01:07 +0200 
        case 'r':
          r += this.format('D, j M Y H:i:s P',utc);
          break;
        case 'U':
          r += this.getTime();
          break;
        default:
          r += s[i];
      }
    }
    return r
  };

// Gen the english suffix for dates
Date.prototype.getDaySuffix =
  function(utc) {
    var n = utc ? this.getUTCDate() : this.getDate();
    // If not the 11th and date ends at 1
    if (n != 11 && (n + '').match(/1$/))
      return 'st';
    // If not the 12th and date ends at 2
    else if (n != 12 && (n + '').match(/2$/))
      return 'nd';
    // If not the 13th and date ends at 3
    else if (n != 13 && (n + '').match(/3$/))
      return 'rd';
    else
      return 'th';
  };

// Return the ISO day number for a date
Date.prototype.getISODay =
  function(utc) {
    // Native JS method - Sunday is 0, monday is 1 etc.
    var d = utc ? this.getUTCDay() : this.getDay();
    // Return d if not sunday; otherwise return 7
    return d ? d : 7;
  };

// Get ISO week number of the year
// The algorithm is credit to Claus Tndering and is taken from his calendar FAQ
// See http://www.tondering.dk/claus/cal/node8.html#SECTION00880000000000000000
// for more information
// Integer division: a/b|0
Date.prototype.getISOWeek =
  function(utc) {
    var y = utc ? this.getUTCFullYear(): this.getFullYear();
    var m = utc ? this.getUTCMonth() + 1: this.getMonth() + 1;
    var d = utc ? this.getUTCDate() : this.getDate();
    // If month jan. or feb.
    if (m < 3) {
      var a = y - 1;
      var b = (a / 4 | 0) - (a / 100 | 0) + (a / 400 | 0);
      var c = ( (a - 1) / 4 | 0) - ( (a - 1) / 100 | 0) + ( (a - 1) / 400 | 0);
      var s = b - c;
      var e = 0;
      var f = d - 1 + 31 * (m - 1);
    }
    // If month mar. through dec.
    else {
      var a = y;
      var b = (a / 4 | 0) - ( a / 100 | 0) + (a / 400 | 0);
      var c = ( (a - 1) / 4 | 0) - ( (a - 1) / 100 | 0) + ( (a - 1) / 400 | 0);
      var s = b - c;
      var e = s + 1;
      var f = d + ( (153 * (m - 3) + 2) / 5 | 0) + 58 + s;
    }
    var g = (a + b) % 7;
    // ISO Weekday (0 is monday, 1 is tuesday etc.)
    var d = (f + g - e) % 7;
    var n = f + 3 - d;
    if (n < 0)
      var w = 53 - ( (g - s) / 5 | 0);
    else if (n > 364 + s)
      var w = 1;
    else
      var w = (n / 7 | 0) + 1;
    return w;
  };

// Return the name of the weekday
Date.prototype.getNameOfDay =
  function(utc) {
    var d = this.getISODay(utc) - 1;
    return Date.nameOfDays[d];
  };

// Return the name of the month
Date.prototype.getNameOfMonth =
  function(utc) {
    var m = utc ? this.getUTCMonth() : this.getMonth();
    return Date.nameOfMonths[m];
  };

// Rewrite native Date.getTimezoneOffset to return values with correct sign
Date.prototype._getTimezoneOffset = Date.prototype.getTimezoneOffset;
Date.prototype.getTimezoneOffset =
  function() {
    return this._getTimezoneOffset() * -1;
  };

// Retuns true if year is a leap year; otherwise false
Date.prototype.isLeapYear =
  function(utc) {
    var y = utc ? this.getUTCFullYear() : this.getFullYear();
    return !(y % 4) && (y % 100) || !(y % 400) ? true : false;
  };

// Names of the week days
Date.nameOfDays = ['Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday'];




}));
swifty.define( 'js/panels/manage_versions/manage_versions',[
    'jquery',
    'swiftylib/evt',
    'swiftylib/map',
    'js/panels/panel/panel',
    'js/panels/panel_stack/panel_stack_instance',
    'js/panels/yes_no/yes_no',
    'swiftylib/i18n/__',
    'stache!./manage_versions.stache',
    // No return values:
    'css!./manage_versions.css',
    'js/libs/stdlib_date'
], function(
    $, evt, Map, Panel, panelStackInstance, YesNo, __, tmpl
) {
    

    return Panel.extend( {
        'defaults': {
            'tmpl_content': tmpl,
            'title': __( 'Manage versions' ),
            'revisions': new Map()
        }
    }, {
        init: function() {
            var self = this;

            self._super();

            evt( 'get_published_versions' ).then( function( data ) {
                var list = [];
                data = $.parseJSON( data );

                $.each( data.data, function( ii, revisionItem ) {
                    // Format must be like this: 2009/07/12 12:34:56
                    var dateStr = revisionItem.post_date_gmt.replace( /\-/g, '/' );

                    revisionItem.swc_date = new Date( dateStr );
                    revisionItem.swc_date = new Date( revisionItem.swc_date.getTime() + ( revisionItem.swc_date.getTimezoneOffset() * 60000 ) ); // Fix the date so it becomes GMT.
                    revisionItem.swc_date_string = revisionItem.swc_date.format( data.date_format );
                    revisionItem.swc_time_string = revisionItem.swc_date.format( data.time_format );
                    list.push( revisionItem );
                } );
                list = list.sort( function( a, b ) {
                    if (a.ID > b.ID) {
                       return -1;
                    }
                    if (a.ID < b.ID) {
                      return 1;
                    }
                    return 0;
                } );

                self.options.revisions.attr( 'data', list );
            } );
        },

        '.swc_revision_button click': function( el/*, ev*/ ) {
            this.yesNoPanel = panelStackInstance.addPanel( YesNo, {
                'title': __( 'Restore page to this version?' ),
                'yes_name': __( 'Restore this version' ),
                'no_name': __( 'Cancel. Do not restore' ),
                'evt_el': $( el ),
                'yes_icon': '&#xe033;'
            } );
        },

        ' evt_swc_yes': function( el, ev, opts ) {
            var self = this;

            self.markCloseOnFocus();

            self.element.find( '.swc_panel_content' )
                .css( 'font-size', '18px' )
                .html( __( 'Restoring. Please wait...' ) );

            evt( 'restore_page_revision', {
                'revision_id': $( opts.evt_el ).attr( 'data-revision_id' )
            } ).then( function( /*data*/ ) {
                self.yesNoPanel.element.find( '.swc_panel_content' )
                    .css( {
                        'color': '#00a000',
                        'font-weight': 'bold'
                    } )
                    .html( __(
                        'Done! The content of this page is now set to that previous version.<br><br>' +
                        'This version overwrites any autosaved changes made since the last publish.<br><br>' +
                        'If you do not want that use the undo button now.<br><br>' +
                        'The visitors of your site still see the last published version until you publish this one.'
                    ) );
            } );
        },

        ' evt_swc_no': function( /*el, ev, opts*/ ) {
            this.yesNoPanel.closePanel();
        }
    } );
} );

swifty.define('stache!js/panels/move_row/move_row.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/panels/move_row/move_row.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<div class="swc_panel_content_nowrap">\n    <swc_panel_button icon="&#xe02d;" action="up" name="{{__ \'Up\'}}"/>\n    <swc_panel_button icon="&#xe02e;" action="down" name="{{__ \'Down\'}}"/>\n</div>\n' ); return idn; });

swifty.define( 'js/panels/move_row/move_row',[
    'jquery',
    'swiftylib/evt',
    'js/panels/panel/panel',
    'swiftylib/i18n/__',
    'stache!./move_row.stache'
], function(
    $, evt, Panel, __, tmpl
) {
    

    return Panel.extend( {
        'defaults': {
            'tmpl_content': tmpl,
            'title': __( 'Move columns' )
            //'title_tooltip': __( 'You can also move columns, by dragging the symbol at it\'s top right (when this panel is closed.)' ),
        }
    }, {
        'swc_panel_button click': function( $el /*, ev*/ ) {
            var self = this;

            evt( 'swifty_editor_move_row', {
                'move': $el.attr( 'action' ),
                '$row': self.options.$row
            } );
        },

        '.swc_back_button click': function( /*el, ev*/ ) {
            this._super();
        }
    } );
} );


swifty.define('stache!js/panels/background/background.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/panels/background/background.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<div class="swc_panel_form_wrapper">\n    <div class="swc_panel_form_wrapper_inner">\n        <form class="swc_content_form swc_panel_content_nowrap" autocomplete="off">\n    <div class="swc_form_column" style="min-width: 200px;">\n        <div {{#if bg_data.bg_img}}class="swc_bg_button_wrapper"{{/if}}>\n        <swc_icon_button action="bg_image" text="{{__ \'Image\'}}" />\n        {{#if bg_data.bg_img}}\n            <swc_icon_button action="bg_image_remove" icon="&#xe00b;" />\n        {{/if}}\n        </div>\n        <div>\n        <swifty_colorpicker name="swc_bg_color" _value="bg_data.color" label="{{__ \'Color\'}}"/>\n        </div>\n    </div>\n    <div class="swc_form_column">\n        <swifty_form_input name="swc_bg_overlay_trans" _value="{bg_data.bg_overlay_trans}" label="{{__ \'Overlay transparency %\'}}" />\n        <swifty_colorpicker name="swc_bg_overlay_color" _value="bg_data.bg_overlay_color" label="{{__ \'Overlay color\'}}"/>\n    </div>\n    <div class="swc_form_column">\n        <swifty_form_radiobutton name="swc_bg_position_h" _value=\'bg_data.bg_position_h\' values="0^{{__ \'Left\'}}^|0.5^{{__ \'Center\'}}|1^{{__ \'Right\'}}" label="{{__ \'Horizontal position\'}}" direction="vertical"/>\n    </div>\n    <div class="swc_form_column">\n        <swifty_form_radiobutton name="swc_bg_position_v" _value=\'bg_data.bg_position_v\' values="0^{{__ \'Top\'}}^|0.5^{{__ \'Center\'}}|1^{{__ \'Bottom\'}}" label="{{__ \'Vertical position\'}}" direction="vertical"/>\n    </div>\n    <div class="swc_form_column">\n        <swifty_form_radiobutton name="swc_bg_repeat" _value=\'bg_data.bg_repeat\' values="no-repeat^{{__ \'No\'}}^|repeat-x^{{__ \'Horizontally\'}}|repeat-y^{{__ \'Verticaly\'}}|repeat^{{__ \'Both\'}}" label="{{__ \'Repeat\'}}" direction="vertical"/>\n    </div>\n    <div class="swc_form_column">\n        <swifty_form_radiobutton name="swc_bg_size" _value=\'{bg_data.bg_size}\' values="cover^{{__ \'Cover\'}}^|contain^{{__ \'Contain\'}}|custom^{{__ \'Percentage\'}}" label="{{__ \'Zoom\'}}" direction="vertical"/>\n    </div>\n    {{#eq bg_data.bg_size \'custom\'}}\n    <div class="swc_form_column swc_form_inputs_w_100">\n        <swifty_form_input name="swc_bg_size_perc" _value="{bg_data.bg_size_perc}" label="{{__ \'Zoom percentage\'}}" />\n    </div>\n    {{/eq}}\n    <div class="swc_form_column">\n        <swifty_form_radiobutton name="swc_scrolleffect" _value=\'bg_data.scrolleffect\' values="none^{{__ \'None\'}}^|parallax0^{{__ \'Fixed\'}}|parallax1^{{__ \'Moving\'}}" label="{{__ \'Parallax effect\'}}" direction="vertical"/>\n    </div>\n    {{#eq bg_data.scrolleffect \'none\'}}\n    {{else}}\n    <div class="swc_form_column swc_form_inputs_w_100">\n        <swifty_form_input name="swc_se_factor" _value="bg_data.se_factor" label="{{__ \'Effect factor\'}}" />\n        <swifty_form_input name="swc_se_offset" _value="bg_data.se_offset" label="{{__ \'Effect offset\'}}" />\n    </div>\n    {{/eq}}\n</div>\n</div>\n</div>\n' ); return idn; });


swifty.define('css!js/panels/background/background',[],function(){});
swifty.define( 'js/panels/background/background',[
    'jquery',
    'swiftylib/evt',
    'swiftylib/map',
    'js/panels/panel/panel',
    'swiftylib/i18n/__',
    'stache!./background.stache',
    'swiftylib/media_manager',
    'css!js/panels/background/background.css'
], function(
    $, evt, Map, Panel, __, tmpl, MediaManager
) {
    

    return Panel.extend( {
        'defaults': {
            'tmpl_content': tmpl,
            'title': __( 'Set background' )
        }
    }, {
        init: function() {
            var self = this;

            self.options.bg_data = new Map( {
                'color': self.options.color,
                'bg_img': self.options.bg_img,
                'scrolleffect': self.options.scrolleffect,
                'se_factor': self.options.se_factor,
                'se_offset': self.options.se_offset,
                'bg_position_h': self.options.bg_position_h,
                'bg_position_v': self.options.bg_position_v,
                'bg_repeat': self.options.bg_repeat,
                'bg_size': self.options.bg_size,
                'bg_size_perc': self.options.bg_size_perc,
                'bg_overlay_trans': self.options.bg_overlay_trans,
                'bg_overlay_color': self.options.bg_overlay_color
            } );

            self._super();
        },

        '{bg_data} change': function( dunno, ev, attr, how, newVal/*, oldVal*/ ) {
            var self = this;

            evt( 'do_change_background', {
                'main_key': self.options.main_key,
                'key': attr,
                'val': newVal
            } );
        },

        '.swc_bg_image click': function() {
            this.select_image();
        },

        '.swc_bg_image_remove click': function() {
            this.options.bg_data.attr( 'bg_img', '' );
        },

        select_image: function() {
            var self = this;
            var $newEl = $( '<div></div>' ).appendTo( this.element );
            var dfd = new $.Deferred();

            $.post(
                scc_data.ajax_url,
                {
                    'action': 'get_attachment_id_from_url',
                    'url': self.options.bg_data.attr( 'bg_img' ),
                    'id': scc_data.page_id,
                    'ajax_nonce': scc_data.ajax_nonce
                }
            ).done( function( attachmentId ) {
                new MediaManager( $newEl, {
                    'selected_ids': attachmentId || '',
                    'multiple': false,
                    'dfd': dfd,
                    'swifty_mode': ( ( scc_data.ss2_hosting_name === 'AMH' ) ? 1 : 0 ),
                    'media_image_prefix': scc_data.media_image_prefix
                } );

                dfd.then( function( data ) {
                    if( data && data.act === 'insert' ) {
                        if( $.isArray( data.attributes ) && data.attributes.length ) {

                            var swifty_attachments = [];

                            // when swifty_cmd==='img_list' then import as attachment
                            $.each( data.attributes, function( index, image ) {
                                if( image.swifty_cmd === 'img_list' ) {
                                    swifty_attachments.push( image.url );
                                }
                            } );

                            if( swifty_attachments.length ) {
                                // show feedback spinner
                                $( '#swc-spinner' ).show();
                                $( '#swc-screen-cover' ).show();

                                $.post(
                                    scc_data.ajax_url,
                                    {
                                        'action': 'insert_attachment_from_url',
                                        'urls': JSON.stringify( swifty_attachments ),
                                        'id': scc_data.page_id,
                                        'ajax_nonce': scc_data.ajax_nonce
                                    }
                                ).done( function( attachments ) {
                                        if( attachments && ( attachments.length > 0 )) {
                                            self.options.bg_data.attr( 'bg_img', attachments[ 0 ].url );
                                        }
                                    }
                                ).always( function() {
                                        // hide feedback spinner
                                        $( '#swc-spinner' ).hide();
                                        $( '#swc-screen-cover' ).hide();
                                    }
                                );
                            } else {
                                self.options.bg_data.attr( 'bg_img', data.attributes[ 0 ].url );
                            }
                        }
                    }

                    $newEl.remove();   // Destroy the MediaManager
                } );
            } );
        }

    } );
} );


swifty.define('stache!js/panels/edit_row/edit_row.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/panels/edit_row/edit_row.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<div class="swc_panel_form_tabs_wrapper">\n    <div class="swc_panel_form_wrapper">\n        <div class="swc_panel_form_wrapper_inner">\n            <form class="swc_content_form swc_panel_content_nowrap" autocomplete="off">\n                <div class="swc_panel_form_tab_pane swc_panel_form_content swc_selected">\n                    <div class="swc_form_column">\n                        <swc_icon_button action="n_columns" text="{{__ \'Change columns layout\'}}" />\n                    </div>\n                </div>\n\n                <div class="swc_panel_form_tab_pane swc_panel_form_position">\n                    <div class="swc_form_column swc_form_inputs_w_100">\n                        <swifty_form_input name="swc_between_cols" _value=\'{row_data.swc_between_cols}\' label="{{__ \'Margin between columns\'}}" />\n                    </div>\n                    <div class="swc_form_column swc_form_inputs_w_100">\n                        <swifty_form_radiobutton name="swc_breakout" _value=\'{row_data.swc_breakout}\' values="none^{{__ \'Normal\'}}^|breakout^{{__ \'Full width\'}}" label="{{__ \'Breakout\'}}" />\n                        <swifty_form_radiobutton name="swc_content_breakout" _value=\'{row_data.swc_content_breakout}\' values="none^{{__ \'Normal\'}}^|breakout^{{__ \'Full width\'}}" label="{{__ \'Content breakout\'}}" />\n                    </div>\n                    <div class="swc_form_column swc_form_inputs_w_100">\n                        <swifty_form_input name="swc_margin_top" _value="row_data.swc_margin_top" label="{{__ \'Margin top\'}}" class="swifty_form_line_below"/>\n                        <swifty_form_input name="swc_margin_bottom" _value="row_data.swc_margin_bottom" label="{{__ \'Margin bottom\'}}" />\n                    </div>\n                    <div class="swc_form_column swc_form_inputs_w_100">\n                        <swifty_form_input name="swc_padding_left" _value="row_data.swc_padding_left" label="{{__ \'Padding left\'}}" />\n                        <swifty_form_input name="swc_padding_right" _value="row_data.swc_padding_right" label="{{__ \'Padding right\'}}" />\n                    </div>\n                    <div class="swc_form_column swc_form_inputs_w_100">\n                        <swifty_form_input name="swc_padding_top" _value="row_data.swc_padding_top" label="{{__ \'Padding top\'}}" />\n                        <swifty_form_input name="swc_padding_bottom" _value="row_data.swc_padding_bottom" label="{{__ \'Padding bottom\'}}" />\n                    </div>\n                    <div class="swc_form_column swc_form_inputs_w_100">\n                        <swifty_form_input name="swc_col_padding_left" _value="row_data.swc_col_padding_left" label="{{__ \'Column padding left\'}}" />\n                        <swifty_form_input name="swc_col_padding_right" _value="row_data.swc_col_padding_right" label="{{__ \'Column padding right\'}}" />\n                    </div>\n                    <div class="swc_form_column swc_form_inputs_w_100">\n                        <swifty_form_input name="swc_col_padding_top" _value="row_data.swc_col_padding_top" label="{{__ \'Column padding top\'}}" />\n                        <swifty_form_input name="swc_col_padding_bottom" _value="row_data.swc_col_padding_bottom" label="{{__ \'Column padding bottom\'}}" />\n                    </div>\n                    <div class="swc_form_column swc_form_inputs_w_100">\n                        <swifty_form_input name="swc_col_min_height" _value="row_data.swc_col_min_height" label="{{__ \'Minimum height\'}}" />\n                        <swifty_form_input name="swc_max_height" _value="row_data.swc_max_height" label="{{__ \'Maximum height\'}}" />\n                    </div>\n                    <div class="swc_form_column swc_form_inputs_w_100">\n                        <swifty_form_radiobutton name="swc_col_pos_vert" _value=\'{row_data.swc_col_pos_vert}\' values="top^{{__ \'Top\'}}^|center^{{__ \'Center\'}}|bottom^{{__ \'Bottom\'}}" label="{{__ \'Center content vertically\'}}" class="swifty_form_line_below"/>\n                        <swifty_form_radiobutton name="swc_overflow" _value=\'{row_data.swc_overflow}\' values="auto^{{__ \'Show scrollbar\'}}^|hidden^{{__ \'Crop\'}}" label="{{__ \'If content too high\'}}" />\n                    </div>\n                </div>\n\n                <div class="swc_panel_form_tab_pane swc_panel_form_style">\n                    <div class="swc_form_column">\n                        <swc_icon_button action="change_background" text="{{__ \'Background\'}}" />\n                        <swc_icon_button action="change_column_background" text="{{__ \'Column background\'}}" />\n                    </div>\n                    <div class="swc_form_column">\n                        <swifty_form_textarea name="swc_custom_css" _value="row_data.swc_custom_css" label="{{__ \'Custom css\'}}" />\n                    </div>\n                </div>\n            </form>\n        </div>\n    </div>\n</div>\n' ); return idn; });


swifty.define('stache!js/panels/edit_row/edit_row_tabs.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/panels/edit_row/edit_row_tabs.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<div class="swc_panel_form_tabs {{#is swifty_gui_mode \'advanced\'}}{{else}}swc_panel_frm_tabs_hidden{{/is}}">\n    <div class="swc_panel_form_tabs_inner">\n        <div class="swc_panel_form_tab swc_selected" data-swc_for=".swc_panel_form_content">{{__ "Content" }}</div>\n        <div class="swc_panel_form_tab" data-swc_for=".swc_panel_form_position">{{__ "Layout" }}</div>\n        <div class="swc_panel_form_tab" data-swc_for=".swc_panel_form_style">{{__ "Style" }}</div>\n    </div>\n</div>\n' ); return idn; });

swifty.define( 'js/panels/edit_row/edit_row',[
    'jquery',
    'swiftylib/evt',
    'swiftylib/map',
    'js/panels/panel/panel',
    'js/panels/panel_stack/panel_stack_instance',
    'js/panels/pick_columns/pick_columns',
    'js/panels/background/background',
    'swiftylib/i18n/__',
    'stache!./edit_row.stache',
    'stache!./edit_row_tabs.stache'
], function(
    $, evt, Map, Panel, panelStackInstance, PickColumns, Background, __, tmpl, tmplTabs
) {
    

    return Panel.extend( {
        'defaults': {
            'tmpl_content': tmpl,
            'tmpl_tabs': tmplTabs,
            'title': __( 'Edit columns' ),
            'swifty_gui_mode': scc_data.swifty_gui_mode,
            'default_attributes_grid': {
                'swc_breakout': 'none',
                'swc_content_breakout': 'none',
                'swc_pos_vert': 'top',
                'swc_overflow': 'auto',
                'swc_margin_top': '0',
                'swc_margin_bottom': '20',
                'swc_padding_left': '0',
                'swc_padding_right': '0',
                'swc_padding_top': '0',
                'swc_padding_bottom': '0',
                'swc_min_height': '0',
                'swc_max_height': '0',
                'swc_bg_color': '',
                'swc_bg_img': '',
                'swc_custom_css': '',
                'swc_temporary': '',
                'swc_scrolleffect': 'none',
                'swc_se_factor': 1,
                'swc_se_offset': 0,
                'swc_bg_position_h': 0.5,
                'swc_bg_position_v': 0.5,
                'swc_bg_repeat': 'no-repeat',
                'swc_bg_size': 'cover',
                'swc_bg_size_perc': '100',
                'swc_bg_overlay_trans': 100,
                'swc_bg_overlay_color': '#000000'
            },
            'default_attributes_column': {
                'swc_between_cols': '20',
                'swc_bg_color': '',
                'swc_padding_top': '0',
                'swc_padding_bottom': '0',
                'swc_padding_left': '0',
                'swc_padding_right': '0',
                'swc_min_height': '0',
                // 'swc_max_height': '0',
                'swc_pos_vert': 'top',
                'swc_bg_img': '',
                'swc_temporary': '',
                'swc_scrolleffect': 'none',
                'swc_se_factor': 1,
                'swc_se_offset': 0,
                'swc_bg_position_h': 0.5,
                'swc_bg_position_v': 0.5,
                'swc_bg_repeat': 'no-repeat',
                'swc_bg_size': 'cover',
                'swc_bg_size_perc': '100',
                'swc_bg_overlay_trans': 100,
                'swc_bg_overlay_color': '#000000'
            }
        }
    }, {
        init: function() {
            var self = this;

            var $row = self.options.$row;
            var $col = $row.find( '> .swc_grid_colwrapper:first .swc_grid_column' );
            var dataRow = $.parseJSON( $row.attr( 'data-grid_data' ) );
            var data = $.parseJSON( $col.attr( 'data-grid_data' ) );

            // merge both the grid and column attributes into row_data using their default values
            self.options.row_data = new Map( $.extend( true,
                {},
                self.options.default_attributes_grid,
                dataRow,
                {
                    'swc_between_cols': data.swc_between_cols ? data.swc_between_cols : self.options.default_attributes_column.swc_between_cols,
                    'swc_col_bg_color': data.swc_bg_color ? data.swc_bg_color : self.options.default_attributes_column.swc_bg_color,
                    'swc_col_bg_img': data.swc_bg_img ? data.swc_bg_img : self.options.default_attributes_column.swc_bg_img,
                    'swc_col_padding_top': data.swc_padding_top ? data.swc_padding_top : self.options.default_attributes_column.swc_padding_top,
                    'swc_col_padding_bottom': data.swc_padding_bottom ? data.swc_padding_bottom : self.options.default_attributes_column.swc_padding_bottom,
                    'swc_col_padding_left': data.swc_padding_left ? data.swc_padding_left : self.options.default_attributes_column.swc_padding_left,
                    'swc_col_padding_right': data.swc_padding_right ? data.swc_padding_right : self.options.default_attributes_column.swc_padding_right,
                    'swc_col_min_height': data.swc_min_height ? data.swc_min_height : self.options.default_attributes_column.swc_min_height,
                    // 'swc_col_max_height': data.swc_max_height ? data.swc_max_height : self.options.default_attributes_column.swc_max_height,
                    'swc_col_pos_vert': data.swc_pos_vert ? data.swc_pos_vert : self.options.default_attributes_column.swc_pos_vert,
                    'swc_col_scrolleffect': data.swc_scrolleffect ? data.swc_scrolleffect : self.options.default_attributes_column.swc_scrolleffect,
                    'swc_col_se_factor': data.swc_se_factor ? data.swc_se_factor : self.options.default_attributes_column.swc_se_factor,
                    'swc_col_se_offset': data.swc_se_offset ? data.swc_se_offset : self.options.default_attributes_column.swc_se_offset,
                    'swc_col_bg_position_h': data.swc_bg_position_h ? data.swc_bg_position_h : self.options.default_attributes_column.swc_bg_position_h,
                    'swc_col_bg_position_v': data.swc_bg_position_v ? data.swc_bg_position_v : self.options.default_attributes_column.swc_bg_position_v,
                    'swc_col_bg_repeat': data.swc_bg_repeat ? data.swc_bg_repeat : self.options.default_attributes_column.swc_bg_repeat,
                    'swc_col_bg_size': data.swc_bg_size ? data.swc_bg_size : self.options.default_attributes_column.swc_bg_size,
                    'swc_col_bg_size_perc': data.swc_bg_size_perc ? data.swc_bg_size_perc : self.options.default_attributes_column.swc_bg_size_perc,
                    'swc_col_bg_overlay_trans': data.swc_bg_overlay_trans ? data.swc_bg_overlay_trans : self.options.default_attributes_column.swc_bg_overlay_trans,
                    'swc_col_bg_overlay_color': data.swc_bg_overlay_color ? data.swc_bg_overlay_color : self.options.default_attributes_column.swc_bg_overlay_color
                } )
            );

            self._super();
            self.options.map.attr( 'show_undo_redo', false );

            $( '.swc_panel_form_tab:first' ).click();
            $( '.swc_panel_form_tab[data-swc_for=".swc_panel_form_' + this.options.mode + '"]' ).click();

            evt( 'swifty_editor_set_focus', { 'focus': 0 } );
            evt( 'swifty_editor_unlock_selection', { '$asset': this.options.$row } );
            evt( 'swifty_editor_set_asset_in_edit_mode', { '$asset': this.options.$row } );
        },

        '.swc_back_button click': function( /*el, ev*/ ) {
            evt( 'swifty_editor_set_focus', { 'focus': 1 } );
            evt( 'swifty_editor_set_cursor', { '$asset': this.options.$row } );
            //evt( 'swifty_editor_set_asset_in_edit_mode' );
            //evt( 'reset_panel_stack' );

            this._super();
        },

        '.swc_panel_form_tab click': function( el/*, ev*/ ) {
            // Show clicked tab as selected
            $( this.element ).find( '.swc_panel_form_tab' ).removeClass( 'swc_selected' );
            $( el ).addClass( 'swc_selected' );

            // Show correct tab pane
            $( this.element ).find( '.swc_panel_form_tab_pane' ).removeClass( 'swc_selected' );
            $( this.element ).find( $( el ).attr( 'data-swc_for' ) ).addClass( 'swc_selected' );

            evt( 'fix_panel_heights', { 'redraw_element': $( this.element ).find( $( el ).attr( 'data-swc_for' ) ) } );
        },

        '.swc_n_columns click': function() {
            var self = this;

            panelStackInstance.addPanel( PickColumns, {
                '$row': self.options.$row,
                'swc_between_cols': self.options.row_data.swc_between_cols
            } );
        },

        '.swc_change_background click': function() {
            var self = this;

            panelStackInstance.addPanel( Background, {
                'main_key': 'main',
                'color': self.options.row_data.swc_bg_color,
                'bg_img': self.options.row_data.swc_bg_img,
                'scrolleffect': self.options.row_data.swc_scrolleffect,
                'se_factor': self.options.row_data.swc_se_factor,
                'se_offset': self.options.row_data.swc_se_offset,
                'bg_position_h': self.options.row_data.swc_bg_position_h,
                'bg_position_v': self.options.row_data.swc_bg_position_v,
                'bg_repeat': self.options.row_data.swc_bg_repeat,
                'bg_size': self.options.row_data.swc_bg_size,
                'bg_size_perc': self.options.row_data.swc_bg_size_perc,
                'bg_overlay_trans': self.options.row_data.swc_bg_overlay_trans,
                'bg_overlay_color': self.options.row_data.swc_bg_overlay_color
            } );
        },

        '.swc_change_column_background click': function() {
            var self = this;

            panelStackInstance.addPanel( Background, {
                'main_key': 'column',
                'color': self.options.row_data.swc_col_bg_color,
                'bg_img': self.options.row_data.swc_col_bg_img,
                'scrolleffect': self.options.row_data.swc_col_scrolleffect,
                'se_factor': self.options.row_data.swc_col_se_factor,
                'se_offset': self.options.row_data.swc_col_se_offset,
                'bg_position_h': self.options.row_data.swc_col_bg_position_h,
                'bg_position_v': self.options.row_data.swc_col_bg_position_v,
                'bg_repeat': self.options.row_data.swc_col_bg_repeat,
                'bg_size': self.options.row_data.swc_col_bg_size,
                'bg_size_perc': self.options.row_data.swc_col_bg_size_perc,
                'bg_overlay_trans': self.options.row_data.swc_col_bg_overlay_trans,
                'bg_overlay_color': self.options.row_data.swc_col_bg_overlay_color
            } );
        },

        '{window} evt_swc_do_change_background': function( el, ev, opts ) {
            var self = this;

            if( opts.key === 'color' ) {
                if( opts.main_key === 'column' ) {
                    self.options.row_data.attr( 'swc_col_bg_color', opts.val );
                } else {
                    self.options.row_data.attr( 'swc_bg_color', opts.val );
                }
            }

            $.each( [ 'bg_img', 'scrolleffect', 'se_factor', 'se_offset', 'bg_position_h', 'bg_position_v', 'bg_repeat', 'bg_size', 'bg_size_perc', 'bg_overlay_trans', 'bg_overlay_color' ], function( ii, ky ) {
                if( opts.key === ky ) {
                    if( opts.main_key === 'column' ) {
                        self.options.row_data.attr( 'swc_col_' + ky, opts.val );
                    } else {
                        self.options.row_data.attr( 'swc_' + ky, opts.val );
                    }
                }
            } );
        },

        '{row_data} change': function( dunno, ev, attr, how, newVal/*, oldVal*/ ) {
            var self = this,
                save_needed = true;
            switch( attr ) {
                case 'swc_between_cols':
                    self.changeColMargin( newVal );
                    break;
                case 'swc_bg_color':
                    self.changeBGColor( newVal );
                    break;
                case 'swc_col_bg_color':
                    self.changeColBGColor( newVal );
                    break;
                case 'swc_bg_img':
                    self.changeBGImg( newVal, attr);
                    break;
                case 'swc_bg_overlay_trans':
                    self.changeBGImg( newVal, attr );
                    break;
                case 'swc_bg_overlay_color':
                    self.changeBGImg( newVal, attr );
                    break;
                case 'swc_bg_position_h':
                    self.changeBGImg( newVal, attr );
                    break;
                case 'swc_bg_position_v':
                    self.changeBGImg( newVal, attr );
                    break;
                case 'swc_bg_repeat':
                    self.changeBGImg( newVal, attr );
                    break;
                case 'swc_bg_size':
                    self.changeBGImg( newVal, attr );
                    break;
                case 'swc_bg_size_perc':
                    self.changeBGImg( newVal, attr );
                    break;
                case 'swc_col_bg_img':
                    self.changeColBGImg( newVal, attr );
                    break;
                case 'swc_col_bg_overlay_trans':
                    self.changeColBGImg( newVal, attr );
                    break;
                case 'swc_col_bg_overlay_color':
                    self.changeColBGImg( newVal, attr );
                    break;
                case 'swc_col_bg_position_h':
                    self.changeColBGImg( newVal, attr );
                    break;
                case 'swc_col_bg_position_v':
                    self.changeColBGImg( newVal, attr );
                    break;
                case 'swc_col_bg_repeat':
                    self.changeColBGImg( newVal, attr );
                    break;
                case 'swc_col_bg_size':
                    self.changeColBGImg( newVal, attr );
                    break;
                case 'swc_col_bg_size_perc':
                    self.changeColBGImg( newVal, attr );
                    break;
                case 'swc_breakout':
                    self.changeBreakout( newVal, 'swc_breakout' );
                    break;
                case 'swc_content_breakout':
                    self.changeBreakout( newVal, 'swc_content_breakout' );
                    break;
                case 'swc_margin_top':
                    self.changeAttrPx( 'margin-top', attr, newVal );
                    break;
                case 'swc_margin_bottom':
                    self.changeAttrPx( 'margin-bottom', attr, newVal );
                    break;
                case 'swc_padding_top':
                    self.changeAttrPx( 'padding-top', attr, newVal );
                    break;
                case 'swc_padding_bottom':
                    self.changeAttrPx( 'padding-bottom', attr, newVal );
                    break;
                case 'swc_padding_left':
                    self.changeAttrPx( 'padding-left', attr, newVal );
                    break;
                case 'swc_padding_right':
                    self.changeAttrPx( 'padding-right', attr, newVal );
                    break;
                case 'swc_col_padding_top':
                    self.changeColAttrPx( 'padding-top', 'swc_padding_top', newVal );
                    break;
                case 'swc_col_padding_bottom':
                    self.changeColAttrPx( 'padding-bottom', 'swc_padding_bottom', newVal );
                    break;
                case 'swc_col_padding_left':
                    self.changeColAttrPx( 'padding-left', 'swc_padding_left', newVal );
                    break;
                case 'swc_col_padding_right':
                    self.changeColAttrPx( 'padding-right', 'swc_padding_right', newVal );
                    break;
                case 'swc_col_min_height':
                    if( parseInt( newVal, 10 ) > 0 ) {
                        self.changeAttrPx( 'min-height', 'swc_min_height', newVal );
                        self.changeColAttrPx( 'min-height', 'swc_min_height', newVal );
                    } else {
                        self.changeAttr( '', 'min-height', 'swc_min_height', newVal );
                        self.changeColAttr( '', 'min-height', 'swc_min_height', '' );
                    }
                    break;
                case 'swc_max_height':
                    // We decided the max height set on rows must NOT be applied to columns.
                    // When we want to add max height to columns later on, we MUST use another attribute name ,because user now already have this attribute set to existing columns, but should be ignores.
                    self.changeHeightAndOverflow( newVal, attr );
                    break;
                case 'swc_overflow':
                    self.changeHeightAndOverflow( newVal, attr );
                    break;
                case 'swc_col_pos_vert':
                    if( newVal === 'center' || newVal === 'bottom' ) {
                        self.changeColInnerAttr( 'flex', 'display', 'swc_pos_vert', newVal );
                        self.changeColInnerAttr( 'column', 'flex-direction', 'swc_pos_vert', newVal );
                        self.changeColInnerAttr( newVal === 'bottom' ? 'flex-end' : newVal, 'justify-content', 'swc_pos_vert', newVal );
                    } else {
                        self.changeColInnerAttr( '', 'display', 'swc_pos_vert', '' );
                        self.changeColInnerAttr( '', 'flex-direction', 'swc_pos_vert', '' );
                        self.changeColInnerAttr( '', 'justify-content', 'swc_pos_vert', '' );
                    }
                    break;
                case 'swc_custom_css':
                    self.changeCustomCss( newVal );
                    break;
                case 'swc_scrolleffect':
                    self.changeScrolleffect( newVal, 'swc_scrolleffect' );
                    break;
                case 'swc_se_factor':
                    self.changeScrolleffect( newVal, 'swc_se_factor' );
                    break;
                case 'swc_se_offset':
                    self.changeScrolleffect( newVal, 'swc_se_offset' );
                    break;
                case 'swc_col_scrolleffect':
                    self.changeColScrolleffect( newVal, attr );
                    break;
                case 'swc_col_se_factor':
                    self.changeColScrolleffect( newVal, attr );
                    break;
                case 'swc_col_se_offset':
                    self.changeColScrolleffect( newVal, attr );
                    break;
                default:
                    save_needed = false;
            }
            // Any change will remove the temporary attribute on row and columns and trigger a save.
            if( save_needed ) {
                var $row = self.options.$row;
                self.setGridData( $row, 'swc_temporary', '' );
                self.setAllColData( '', '', 'swc_temporary', '', 0 );

                evt( 'swifty_editor_trigger_save', {} );
            }
        },

        setGridData: function( $el, key, val ) {
            var self = this;
            var data = $.parseJSON( $el.attr( 'data-grid_data' ) );

            // only store val when different from default
            if( ( key in self.options.default_attributes_grid ) &&
                ( ( self.options.default_attributes_grid[ key ] === val ) || ( val === '' ) ) ) {
                delete( data[ key ] );
            } else {
                data[ key ] = val;
            }
            $el.attr( 'data-grid_data', JSON.stringify( data ) );
        },

        '{window} evt_swc_do_change_col_margin': function( el, ev, opts ) {
            var self = this;
            self.doChangeColMargin( opts.$row, opts.value );
        },

        changeColMargin: function( newVal ) {
            var self = this;
            var $row = self.options.$row;

            self.doChangeColMargin( $row, newVal );
        },

        doChangeColMargin: function( $row, newVal ) {
            var self = this;
            var nrColsNow = $row.find( '> .swc_grid_colwrapper' ).length;

            var val = parseInt( newVal, 10 );
            if( ! val > 0 ) {
                val = 0;
            }

            $row.find( '> .swc_grid_colwrapper' ).each( function( i, el ) {

                // set the swc_between_cols attr to 0 for the last column
                var val2 = val;
                if( i === nrColsNow - 1 ) {
                    val2 = 0;
                }
                self.setColData( $( el ), val2 + 'px', 'margin-right', 'swc_between_cols', '' + val2, 0 );
            } );
        },

        changeAttrPx: function( key, attr, newVal ) {
            var val = parseInt( newVal, 10 );
            if( ! val > 0 ) {
                val = 0;
            }
            val += 'px';

            this.changeAttr( val, key, attr, newVal );
        },

        changeAttr: function( val, key, attr, newVal ) {
            var self = this;
            var $row = self.options.$row;

            $row.css( key, val );

            self.setGridData( $row, attr, newVal );

            // Restore breakout
            $row.attr( 'data-' + attr, newVal );
            var data = $.parseJSON( $row.attr( 'data-grid_data' ) );

            evt( 'swifty_set_breakout', {
                row: $row[ 0 ],
                breakout: data.swc_breakout === 'breakout' ? 1 : 0,
                contentBreakout:  data.swc_content_breakout === 'breakout' ? 1 : 0 } );
        },

        changeColAttrPx: function( key, attr, newVal ) {
            var val = parseInt( newVal, 10 );
            if( ! val > 0 ) {
                val = 0;
            }
            val += 'px';

            this.changeColAttr( val, key, attr, newVal );
        },

        changeColAttr: function( val, key, attr, newVal ) {
            this.setAllColData( val, key, attr, newVal, 0 );
        },

        changeColInnerAttr: function( val, key, attr, newVal ) {
            this.setAllColInnerData( val, key, attr, newVal );
        },

        changeHeightAndOverflow: function( newVal, attr ) {
            var self = this;
            var $row = self.options.$row;
            var rowData = self.options.row_data;
            var maxHeight = parseInt( rowData.attr( 'swc_max_height' ), 10 );
            var overflow = rowData.attr( 'swc_overflow' );

            if( maxHeight > 0 ) {
                self.changeAttrPx( 'max-height', 'swc_max_height', maxHeight + '' );
                self.changeAttr( overflow, 'overflow-y', 'swc_overflow', overflow );
                $row.css( 'overflow-x', 'hidden' );
            } else {
                self.changeAttr( '', 'max-height', 'swc_max_height', '' );
                self.changeAttr( 'visible', 'overflow-y', 'swc_overflow', overflow );
                $row.css( 'overflow-x', 'visible' );
            }
        },

        changeBGColor: function( newVal ) {
            var self = this;
            var $row = self.options.$row;

            $row.css( 'background-color', newVal );

            self.setGridData( $row, 'swc_bg_color', newVal );
        },

        changeColBGColor: function( newVal ) {
            var self = this;

            self.setAllColData( newVal, 'background-color', 'swc_bg_color', newVal, 0 );
        },

        setAllColData: function( val, cssKey, key, val2, mod ) {
            var self = this;

            self.options.$row.find( '> .swc_grid_colwrapper' ).each( function( i, el ) {
                self.setColData( $( el ), val, cssKey, key, val2, mod );
            } );
        },

        setAllColInnerData: function( val, cssKey, key, val2 ) {
            var self = this;

            self.options.$row.find( '> .swc_grid_colwrapper' ).each( function( i, el ) {
                self.setColData( $( el ).find( '.swc_grid_column' ), val, cssKey, key, val2, 0 );
            } );
        },

        setColData: function( $el, val, cssKey, key, val2, mod ) {
            var self = this;

            if( cssKey && cssKey !== '' ) {
                if( mod === 1 && $el.hasClass( 'swc_grid_colwrapper' ) ) {
                    var $colEffect = $el.find( '.swc_rw_in_effect' );
                    if( $colEffect.length <= 0 ) {
                        $colEffect = $( '<div class="swc_rw_in_effect"></div>' ).prependTo( $el );
                    }
                    $colEffect.css( cssKey, val );
                } else {
                    $el.css( cssKey, val );
                }
            }

            if( key && key !== '' ) {
                var $col = $el;
                if( ! $col.hasClass( 'swc_grid_column' ) ) {
                    $col = $col.find( '.swc_grid_column' );
                }
                var data = $.parseJSON( $col.attr( 'data-grid_data' ) );
                // only store val when different from default
                if( ( key in self.options.default_attributes_column ) &&
                    ( ( self.options.default_attributes_column[ key ] === val2 ) || ( val2 === '' ) ) ) {
                    delete( data[ key ] );
                } else {
                    data[ key ] = '' + val2;
                }

                $col.attr( 'data-grid_data', JSON.stringify( data ) );
            }
        },

        changeBGImg: function( newVal, key ) {
            var self = this;
            var $row = self.options.$row;
            var rowData = self.options.row_data;
            var bgImg = rowData.attr( 'swc_bg_img' );
            var bgSize = rowData.attr( 'swc_bg_size' );
            var bgSize2 = rowData.attr( 'swc_bg_size' );
            var bgSizePerc = rowData.attr( 'swc_bg_size_perc' );
            if( bgSize !== 'cover' && bgSize !== 'contain' ) {
                bgSize2 = bgSizePerc + '%';
            }

            $row.css( 'background-image', 'url("' + bgImg + '")' );
            $row.css( 'background-size', 'cover' );
            $row.css( 'background-position', ( 100.0 * parseFloat( rowData.attr( 'swc_bg_position_h' ) ) ) + '% ' + ( 100.0 * parseFloat( rowData.attr( 'swc_bg_position_v' ) ) ) + '%' );
            $row.css( 'background-repeat', rowData.attr( 'swc_bg_repeat' ) );
            $row.css( 'background-size', bgSize2 );
            
            var $rowEffect = $row.find( '.swc_rw_in_effect' );
            if( $rowEffect.length <= 0 ) {
                $rowEffect = $( '<div class="swc_rw_in_effect"></div>' ).prependTo( $row );
            }
            $rowEffect.css( 'opacity', 1 - parseFloat( rowData.attr( 'swc_bg_overlay_trans' ) ) / 100.0 );
            $rowEffect.css( 'background-color', rowData.attr( 'swc_bg_overlay_color' ) );

            self.setGridData( $row, key, newVal );
        },

        changeColBGImg: function( newVal, key ) {
            var self = this;
            var rowData = self.options.row_data;
            var bgImg = rowData.attr( 'swc_col_bg_img' );
            var bgPositionH = rowData.attr( 'swc_col_bg_position_h' );
            var bgPositionV = rowData.attr( 'swc_col_bg_position_v' );
            var bgRepeat = rowData.attr( 'swc_col_bg_repeat' );
            var bgSize = rowData.attr( 'swc_col_bg_size' );
            var bgSize2 = rowData.attr( 'swc_col_bg_size' );
            var bgSizePerc = rowData.attr( 'swc_col_bg_size_perc' );
            if( bgSize !== 'cover' && bgSize !== 'contain' ) {
                bgSize2 = bgSizePerc + '%';
            }
            var bgOverlayTrans = rowData.attr( 'swc_col_bg_overlay_trans' );
            var bgOverlayColor = rowData.attr( 'swc_col_bg_overlay_color' );

            self.setAllColData( 'url("' + bgImg + '")', 'background-image', 'swc_bg_img', bgImg, 0 );
            self.setAllColData( 'cover', 'background-size', '', newVal, 0 );
            self.setAllColData( ( 100.0 * parseFloat( bgPositionH ) ) + '% ' + ( 100.0 * parseFloat( bgPositionV ) ) + '%', 'background-position', 'swc_bg_position_h', bgPositionH, 0 );
            self.setAllColData( ( 100.0 * parseFloat( bgPositionH ) ) + '% ' + ( 100.0 * parseFloat( bgPositionV ) ) + '%', 'background-position', 'swc_bg_position_v', bgPositionV, 0 );
            self.setAllColData( bgRepeat, 'background-repeat', 'swc_bg_repeat', bgRepeat, 0 );
            self.setAllColData( bgSize2, 'background-size', 'swc_bg_size', bgSize, 0 );
            self.setAllColData( bgSize2, 'background-size', 'swc_bg_size_perc', bgSizePerc, 0 );
            self.setAllColData( 1 - parseFloat( bgOverlayTrans ) / 100.0, 'opacity', 'swc_bg_overlay_trans', bgOverlayTrans, 1 );
            self.setAllColData( bgOverlayColor, 'background-color', 'swc_bg_overlay_color', bgOverlayColor, 1 );
        },

        changeBreakout: function( newVal, key ) {
            var self = this;
            var $row = self.options.$row;

            self.setGridData( $row, key, newVal );

            var data = $.parseJSON( $row.attr( 'data-grid_data' ) );

            evt( 'swifty_set_breakout', {
                row: $row[ 0 ],
                breakout: data.swc_breakout === 'breakout' ? 1 : 0,
                contentBreakout:  data.swc_content_breakout === 'breakout' ? 1 : 0 } );
        },

        changeScrolleffect: function( newVal, key ) {
            var self = this;
            var $row = self.options.$row;
            var rowData = self.options.row_data;

            self.setGridData( $row, key, newVal );

            evt( 'swifty_reset_scrolleffect', 1 );
            
            var scrollEffect = rowData.attr( 'swc_scrolleffect' );
            if( scrollEffect === 'none' ) {
                $row.removeAttr( 'data-swc_scrolleffect' );
            } else {
                var obj = {
                    'effect': scrollEffect,
                    'factor': rowData.attr( 'swc_se_factor' ),
                    'offset': rowData.attr( 'swc_se_offset' )
                };

                $row.attr( 'data-swc_scrolleffect', JSON.stringify( obj ) );
            }

            evt( 'swifty_update_scrolleffect' );
        },

        changeColScrolleffect: function( newVal, key ) {
            var self = this;
            var rowData = self.options.row_data;
            var scrollEffect = rowData.attr( 'swc_col_scrolleffect' );
            var seFactor = rowData.attr( 'swc_col_se_factor' );
            var seOffset = rowData.attr( 'swc_col_se_offset' );

            self.setAllColData( '', '', 'swc_scrolleffect', scrollEffect, 0 );
            self.setAllColData( '', '', 'swc_se_factor', seFactor, 0 );
            self.setAllColData( '', '', 'swc_se_offset', seOffset, 0 );

            self.options.$row.find( '> .swc_grid_colwrapper' ).each( function( i, el ) {
                var $el = $( el );
                if( scrollEffect === 'none' ) {
                    $el.removeAttr( 'data-swc_scrolleffect' );
                } else {
                    var obj = {
                        'effect': scrollEffect,
                        'factor': seFactor,
                        'offset': seOffset
                    };

                    $el.attr( 'data-swc_scrolleffect', JSON.stringify( obj ) );
                }
            } );

            evt( 'swifty_update_scrolleffect' );
        },

        changeCustomCss: function( newVal ) {
            var self = this;
            var $row = self.options.$row;

            self.setGridData( $row, 'swc_custom_css', newVal );

            var data = $.parseJSON( $row.attr( 'data-grid_data' ) );
            if( ! data.cssid ) {
                data.cssid = Date.now() + '_' + parseInt( Math.random() * 999, 10 );
                self.setGridData( $row, 'cssid', data.cssid );
                $row.attr( 'id', 'c' + data.cssid );
            }

            // Remove existing css for the row
            $( '#css_' + data.cssid ).remove();
            $( '#cssclose_' + data.cssid ).remove();

            // Add new css for the row
            var sel = '#c' + data.cssid;
            var accolines = 0;
            var css = sel + ' {\n';
            var lines = newVal.split( '\n' );
            $.each( lines, function( i, line ) {
                if( line.indexOf( '{' ) >= 0 ) {
                    if( accolines === 0 ) {
                        css += '}\n';
                    }
                    css += sel + ' ' + line + '\n';
                    accolines++;
                } else {
                    css += line + '\n';
                }
            } );
            if( accolines === 0 ) {
                css += '}\n';
            }
            css = css.replace( /\n/g, ' ' );
            $( '<style id="css_' + data.cssid + '" class="swc_custom_css">' + css + ' }</style><div id="cssclose_' + data.cssid + '" class="swc_custom_cssclose"></div></div>' ).appendTo( $row );
        }

    } );
} );


swifty.define('stache!js/panels/row_main/row_main.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/panels/row_main/row_main.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<div>\n    <swc_panel_button icon="&#xe03f;" action="edit_row" name="{{__ \'Edit columns\'}}"/>\n    <swc_panel_button icon="fa-exchange" action="change_layout" name="{{__ \'Change layout\'}}"/>\n    <swc_panel_button icon="fa-paint-brush" action="change_style" name="{{__ \'Change style\'}}"/>\n    <swc_panel_button icon="&#xe013;" action="move_row" name="{{__ \'Move columns\'}}"/>\n    <swc_panel_button icon="fa-copy" action="copy_row" name="{{__ \'Copy columns\'}}"/>\n    <swc_panel_button icon="&#xe00b;" action="delete_row" name="{{__ \'Delete columns\'}}"/>\n    {{#if show_lock_ui}}\n    {{#if map.swc_locked}}\n    <swc_panel_button icon="fa-lock" action="unlock_row" name="{{__ \'Columns are now locked\'}}"/>\n    {{/if}}\n    {{#if map.swc_unlocked}}\n    <swc_panel_button icon="fa-unlock" action="lock_row" name="{{__ \'Columns are now unlocked\'}}"/>\n    {{/if}}\n    {{/if}}\n    <!--<swc_panel_button icon="&#xe902" action="insert_p_above_row" name="{{__ \'Insert text above\'}}"/>-->\n    <!--<swc_panel_button icon="&#xe901" action="insert_p_below_row" name="{{__ \'Insert text below\'}}"/>-->\n</div>' ); return idn; });

swifty.define( 'js/panels/row_main/row_main',[
    'jquery',
    'swiftylib/evt',
    'js/panels/panel/panel',
    'js/panels/panel_stack/panel_stack_instance',
    'js/panels/yes_no/yes_no',
    'js/panels/move_row/move_row',
    'js/panels/edit_row/edit_row',
    'swiftylib/i18n/__',
    'stache!js/panels/row_main/row_main.stache'
], function(
    $, evt, Panel, panelStackInstance, YesNo, MoveRow, EditRow, __, tmpl
) {
    

    return Panel.extend( {
        'defaults': {
            'tmpl_content': tmpl,
            'title': __( 'Columns' )
        }
    }, {
        init: function() {
            this.options.show_lock_ui = scc_data.swifty_change_lock;

            this._super();

            if( this.getLocked() ) {
                this.options.map.attr( 'swc_locked', true );
                this.options.map.attr( 'swc_unlocked', false );
            } else {
                this.options.map.attr( 'swc_locked', false );
                this.options.map.attr( 'swc_unlocked', true );
            }

            evt( 'swifty_editor_set_asset_in_edit_mode', { '$asset': this.options.$row } );

            if( this.options.mode && ( this.options.mode === 'directedit' ) ) {
                this.markCloseOnFocus();
                $( '.swc_panel_button_edit_row' ).click();
            }

            if( this.options.mode && ( this.options.mode === 'delete' ) ) {
                this.markCloseOnFocus();
                $( '.swc_panel_button_delete_row' ).click();
            }

            if( this.options.mode && ( this.options.mode === 'move' ) ) {
                this.markCloseOnFocus();
                $( '.swc_panel_button_move_row' ).click();
            }
        },

        destroy: function() {
            this._super();
        },

        getLocked: function() {
            var self = this;

            var data = $.parseJSON( self.options.$row.attr( 'data-grid_data' ) );

            return ( data && data.swc_locked );
        },

        '.swc_panel_button_edit_row click': function() {
            var self = this;

            //this.markCloseOnFocus();
            panelStackInstance.addPanel( EditRow, {
                '$row': self.options.$row
            } );
        },

        '.swc_panel_button_change_layout click': function() {
            var self = this;

            //this.markCloseOnFocus();
            panelStackInstance.addPanel( EditRow, {
                '$row': self.options.$row,
                'mode': 'position'
            } );
        },

        '.swc_panel_button_change_style click': function() {
            var self = this;

            //this.markCloseOnFocus();
            panelStackInstance.addPanel( EditRow, {
                '$row': self.options.$row,
                'mode': 'style'
            } );
        },

        '.swc_panel_button_delete_row click': function() {
            //this.markCloseOnFocus();
            this.yesNoPanel = panelStackInstance.addPanel( YesNo, {
                'title': __( 'Delete these columns with all the content?' ),
                'yes_name': __( 'Delete these columns with all content permanently' ),
                'no_name': __( 'Cancel, do not delete' ),
                'evt_el': $( this.element )
            } );
        },

        '.swc_panel_button_lock_row click': function() {
            evt( 'set_row_lock', { '$row': this.options.$row, 'locked': 1 } );
            this.options.map.attr( 'swc_locked', true );
            this.options.map.attr( 'swc_unlocked', false );
        },

        '.swc_panel_button_unlock_row click': function() {
            evt( 'set_row_lock', { '$row': this.options.$row, 'locked': null } );
            this.options.map.attr( 'swc_locked', false );
            this.options.map.attr( 'swc_unlocked', true );
        },

        '.swc_panel_button_move_row click': function() {
            var self = this;

            //this.markCloseOnFocus();
            panelStackInstance.addPanel( MoveRow, {
                '$row': self.options.$row
            } );
        },

        '.swc_panel_button_copy_row click': function() {
            var self = this;

            evt( 'swifty_editor_row_copy', { '$row': self.options.$row } );
        },

        ' evt_swc_yes': function( /*el, ev, opts*/ ) {
            this.deleteRow();

            evt( 'swifty_editor_set_asset_in_edit_mode' );

            this.markCloseOnFocus();
            this.yesNoPanel.closePanel();
        },

        ' evt_swc_no': function( /*el, ev, opts*/ ) {
            //evt( 'swifty_editor_set_asset_in_edit_mode' );

            this.yesNoPanel.closePanel();
        },

        '.swc_panel_button_insert_p_above_row click': function( /*el, ev*/ ) {
            evt( 'swifty_editor_insert_p_asset', {
                'action': 'above',
                '$asset': this.options.$row
            } );
        },

        '.swc_panel_button_insert_p_below_row click': function( /*el, ev*/ ) {
            evt( 'swifty_editor_insert_p_asset', {
                'action': 'below',
                '$asset': this.options.$row
            } );
        },

        deleteRow: function() {
            var self = this;
            var $el = self.options.$row;
            var $wrapper = $el.closest( '.cke_widget_wrapper' );

            $wrapper.remove();

            evt( 'swifty_editor_set_asset_in_edit_mode' );
            evt( 'swifty_editor_content_modified' );
        },

        '.swc_back_button click': function( /*el, ev*/ ) {
            evt( 'swifty_editor_set_asset_in_edit_mode' );

            this._super();
        }

    } );
} );
swifty.define( 'js/panels/convert_image/convert_image',[
    'jquery',
    'swiftylib/evt',
    '../yes_no/yes_no',
    'swiftylib/i18n/__'
], function(
    $, evt, YesNo, __
) {
    

    return YesNo.extend( {
        'defaults': {
            'title': __( 'Convert to Swifty Content Creator image?' ),
            'yes_name': __( 'Convert' ),
            'no_name': __( 'Do not convert.' )
        }
    }, {
        '.swc_panel_button_yes click': function() {
            var self = this;

            evt( 'convert_image_to_asset', self.options );
            self.closePanel();
        },

        '.swc_panel_button_no click': function() {
            this.closePanel();
        }
    } );
} );


swifty.define('stache!js/panels/area_settings/area_settings.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/panels/area_settings/area_settings.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<div class="swc_panel swc_overlay_panel {{panel_css_class}}">\n    <div class="swc_panel_container">\n        <div class="swc_panel_content">\n            <div class="swc_panel_area_settings swc_panel_content_wrap">\n                <div class="swc_panel_form_wrapper">\n                    <div class="swc_panel_form_wrapper_inner">\n                        <form class="swc_content_form swc_panel_content_nowrap" autocomplete="off">\n                            <div class="swc_panel_form_tab_pane swc_panel_form_content swc_selected">\n                                <div class="swc_form_column">\n                                    <table>\n                                        <tr class="swc_tr_head">\n                                            <th colspan="2"><div class="swc_panel_category_title">{{__ \'Choose how to show each area\'}}</div></th>\n                                            <th><div class="swc_panel_category_title">{{__ \'Pick area variant\'}}</div></th>\n                                        </tr>\n                                        <tr>\n                                            <td class="swc_td_label">{{__ \'Topbar\'}}</td>\n                                            <td class="swc_td_radios">\n                                                <swifty_form_radiobutton name="spm_topbar_visibility" _value="area_settings.topbar.visibility" values="default^{{__ \'Default\'}}^|hide^{{__ \'Hide\'}}^|show^{{__ \'Show\'}}" label="{{__ \'Top Bar\'}}" />\n                                            </td>\n                                            <td class="swc_td_selects">\n                                                {{#if area_data.templates_exist}}\n                                                    {{#if area_settings.topbar.nr_of_templates}}\n                                                        <swifty_form_select name="spm_topbar_template" _value="{area_settings.topbar.active_template}" values="{{area_settings.topbar.template_select_options}}" />\n                                                    {{/if}}\n                                                {{/if}}\n                                            </td>\n                                        </tr>\n                                        <tr>\n                                            <td class="swc_td_label">{{__ \'Header\'}}</td>\n                                            <td class="swc_td_radios">\n                                                <swifty_form_radiobutton name="spm_header_visibility" _value="area_settings.header.visibility" values="default^{{__ \'Default\'}}^|hide^{{__ \'Hide\'}}^|show^{{__ \'Show\'}}" label="{{__ \'Header\'}}" />\n                                            </td>\n                                            <td class="swc_td_selects">\n                                                {{#if area_data.templates_exist}}\n                                                    {{#if area_settings.header.nr_of_templates}}\n                                                        <swifty_form_select name="spm_header_template" _value="{area_settings.header.active_template}" values="{{area_settings.header.template_select_options}}" />\n                                                    {{/if}}\n                                                {{/if}}\n                                            </td>\n                                        </tr>\n                                        <tr>\n                                            <td class="swc_td_label">{{__ \'Navbar\'}}</td>\n                                            <td class="swc_td_radios">\n                                                <swifty_form_radiobutton name="spm_navbar_visibility" _value="area_settings.navbar.visibility" values="default^{{__ \'Default\'}}^|hide^{{__ \'Hide\'}}^|show^{{__ \'Show\'}}" label="{{__ \'Nav Bar\'}}" />\n                                            </td>\n                                            <td class="swc_td_selects">\n                                                {{#if area_data.templates_exist}}\n                                                    {{#if area_settings.navbar.nr_of_templates}}\n                                                        <swifty_form_select name="spm_navbar_template" _value="{area_settings.navbar.active_template}" values="{{area_settings.navbar.template_select_options}}" />\n                                                    {{/if}}\n                                                {{/if}}\n                                            </td>\n                                        </tr>\n                                        <tr>\n                                            <td class="swc_td_label">{{__ \'Sidebar\'}}</td>\n                                            <td class="swc_td_radios">\n                                                <swifty_form_radiobutton name="spm_sidebar_visibility" _value="area_settings.sidebar.visibility" values="default^{{__ \'Default\'}}^|hide^{{__ \'Hide\'}}^|left^{{__ \'Left\'}}^|right^{{__ \'Right\'}}" label="{{__ \'Sidebar\'}}" />\n                                            </td>\n                                            <td class="swc_td_selects">\n                                                {{#if area_data.templates_exist}}\n                                                    {{#if area_settings.sidebar.nr_of_templates}}\n                                                        <swifty_form_select name="spm_sidebar_template" _value="{area_settings.sidebar.active_template}" values="{{area_settings.sidebar.template_select_options}}" />\n                                                    {{/if}}\n                                                {{/if}}\n                                            </td>\n                                        </tr>\n                                        <tr>\n                                            <td class="swc_td_label">{{__ \'Extra Sidebar\'}}</td>\n                                            <td class="swc_td_radios">\n                                                <swifty_form_radiobutton name="spm_extrasidebar_visibility" _value="area_settings.extrasidebar.visibility" values="default^{{__ \'Default\'}}^|hide^{{__ \'Hide\'}}^|left^{{__ \'Left\'}}^|right^{{__ \'Right\'}}" label="{{__ \'Extra Sidebar\'}}" />\n                                            </td>\n                                            <td class="swc_td_selects">\n                                                {{#if area_data.templates_exist}}\n                                                    {{#if area_settings.extrasidebar.nr_of_templates}}\n                                                        <swifty_form_select name="spm_extrasidebar_template" _value="{area_settings.extrasidebar.active_template}" values="{{area_settings.extrasidebar.template_select_options}}" />\n                                                    {{/if}}\n                                                {{/if}}\n                                            </td>\n                                        </tr>\n                                        <tr>\n                                            <td class="swc_td_label">{{__ \'Footer\'}}</td>\n                                            <td class="swc_td_radios">\n                                                <swifty_form_radiobutton name="spm_footer_visibility" _value="area_settings.footer.visibility" values="default^{{__ \'Default\'}}^|hide^{{__ \'Hide\'}}^|show^{{__ \'Show\'}}" label="{{__ \'Footer\'}}" />\n                                            </td>\n                                            <td class="swc_td_selects">\n                                                {{#if area_data.templates_exist}}\n                                                    {{#if area_settings.footer.nr_of_templates}}\n                                                        <swifty_form_select name="spm_footer_template" _value="{area_settings.footer.active_template}" values="{{area_settings.footer.template_select_options}}" />\n                                                    {{/if}}\n                                                {{/if}}\n                                            </td>\n                                        </tr>\n                                        <tr>\n                                            <td class="swc_td_label">{{__ \'Bottombar\'}}</td>\n                                            <td class="swc_td_radios">\n                                                <swifty_form_radiobutton name="spm_bottombar_visibility" _value="area_settings.bottombar.visibility" values="default^{{__ \'Default\'}}^|hide^{{__ \'Hide\'}}^|show^{{__ \'Show\'}}" label="{{__ \'Bottom Bar\'}}" />\n                                            </td>\n                                            <td class="swc_td_selects">\n                                                {{#if area_data.templates_exist}}\n                                                    {{#if area_settings.bottombar.nr_of_templates}}\n                                                        <swifty_form_select name="spm_bottombar_template" _value="{area_settings.bottombar.active_template}" values="{{area_settings.bottombar.template_select_options}}" />\n                                                    {{/if}}\n                                                {{/if}}\n                                            </td>\n                                        </tr>\n                                    </table>\n                                </div>\n                            </div>\n                        </form>\n                    </div>\n                </div>\n            </div>\n        </div>\n        <div class="clearfix"></div>\n        <div class="swc_iframe_gradient"></div>\n    </div>\n\n    <div class="swc_panel_bottom_container">\n        <div class="swc_panel_back_container {{#eq back_action \'exit\'}}swc_back_exit{{/eq}}">\n            <div class="swc_button swc_back_button">\n                {{#eq panel_css_class \'swc_small_panel\'}}\n                    &#xe900;\n                {{else}}\n                    <i class="fa fa-chevron-left"></i>\n                {{/eq}}\n            </div>\n        </div>\n\n        <div class="swc_panel_title_container">\n            <div class="swc_panel_title_pos">\n                <div class="swc_title">\n                    {{__ title}}\n                </div>\n            </div>\n        </div>\n    </div>\n</div>' ); return idn; });


swifty.define('css!js/panels/area_settings/area_settings',[],function(){});
swifty.define( 'js/panels/area_settings/area_settings',[
    'jquery',
    'swiftylib/evt',
    'js/libs/mout/src/object/deepMatches',
    'swiftylib/map',
    'js/panels/panel/panel',
    'js/panels/panel_stack/panel_stack_instance',
    'swiftylib/i18n/__',
    'stache!./area_settings.stache',
    // No return values:
    'css!./area_settings.css'
], function(
    $, evt, deepMatches, Map, Panel, panelStackInstance, __, tmpl
) {
    

    return Panel.extend( {
        'defaults': {
            'tmpl': tmpl,
            'panel_css_class': 'swc_overlay_area_settings_panel',
            'title': __( 'Manage areas for this page' ),
            'area_data': null,
            'area_settings': null,
            'area_settings_init': null
        }
    }, {
        init: function() {
            var self = this;

            self.options.area_data = new Map();
            self.options.area_settings = new Map();
            self.options.area_settings_init = {};

            self.options.area_data.attr( 'templates_exist', 0 );
            
            evt( 'get_area_settings' ).then( function( result ) {
                if( result && result.success ) {
                    self.options.area_settings.attr( result.data );
                    self.options.area_settings_init = result.data;

                    self.options.area_settings.each( function( area_settings /*, area_name*/ ) {
                        if( area_settings.attr( 'nr_of_templates' ) ) {
                            self.options.area_data.attr( 'templates_exist', 1 );
                        }
                    } );
                }
            } );

            self._super();

            evt( 'swifty_editor_set_focus', { 'focus': 0 } );
        },

        '.swc_back_button click': function() {
            var self = this;
            var settingsNow = self.options.area_settings.serialize();
            var dfd = new $.Deferred();

            if( ! deepMatches( self.options.area_settings_init, settingsNow ) ) {
                evt( 'save_area_settings', settingsNow ).then( function( result ) {
                    if( result && result.success ) {
                        $( '#swc_iframe' ).attr( 'src', function ( i, val ) { return val; } );
                        dfd.resolve();
                    }
                } );
            } else {
                dfd.resolve();
            }

            dfd.done( function() {
                evt( 'swifty_editor_set_focus', { 'focus': 1 } );
                panelStackInstance.closePanel( self.element );
            } );
        }
    } );
} );

swifty.define('stache!js/panels/page_options/page_options.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/panels/page_options/page_options.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<div class="swc_panel_content_nowrap">\n    {{#if has_ssd}}\n    <swc_panel_button icon="&#xe007;" action="area_settings" name="{{__ \'Area settings\'}}" />\n    {{/if}}\n    <swc_panel_button icon="&#xe912;" action="manage_versions" name="{{__ \'Previous versions\'}}" />\n</div>\n' ); return idn; });

swifty.define( 'js/panels/page_options/page_options',[
    'jquery',
    'swiftylib/evt',
    'js/panels/panel/panel',
    'swiftylib/i18n/__',
    'js/panels/panel_stack/panel_stack_instance',
    'js/panels/area_settings/area_settings',
    'js/panels/manage_versions/manage_versions',
    'stache!./page_options.stache'
], function(
    $, evt, Panel, __, panelStackInstance, AreaSettings, ManageVersions, tmpl
) {
    

    return Panel.extend( {
        'defaults': {
            'tmpl_content': tmpl,
            'title': __( 'Options' ),
            'has_ssd' : null
        }
    }, {
        init: function() {
            var self = this;
            var activeTheme = scc_data.active_theme;

            self.options.has_ssd = activeTheme && activeTheme === 'swifty-site-designer';
            self._super();
        },

        '.swc_panel_button_area_settings click': function() {
            // Never open the Page Settings panel while saving.
            if( this.options.state_saving === 0 ) {
                this.markCloseOnFocus();
                panelStackInstance.addPanel( AreaSettings );
            } else {
                alert( __( 'We are still saving. Please try again in a minute.' ) );
            }
        },

        '.swc_panel_button_manage_versions click': function() {
            this.markCloseOnFocus();
            panelStackInstance.addPanel( ManageVersions, {
                'page_model_map': this.options.page_model_map
            } );
        }
    } );
} );


swifty.define('stache!js/panels/area_style/area_style.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/panels/area_style/area_style.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<div class="swc_panel_form_tabs_wrapper">\n    <div class="swc_panel_form_wrapper">\n        <div class="swc_panel_form_wrapper_inner">\n            <form class="swc_content_form swc_panel_content_nowrap" autocomplete="off">\n\n                <div class="swc_form_column">\n                    <swifty_form_radiobutton name="bg_type" _value=\'{area_data.bg_type}\' values="default^{{__ \'Default\'}}^|color^{{__ \'Color\'}}|image^{{__ \'Image\'}}" label="{{__ \'Background type\'}}" direction="vertical" />\n                </div>\n                {{#is area_data.bg_type \'color\'}}\n                    <div class="swc_form_column">\n                        <swifty_colorpicker name="bg_color" _value="area_data.bg_color" label="{{__ \'Background color\'}}"/>\n                    </div>\n                {{/is}}\n                {{#is area_data.bg_type \'image\'}}\n                    <div class="swc_form_column">\n                        <swc_icon_button action="bg_image" text="{{__ \'Background image\'}}" />\n                        {{#if area_data.bg_img}}\n                            <swc_icon_button action="bg_image_remove" text="{{__ \'Remove background image\'}}" />\n                        {{/if}}\n                    </div>\n                {{/is}}\n\n                <div class="swc_form_column swc_form_inputs_w_100">\n                    {{#if is_vertical}}\n                        <swifty_form_radiobutton name="set_width" _value=\'{area_data.set_width}\' values="default^{{__ \'Default\'}}^|custom^{{__ \'Custom\'}}" label="{{__ \'Minimum width\'}}" direction="vertical" />\n                        {{#is area_data.set_width \'custom\'}}\n                            <swifty_form_input name="px_width" _value="area_data.px_width" label="" />\n                        {{/is}}\n                    {{else}}\n                        <swifty_form_radiobutton name="set_height" _value=\'{area_data.set_height}\' values="default^{{__ \'Default\'}}^|custom^{{__ \'Custom\'}}" label="{{__ \'Minimum height\'}}" direction="vertical" />\n                        {{#is area_data.set_height \'custom\'}}\n                            <swifty_form_input name="px_height" _value="area_data.px_height" label="" />\n                        {{/is}}\n                    {{/if}}\n                </div>\n\n                <div class="swc_form_column swc_form_inputs_w_100">\n                    <swifty_form_radiobutton name="set_margin" _value=\'{area_data.set_margin}\' values="default^{{__ \'Default\'}}^|custom^{{__ \'Custom\'}}" label="{{__ \'Margin\'}}" direction="vertical" />\n                </div>\n                {{#is area_data.set_margin \'custom\'}}\n                    <div class="swc_form_column swc_form_inputs_w_100">\n                        <swifty_form_input name="margin_left" _value="area_data.margin_left" label="{{__ \'Margin left\'}}" />\n                        <swifty_form_input name="margin_right" _value="area_data.margin_right" label="{{__ \'Margin right\'}}" />\n                    </div>\n                    <div class="swc_form_column swc_form_inputs_w_100">\n                        <swifty_form_input name="margin_top" _value="area_data.margin_top" label="{{__ \'Margin top\'}}" />\n                        <swifty_form_input name="margin_bottom" _value="area_data.margin_bottom" label="{{__ \'Margin bottom\'}}" />\n                    </div>\n                {{/is}}\n\n                <div class="swc_form_column swc_form_inputs_w_100">\n                    <swifty_form_radiobutton name="set_padding" _value=\'{area_data.set_padding}\' values="default^{{__ \'Default\'}}^|custom^{{__ \'Custom\'}}" label="{{__ \'Padding\'}}" direction="vertical" />\n                </div>\n                {{#is area_data.set_padding \'custom\'}}\n                    <div class="swc_form_column swc_form_inputs_w_100">\n                        <swifty_form_input name="padding_left" _value="area_data.padding_left" label="{{__ \'Padding left\'}}" />\n                        <swifty_form_input name="padding_right" _value="area_data.padding_right" label="{{__ \'Padding right\'}}" />\n                    </div>\n                    <div class="swc_form_column swc_form_inputs_w_100">\n                        <swifty_form_input name="padding_top" _value="area_data.padding_top" label="{{__ \'Padding top\'}}" />\n                        <swifty_form_input name="padding_bottom" _value="area_data.padding_bottom" label="{{__ \'Padding bottom\'}}" />\n                    </div>\n                {{/is}}\n\n                <div class="swc_form_column">\n                    <swifty_form_textarea name="custom_css" _value="area_data.custom_css" label="{{__ \'Custom css\'}}" />\n                </div>\n\n            </form>\n        </div>\n    </div>\n</div>' ); return idn; });

swifty.define( 'js/panels/area_style/area_style',[
    'jquery',
    'swiftylib/evt',
    'swiftylib/map',
    'js/panels/panel/panel',
    'js/panels/panel_stack/panel_stack_instance',
    'swiftylib/i18n/__',
    'stache!./area_style.stache',
    'swiftylib/media_manager'
], function(
    $, evt, Map, Panel, panelStackInstance, __, tmpl, MediaManager
) {
    

    return Panel.extend( {
        'defaults': {
            'tmpl_content': tmpl,
            'title': __( 'Area style' ),
            'is_vertical': false,
            'default_settings': {
                'bg_type': 'default',
                'bg_color': '#FFF',
                'bg_img': '',
                'set_height': 'default',
                'px_height': '0',
                'set_width': 'default',
                'px_width': '0',
                'set_margin': 'default',
                'margin_left': '0',
                'margin_right': '0',
                'margin_top': '0',
                'margin_bottom': '0',
                'set_padding': 'default',
                'padding_left': '0',
                'padding_right': '0',
                'padding_top': '0',
                'padding_bottom': '0',
                'custom_css': ''
            }
        }
    }, {
        init: function() {
            var self = this;
            var ky = scc_data.area + '_' + ( scc_data.area_template ? scc_data.area_template : '' );

            evt( 'get_page_style_object', ky ).then( function( obj2 ) {
                var obj = {};
                if( typeof obj2 !== 'undefined' && obj2.area_data ) {
                    obj = obj2.area_data;
                }

                self.options.area_data = new Map( $.extend( true,
                    {},
                    self.options.default_settings,
                    obj
                ) );
            } );

            if( scc_data.area.indexOf( 'sidebar' ) >= 0 ) {
                self.options.is_vertical = true;
            }

            self._super();

            evt( 'swifty_editor_set_focus', { 'focus': 0 } );
        },

        '.swc_back_button click': function( /*el, ev*/ ) {
            evt( 'swifty_editor_set_focus', { 'focus': 1 } );

            this._super();
        },

        dataToCss: function() {
            var self = this;
            var data = self.options.area_data;
            var css = '.swifty_area_' + scc_data.area + ' {';

            if( data.attr( 'bg_type' ) === 'color' ) {
                css += ' background-color: ' + data.attr( 'bg_color' ) + ' !important;';
            }
            if( data.attr( 'bg_type' ) === 'image' ) {
                css += ' background-size: cover !important;';
                css += ' background-repeat: inherit !important;';
            }

            var set_height = data.attr( 'set_height' );
            var px_height = '' + data.attr( 'px_height' );
            if( set_height === 'custom' && set_height !=='' ) {
                css += ' min-height: ' + parseInt( px_height, 10 ) + 'px !important;';
            }

            var set_width = data.attr( 'set_width' );
            var px_width = '' + data.attr( 'px_width' );
            if( set_width === 'custom' && set_width !=='' ) {
                css += ' min-width: ' + parseInt( px_width, 10 ) + 'px !important;';
            }

            var set_margin = data.attr( 'set_margin' );
            var margin_left = '' + data.attr( 'margin_left' );
            if( set_margin === 'custom' && margin_left !=='' ) {
                css += ' margin-left: ' + parseInt( margin_left, 10 ) + 'px !important;';
            }
            var margin_right = '' + data.attr( 'margin_right' );
            if( set_margin === 'custom' && margin_right !=='' ) {
                css += ' margin-right: ' + parseInt( margin_right, 10 ) + 'px !important;';
            }
            var margin_top = '' + data.attr( 'margin_top' );
            if( set_margin === 'custom' && margin_top !=='' ) {
                css += ' margin-top: ' + parseInt( margin_top, 10 ) + 'px !important;';
            }
            var margin_bottom = '' + data.attr( 'margin_bottom' );
            if( set_margin === 'custom' && margin_bottom !=='' ) {
                css += ' margin-bottom: ' + parseInt( margin_bottom, 10 ) + 'px !important;';
            }

            css += data.attr( 'custom_css' );
            
            css += '}';

            css += ' .swifty_area_inner_content_' + scc_data.area + ' {';

            var set_padding = data.attr( 'set_padding' );
            var padding_left = '' + data.attr( 'padding_left' );
            if( set_padding === 'custom' && padding_left !=='' ) {
                css += ' padding-left: ' + parseInt( padding_left, 10 ) + 'px !important;';
            }
            var padding_right = '' + data.attr( 'padding_right' );
            if( set_padding === 'custom' && padding_right !=='' ) {
                css += ' padding-right: ' + parseInt( padding_right, 10 ) + 'px !important;';
            }
            var padding_top = '' + data.attr( 'padding_top' );
            if( set_padding === 'custom' && padding_top !=='' ) {
                css += ' padding-top: ' + parseInt( padding_top, 10 ) + 'px !important;';
            }
            var padding_bottom = '' + data.attr( 'padding_bottom' );
            if( set_padding === 'custom' && padding_bottom !=='' ) {
                css += ' padding-bottom: ' + parseInt( padding_bottom, 10 ) + 'px !important;';
            }

            css += '}';

            self.updateCss( css );
        },

        updateCss: function( css ) {
            var self = this;
            var area_data = self.options.area_data.attr();

            $.each( self.options.default_settings, function( ky, val ) {
                if( area_data[ ky ] === val ) {
                    delete area_data[ ky ];
                }
            } );

            evt( 'change_style_tag', {
                'id': 'swifty_scc_area_' + scc_data.area + '_' + scc_data.area_template + '_css',
                'css': css,
                'area_data': area_data
            } );

            setTimeout( function() {
                self.checkBackgroundImages();
            }, 1 );
        },
        
        checkBackgroundImages: function() {
            var self = this;
            var data = self.options.area_data;
            var key = scc_data.area;

            evt( 'set_bg_img', {
                'key': key,
                'data': data
            } );
        },

        select_image: function() {
            var self = this;
            var $newEl = $( '<div></div>' ).appendTo( this.element );
            var dfd = new $.Deferred();

            $.post(
                scc_data.ajax_url,
                {
                    'action': 'get_attachment_id_from_url',
                    'url': self.options.area_data.attr( 'bg_img' ),
                    'id': scc_data.page_id,
                    'ajax_nonce': scc_data.ajax_nonce
                }
            ).done( function( attachmentId ) {
                new MediaManager( $newEl, {
                    'selected_ids': attachmentId || '',
                    'multiple': false,
                    'dfd': dfd,
                    'swifty_mode': 0
                } );

                dfd.then( function( data ) {
                    if( data && data.act === 'insert' ) {
                        if( $.isArray( data.attributes ) && data.attributes.length ) {
                            var url = data.attributes[ 0 ].url || '';
                            if( url !== '' ) {
                                if( url.indexOf( '?swifty=' ) < 0 ) {
                                    url += '?swifty=1';
                                }

                                if( data.attributes[ 0 ].swifty_tp ) {
                                    url += '&ssd_tp=' + data.attributes[ 0 ].swifty_tp;
                                }
                            }

                            self.options.area_data.attr( 'bg_img', url );
                        }
                    }

                    $newEl.remove();   // Destroy the MediaManager
                } );
            } );
        },

        '.swc_bg_image click': function() {
            this.select_image();
        },

        '.swc_bg_image_remove click': function() {
            this.options.area_data.attr( 'bg_img', '' );
        },

        '{area_data} change': function( /*dunno, ev, attr, how, newVal, oldVal*/ ) {
            var self = this;

            self.dataToCss();
            
            evt( 'set_is_style_changed', true );

            setTimeout( function() {
                evt( 'fix_panel_heights', { 'redraw_element': $( self.element ).find( '.swc_content_form' ) } );
            }, 1 );
        }
        
    } );
} );


swifty.define('stache!js/panels/area_select/area_select.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/panels/area_select/area_select.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<div class="swc_panel_content_nowrap">\n    <swc_panel_button icon="fa-pencil" action="edit" name="Edit this {{areaname}}"/>\n    <swc_panel_button icon="fa-plus" action="new" name="Create new {{areaname}}"/>\n    <swc_panel_button icon="fa-eye-slash" action="hide" name="Hide this {{areaname}}"/>\n</div>\n' ); return idn; });

swifty.define( 'js/panels/area_select/area_select',[
    'jquery',
    'swiftylib/evt',
    'swiftylib/map',
    'js/panels/panel/panel',
    'stache!./area_select.stache',
    'js/diverse/utils',
    'swiftylib/i18n/__'
], function(
    $, evt, Map, Panel, tmpl, Utils, __
) {
    

    return Panel.extend( {
        'defaults': {
            'tmpl_content': tmpl,
            'title': __( 'Edit [areaname]?' )
        }
    }, {
        openAreaTemplate: function(edit_area, edit_area_template) {
            var url = Utils.updateQueryString( 'swcreator_edit', edit_area, scc_data.view_url );
            url = Utils.updateQueryString( 'swcreator_area_template', edit_area_template, url );

            evt( 'swifty_editor_change_window_location', { 'url': url } );
        },

        '.swc_panel_button_new click': function() {
            var self = this;
            self.openAreaTemplate( self.options.edit_area, '@' );
            self.closePanel();
        },

        '.swc_panel_button_edit click': function() {
            var self = this;
            self.openAreaTemplate( self.options.edit_area, self.options.edit_area_template );
            this.closePanel();
        },

        '.swc_panel_button_hide click': function() {
            var self = this;

            evt( 'store_current_areas' );

            self.options.preset_areas = new Map();
            self.options.preset_areas.attr( self.options.edit_area, new Map( {
                'html': '',
                'overrule': 'hide'
            } ) );

            evt( 'change_current_areas', { 'preset_areas': self.options.preset_areas } );

            evt( 'save_current_areas', {
                'preset_areas': self.options.preset_areas
            } ).done( function() {
                evt( 'reset_theme_edit_overlay' );
                self.closePanel();
            } );
        },

        '.swc_back_button click': function( /*el, ev*/ ) {
            evt( 'reset_theme_edit_overlay' );
            evt( 'swifty_editor_set_cursor' );
            evt( 'swifty_editor_set_asset_in_edit_mode' );

            this._super();
        }
    } );
} );


swifty.define('stache!js/panels/messages/messages.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/panels/messages/messages.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<swc_dialog {(map)}="map"></swc_dialog>' ); return idn; });


swifty.define('css!js/panels/messages/messages',[],function(){});
swifty.define( 'js/panels/messages/messages',[
    'jquery',
    'swiftylib/evt',
    'swiftylib/control',
    'swiftylib/view',
    'swiftylib/map',
    'swiftylib/i18n/__',
    'stache!js/panels/messages/messages.stache',
    // No return values:
    'css!js/panels/messages/messages.css'
], function(
    $, evt, Control, View, Map, __, tmpl
) {
    

    return Control.extend( {
        'defaults': {
            'tmpl': tmpl,
            'map': new Map( {
                'title': 'SwiftySite',
                'html': __( 'Loading...' ),
                'checkbox_delete': 0,
                'show_checkbox_delete': true,
                'active_nr': 1,
                'total_nr': 0,
                'id': ''
            } )
        }
    }, {
        init: function() {
            var self = this;
            var map = self.options.map;
            
            map.attr( 'items', self.options.message_data.attr( 'items' ) );
            map.attr( 'total_nr', self.options.message_data.attr( 'items.total_nr' ) );

            $( self.element ).addClass( 'swc_messages_dialog' );

            self.element.html( new View( self.options.tmpl )(
                self.options, {
            } ) );

            self.updateMessage();

            self.dataChanged();

            self._super();
        },

        updateMessage: function() {
            var self = this;
            var map = self.options.map;

            var msg = map.attr( 'items.messages.' + ( map.attr( 'active_nr' ) - 1 ) );
            if( msg ) {
                if( map.attr( 'id' ) !== msg.attr( 'id' ) ) {
                    map.attr( 'id', msg.attr( 'id' ) );
                    evt( 'set_message_read', { 'id': msg.attr( 'id' ) } );

                    map.attr( 'checkbox_delete', msg.attr( 'deleted' ) > 0 ? '1' : '0' );
                }

                map.attr( 'title', __( msg.attr( 'titlebar' ) ) );
                if( typeof msg.attr( 'url' ) !== 'undefined' && msg.attr( 'url' ) + '' !== '' ) {
                    map.attr( 'html', '' );
                    // First make the iframe and spinner go away, so we will get a new spinner.
                    map.attr( 'show_iframe', false );
                    setTimeout( function() {
                        map.attr( 'url', msg.attr( 'url' ) );
                        map.attr( 'show_iframe', true );
                    }, 1 );
                } else {
                    map.attr( 'html', msg.attr( 'html' ) );
                    map.attr( 'url', '' );
                    map.attr( 'show_iframe', false );
                }
                map.attr( 'show_checkbox_delete', true );
            }
        },

        dataChanged: function() {
            var self = this;
            var map = self.options.map;
            var items = map.attr( 'items' );

            map.attr( 'total_nr', items.attr( 'total_nr' ) );
            if( items.attr( 'total_nr' ) === 0 ) {
                map.attr( 'title', __( 'No messages' ) );
                map.attr( 'html', __( 'Sorry, my dog ate all your messages...' ) );
                map.attr( 'show_checkbox_delete', false );
            } else {
                self.updateMessage();
            }
        },

        setCheckOn: function() {
            var self = this;
            var $input = $( self.element ).find( '.swc_dialog_footer_t input' );

            if( ! $input.prop( 'checked' ) ) {
                $input.click();
            }
        },

        '{window} evt_swc_dialog_close': function( /*el, ev, opts, dfd*/ ) {
            $( this.element ).remove();
        },

        '{window} evt_swc_dialog_next': function( /*el, ev, opts, dfd*/ ) {
            var self = this;
            var map = self.options.map;
            var items = map.attr( 'items' );

            if( map.attr( 'active_nr' ) < items.attr( 'total_nr' ) ) {
                map.attr( 'active_nr', map.attr( 'active_nr' ) + 1 );
                self.updateMessage();
            }
        },

        '{window} evt_swc_dialog_previous': function( /*el, ev, opts, dfd*/ ) {
            var self = this;
            var map = self.options.map;

            if( map.attr( 'active_nr' ) > 1 ) {
                map.attr( 'active_nr', map.attr( 'active_nr' ) - 1 );
                self.updateMessage();
            }
        },

        '{window} evt_swc_dialog_action': function( el, ev, opts/*, dfd*/ ) {
            var self = this;
            var $buttons = opts.$el.closest( '.swc_msg_buttons' );
            var $messageDialog = $buttons.closest( '.swc_messages_dialog' );
            var map = self.options.map;
            var msg = map.attr( 'items.messages.' + ( map.attr( 'active_nr' ) - 1 ) );

            if( opts.action === 'allow_ext' ) {
                $buttons.html( __( 'Okay. Thank you!' ) );
                evt( 'set_swifty_allow_external', { allow: 'allow' } );
                self.setCheckOn();
            }

            if( opts.action === 'disallow_ext' ) {
                $buttons.html( __( 'Okay. No problem :-)' ) );
                evt( 'set_swifty_allow_external', { allow: 'disallow' } );
                self.setCheckOn();
            }

            if( opts.action === 'update_plugin' ) {
                evt( 'go_update_plugin', { data: opts.data, '$buttons': $buttons, 'msg': msg, 'map': self.options.map, '$messageDialog': $messageDialog } );
            }

            if( opts.action === 'update_theme' ) {
                evt( 'go_update_theme', { data: opts.data, '$buttons': $buttons, 'msg': msg, 'map': self.options.map, '$messageDialog': $messageDialog } );
            }

            if( opts.action === 'visit_ssm' ) {
                var win = window.open( 'https://wordpress.org/plugins/swifty-site/', '_blank' );
                if( win ) {
                    // Browser has allowed it to be opened.
                    win.focus();
                }
            }
        },

        '{map} change': function( huh, ev, attr, how, newVal, oldVal ) {
            var self = this;
            var map = self.options.map;

            if( attr === 'checkbox_delete' ) {
                var msg = map.attr( 'items.messages.' + ( map.attr( 'active_nr' ) - 1 ) );
                if( msg ) {
                    var del = newVal === '1' ? 1 : 0;

                    if( msg.attr( 'id' ) === '__perm_ph_home' ) {
                        if( del === 1 ) {
                            // Set deleted, but only for 1 month.
                            del = parseInt( new Date().getTime() / 1000, 10 ) + 60 * 60 * 24 * 30;
                        }
                    }
                    
                    if( msg.attr( 'deleted' ) !== del ) {
                        evt( 'set_message_deleted', { 'id': msg.attr( 'id' ), 'deleted': del } );
                    }
                    
                    msg.attr( 'deleted', del );
                }
            } else if( attr === 'active_nr' ) {
                this.dataChanged();
            }
        }

    } );
} );

swifty.define('stache!js/panels/welcome/welcome.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/panels/welcome/welcome.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<swc_dialog {(map)}="map">\n    <div class="swc_welcome_bottom"></div>\n    <div>\n        {{#is map.step 1}}\n            <div class="swc_welcome_icon">&#xe03d</div>\n            <div class="swc_welcome_title">Thanks for using Swifty</div>\n            <div class="swc_welcome_subtitle">How awesome of you!</div>\n            <div class="swc_welcome_text">\n                It\'s really easy for both professionals and for the rest of us, to create a stunning and amazing website with SwiftySite.<br>\n                Please let us know which of the two you are, and we will provide you with the best user experience.<br>\n            </div>\n            <div class="swc_welcome_buttons">\n                <div class="swc_button swc_btn_welcome_pro">I\'m a&nbsp;<b>pro</b></div>\n                <div class="swc_button swc_btn_welcome_easy">Let\'s go <b>easy</b></div>\n            </div>\n            <div class="swc_welcome_note">(You can always change this later)</div>\n        {{/is}}\n        {{#is map.step 2}}\n            <div class="swc_welcome_icon">&#xe03d</div>\n            <div class="swc_welcome_title">One more question</div>\n            <div class="swc_welcome_subtitle">and you\'re good to go</div>\n            <div class="swc_welcome_text">\n                We want to make your life easy by providing you with the best settings for the way your content will be shown. But at the same time we don\'t want to mess things up if you already have valuable content in this website. So please let us know:<br>\n            </div>\n            <div class="swc_welcome_buttons">\n                <div class="swc_button swc_btn_welcome_existing">This is an existing site with content</div>\n                <div class="swc_button swc_btn_welcome_empty">This is a new & empty site</div>\n            </div>\n            <div class="swc_welcome_note">(You can always change this later)</div>\n        {{/is}}\n        {{#is map.step 3}}\n            <div class="swc_welcome_icon">&#xe03d</div>\n            <div class="swc_welcome_title">Getting your site ready</div>\n            <div class="swc_welcome_subtitle">One second please...</div>\n            <div class="swc_welcome_text">\n                We need to reload this page in order to apply all your preferences.<br>\n            </div>\n        {{/is}}\n    </div>\n    <div class="swc_welcome_laptops"><div class="swc_welcome_laptops_inner"></div></div>\n</swc_dialog>' ); return idn; });


swifty.define('css!js/panels/welcome/welcome',[],function(){});
swifty.define( 'js/panels/welcome/welcome',[
    'jquery',
    'swiftylib/evt',
    'js/diverse/utils',
    'swiftylib/control',
    'swiftylib/view',
    'swiftylib/map',
    'swiftylib/i18n/__',
    'stache!js/panels/welcome/welcome.stache',
    // No return values:
    'css!js/panels/welcome/welcome.css'
], function(
    $, evt, Utils, Control, View, Map, __, tmpl
) {
    

    return Control.extend( {
        'defaults': {
            'tmpl': tmpl,
            'map': new Map( {
                'step': 1
            } )
        }
    }, {
        init: function() {
            var self = this;
            
            $( self.element ).addClass( 'swc_welcome_dialog' );

            self.element.html( new View( self.options.tmpl )(
                self.options, {
            } ) );

            var bgImg = scc_data.swcreator_url + 'css/welcome_bg.jpg';
            $( self.element ).find( '.swc_dialog_window' ).css( 'background-image', 'url("' + bgImg + '")' );
            var laptopsImg = scc_data.swcreator_url + 'css/welcome_laptops.png';
            $( self.element ).find( '.swc_welcome_laptops_inner' ).css( 'background-image', 'url("' + laptopsImg + '")' );

            self._super();
        },

        setMode: function( guiMode, changeLock ) {
            if( scc_data.can_manage_options === '1' ) {
                this.options.map.attr( 'step', 2 );
            } else {
                this.options.map.attr( 'step', 3 );
            }

            evt( 'change_scc_data', { 'key': 'swifty_gui_mode', 'val': guiMode } );
            evt( 'change_scc_data', { 'key': 'swifty_change_lock', 'val': changeLock } );

            $.post(
                Utils.getSWCreatorAjaxUrl(),
                {
                    'action': 'set_gui_mode',
                    'gui_mode': guiMode,
                    'id': scc_data.page_id,
                    'ajax_nonce': scc_data.ajax_nonce
                }
            );

            $.post(
                Utils.getSWCreatorAjaxUrl(),
                {
                    'action': 'set_scc_enable_lock_options',
                    'lock': changeLock,
                    'id': scc_data.page_id,
                    'ajax_nonce': scc_data.ajax_nonce
                }
            );
            if( scc_data.can_manage_options === '0' ) {
                this.setClickedAndReload();
            }
        },

        setClickedAndReload: function() {
            $.post(
                Utils.getSWCreatorAjaxUrl(),
                {
                    'action': 'set_welcome_state',
                    'welcome_state': 'clicked',
                    'id': scc_data.page_id,
                    'ajax_nonce': scc_data.ajax_nonce
                }
            ).then( function() {
                location.reload();
            } );
        },

        setMode2: function( autop, pMargin, wpEmbed ) {
            var self = this;

            self.options.map.attr( 'step', 3 );

            $.post(
                scc_data.ajax_url,
                {
                    'action': 'set_wpautop_and_ptag_bottom_margin_and_wp_embed',
                    'wpautop': autop,
                    'ptag_bottom_margin': pMargin,
                    'wp_embed': wpEmbed,
                    'id': scc_data.page_id,
                    'ajax_nonce': scc_data.ajax_nonce
                }
            ).then( function() {
                self.setClickedAndReload();
            } );
        },

        '.swc_btn_welcome_pro click' : function() {
            this.setMode( 'advanced', 'enabled' );
        },

        '.swc_btn_welcome_easy click' : function() {
            this.setMode( 'easy', false );
        },

        '.swc_btn_welcome_existing click' : function() {
            this.setMode2( 'default', '0', '' );

            // $( this.element ).remove();
        },

        '.swc_btn_welcome_empty click' : function() {
            this.setMode2( 'off', '1', 'disable' );

            // $( this.element ).remove();
        }

    } );
} );

swifty.define('stache!js/panels/help/help.stache', ['can/../can'], function (can) { var idn = '__stache_tmpl_' + 'js/panels/help/help.stache'.split('.').join('_').split('/').join('_') + '_' + Date.now() + '_' + parseInt( 1000000 * Math.random() ) + '__'; can.view.mustache( idn, '<swc_dialog {(map)}="map"></swc_dialog>' ); return idn; });

swifty.define( 'js/panels/help/help',[
    'jquery',
    'swiftylib/control',
    'swiftylib/view',
    'swiftylib/map',
    'swiftylib/i18n/__',
    'stache!js/panels/help/help.stache'
], function(
    $, Control, View, Map, __, tmpl
) {
    

    return Control.extend( {
        'defaults': {
            'tmpl': tmpl,
            'map': new Map( {
                'title': __( 'Need help?' ),
                'show_iframe': true,
                'total_nr': 0,
                'url': '',
                'small_header': true
            } )
        }
    }, {
        init: function() {
            var self = this;

            self.options.map.attr( 'url', self.options.dialog_data.attr( 'url' ) );

            self.element.html( new View( self.options.tmpl )(
                self.options, {
            } ) );

            self._super();
        },

        '{window} evt_swc_dialog_close': function( /*el, ev, opts, dfd*/ ) {
            $( this.element ).remove();
        },
    } );
} );
swifty.define( 'js/panels/main/main',[
    'jquery',
    'swiftylib/evt',
    'swiftylib/map',
    'js/diverse/page',
    'js/panels/panel/panel',
    'js/panels/panel_stack/panel_stack_instance',
    'stache!js/panels/main/main.stache',
    'js/panels/add_content/add_content',
    'js/panels/publish/publish',
    'js/panels/manage_versions/manage_versions',
    'swiftylib/i18n/__',
    'js/diverse/utils',
    'js/panels/yes_no/yes_no',
    'js/panels/row_main/row_main',
    'js/panels/convert_image/convert_image',
    'js/panels/pick_columns/pick_columns',
    'js/panels/add_preset/add_preset',
    'js/panels/page_options/page_options',
    'js/panels/area_style/area_style',
    'js/panels/area_select/area_select',
    'js/panels/messages/messages',
    'js/panels/welcome/welcome',
    'js/panels/help/help',
    'js/libs/mout/src/function/throttle'
], function(
    $, evt, Map, Page, Panel, panelStackInstance, tmpl, AddContentPanel, Publish, ManageVersions, __, Utils, YesNo,
    PanelRowMain, PanelImageConvert, PickColumns, AddPresetPanel, PageOptionsPanel, AreaStylePanel, PanelAreaSelect,
    MessagesPanel, WelcomePanel, HelpPanel, throttle
) {
    

    return Panel.extend( {
        'defaults': {
            'panel_css_class': 'swc_small_panel',
            'tmpl_content': tmpl,
            // 'back_action': ( /*scc_data.is_swifty_mode ||*/ ( scc_data.area !== 'main' ) ) ? '' : 'exit',
            'back_action': 'exit',
            'show_panel_extra': true,
            'options_map': new Map( { 'mobile_view': 'desktop' } ),
            'main_menu_msgs': [
                __( 'Hold your breath... at least you\'re not on hold...' ),
                __( 'We\'re testing your patience...' ),
                __( 'Just a second... (as if you had any other choice)' ),
                __( 'It\'s still faster than you could draw it...' ),
                __( 'Are we there yet?' ),
                __( '1,000,000 bottles of beer on the wall...' ),
                __( 'Hang on a sec... I know your data is here somewhere...' )
            ],
            'message_data': new Map( {
                'items': {
                    'total_nr': 0,
                    'total_nr_unread': 0,
                    'messages': []
                }
            } ),
            'message_server_data': [],
            'message_srv_data_received': false
        }
    }, {
        init: function() {
            var self = this;

            self.Page = new Page( $( 'body' ), {} );

            self.options.title = scc_data.admin_page_title;

            self.options.page_model_map = this.Page.getMap();

            self.options.page_model_map.attr( 'show_button_options', scc_data.area === 'main' );
            self.options.page_model_map.attr( 'show_button_style', scc_data.area !== 'main' );

            self.options.page_model_map.attr( 'show_main_menu_msg', self.options.main_menu_msgs[
                Math.floor( Math.random() * self.options.main_menu_msgs.length )
            ] );

            self.saveMsgStateThrottledObject = throttle( $.proxy( self.sendMessageStatesToServer, self ), 1000 );

            self.getLatestMessages();

            self._super();
        },

        go_location_back: function() {
            if( ! scc_data.is_swifty_mode ) {
                window.location.href =  scc_data.exit_url;
            } else {
                var url = window.location.href;
                url = Utils.updateQueryString( 'swcreator_edit', ( scc_data.area === 'main' ) ? null : 'main', url );
                url = Utils.updateQueryString( 'swcreator_area_template', null, url );
                window.location = url;
            }
        },

        getLatestMessages: function() {
            var self = this;
            var items = self.options.message_data.attr( 'items' );

            evt( 'check_swifty_allow_external' ).then( function( allowExternal ) {
                if( allowExternal === 'allow' ) {
                    // Get messages from the stuff server. The user gave specific permission to do that.
                    $.ajax( {
                        url: "https://stuff.swifty.online/stuff/data/get.php",
                        type: "POST",
                        data: {
                            "do": "messages"
                        },
                        dataType: "json",
                        xhrFields: { withCredentials: true }
                    } ).then( function( data ) {
                        self.nextGenerateMessage( data.result );
                    } );
                } else {
                    // Get messages from the zip file. No phoning home.
                    $.post(
                        Utils.getSWCreatorAjaxUrl(),
                        {
                            'action': 'get_default_messages',
                            'id': scc_data.page_id,
                            'ajax_nonce': scc_data.ajax_nonce
                        }
                    ).done( function( data ) {
                        data = $.trim( data );

                        if( data.substr( 0, 1 ) === '[' ) {
                            data = $.parseJSON( data );
                        } else {
                            data = [];
                        }

                        // Add a message asking for permission to phone home.
                        if( allowExternal !== 'disallow' ) {
                            data.push( {
                                'id': '__perm_ph_home',
                                'titlebar': __( 'Message' ),
                                'html': '<h1>' + __( 'We would love to keep you in the loop' ) + '</h1>' +
                                __( 'SwiftySite is constantly improving and expanding and we would love it, if you <b>let us inform you of cool new features and improvements</b> and gather some anonymous stats of how people use our plugin (helps us make it even better).' ) + '<br>' +
                                '<br>' + __( 'No need to register or give us your email. We\'ll use this inbox. But first we need your permission to check our server for updates ;-)' ) + '<br>' +
                                '<br><br>' +
                                '<div class="swc_msg_buttons">' +
                                '<div class="swc_button swc_dialog_click" data-swc_dialog_action="allow_ext">' + __( 'Yes, I want to be the first to know' ) + '</div>' +
                                '<br><div class="swc_button_show_as_link swc_dialog_click" data-swc_dialog_action="disallow_ext">' + __( 'No thanks, do not contact the news server.' ) + '</div>' +
                                '</div>'
                            } );
                        }

                        self.nextGenerateMessage( data );
                    } );
                }
            } );
        },

        nextGenerateMessage: function( msgs ) {
            var self = this;
            
            // Add a message telling about the full Swifty product.
            if( scc_data.is_ssm_active !== '1' ) {
                msgs.push( {
                    'id': '__full_ss',
                    'titlebar': __( 'Message' ),
                    'html': '<h1>' + __( 'Hi there!' ) + '</h1>' +
                    __( 'Awesome of you to use <b>Swifty Content Creator</b> for this website project.' ) + '<br>' +
                    __( 'We are honoured :-)' ) + '<br>' +
                    '<br>' + __( 'But did you know you are now only enjoying part of the full SwifySite experience? Theres way more!' ) + '<br>' +
                    '<br>' + __( '<b>Swifty Page Manager</b>' ) + '<br>' +
                    __( 'Puts all your pages in an orderly page tree overview. Here you can easily create new pages, edit existing ones and move them around with drag and drop.' ) + '<br>' +
                    '<br>' + __( '<b>Swifty Site Designer</b>' ) + '<br>' +
                    __( 'This is a free theme that is actually more like a theme generator, because you can create almost any design with it. <i>It works closely together with Swifty Content Creator</i> which you are already using.' ) + '<br>' +
                    '<br>' + __( 'Now, you can can get each of these indiviually, but when you install the <b>SwiftySite plugin</b>, you get the whole experience of this theme and these plugins working beautifully together.' ) + '<br>' +
                    '<br>' + __( 'Why not give it a try? Its free :-)' ) + '<br>' +
                    '<br><br>' +
                    '<div class="swc_msg_buttons">' +
                    '<div class="swc_button swc_dialog_click" data-swc_dialog_action="visit_ssm">' + __( 'Yes, I want the full SwiftySite experience!' ) + '</div>' +
                    '</div>'
                } );
            }

            $.post(
                Utils.getSWCreatorAjaxUrl(),
                {
                    'action': 'get_swifty_plugin_versions',
                    'id': scc_data.page_id,
                    'ajax_nonce': scc_data.ajax_nonce
                },
                function( data ) {
                    data = $.parseJSON( data );

                    $.each( data, function( key, dat ) {
                        var html = '';
                        var id = '__upd_';
    
                        if( dat.update_status === 'update_available' ) {
                            var idn = key;
                            var update_action = 'update_plugin';
                            if( key === 'swifty-content-creator' ) { idn = 'scc'; }
                            if( key === 'swifty-content-goodies-pack' ) { idn = 'scgp'; }
                            if( key === 'swifty-content-visuals-pack' ) { idn = 'scvp'; }
                            if( key === 'swifty-page-manager' ) { idn = 'spm'; }
                            if( key === 'swifty-site' ) { idn = 'ssm'; }
                            if( key === 'si-contact-form' ) { idn = 'scf'; }
                            if( key === 'swifty-site-designer' ) { 
                                idn = 'ssd';
                                update_action = 'update_theme';
                            }
                            id += idn + dat.update_version + '_';

                            var name = key.replace( /-/g, ' ');
                            name = name.replace( /\w\S*/g, function( txt ) {return txt.charAt( 0 ).toUpperCase() + txt.substr( 1 ).toLowerCase();} );

                            var cls = 'swc_msg_plugin_msg_' + idn;
                            var json = JSON.stringify( { plugin: dat.update_plugin, slug: dat.update_slug, cls: cls } );
                            
                            html += '<b>' + name + '</b><br>' +
                                __( 'Your version:' ) + ' ' + dat.version + '<br>' + 
                                __( 'Available version:' ) + ' ' + dat.update_version + '<br>' +
                            '<br>' +
                            '<div class="swc_msg_buttons ' + cls + '">' +
                            '<div class="swc_button swc_dialog_click"' +
                                ' data-swc_dialog_action="' + update_action + '"' +
                                ' data-swc_dialog_data=\'' + json + '\'' +
                                '>' + __( 'Update' ) + ' ' + name + '</div>' +
                            '</div><!--butend' + cls + '-->' +
                            '<br><br>';
                        }

                        if( html !== '' ) {
                            html = '<div style="text-align: center;">' + __( 'There are updates available for these Swifty plugins:' ) + '<br><br>' + html;
                            html += '<div class="swc_msg_hide_on_succes">' + __( 'Please update!' ) + '</div></div>';
    
                            msgs.push( {
                                'id': id,
                                'titlebar': __( 'Message' ),
                                'html': html
                            } );
                        }
                        
                    } );
                    
                    self.updateMessageStates( msgs );
                }
            );
        },

        updateMessageStates: function( msgs ) {
            var self = this;
            var items = self.options.message_data.attr( 'items' );

            $.post(
                Utils.getSWCreatorAjaxUrl(),
                {
                    'action': 'get_message_states',
                    'id': scc_data.page_id,
                    'ajax_nonce': scc_data.ajax_nonce
                }
            ).done( function( data ) {
                data = $.trim( data );

                if( data.substr( 0, 1 ) === '[' ) {
                    data = $.parseJSON( data );

                    self.options.message_server_data = data;

                    $.each( msgs, function( ii, msg ) {
                        $.each( data, function( iii, dat ) {
                            if( msg.id + '' === dat.id + '' ) {
                                msg.read = dat.read;
                                msg.deleted = dat.deleted;
                            }
                        } );
                    } );
                }

                msgs = msgs.sort( function( a, b ) {
                    if( a.read > b.read || ( a.read !== 1 && b.read === 1 ) ) {
                        return -1;
                    }
                    if( a.read < b.read || ( a.read === 1 && b.read !== 1 ) ) {
                        return 1;
                    }
                    return 0;
                } );

                $.each( msgs, function( ii, msg ) {
                    if( msg.deleted > 1 && msg.deleted < parseInt( new Date().getTime() / 1000, 10 ) ) {
                        msg.deleted = 0;
                    }
                    if( ! msg.deleted >= 1 ) {
                        items.messages.push( msg );
                    }
                } );

                self.updateMessageTotals();

                self.options.message_srv_data_received = true;
            } );
        },

        updateMessageTotals: function() {
            var self = this;
            var items = self.options.message_data.attr( 'items' );
            var aUnread = 0;

            $.each( items.messages, function( i, msg ) {
                if( msg.attr( 'read' ) !== 1 ) {
                    aUnread++;
                }
            } );

            items.attr( 'total_nr_unread', aUnread );
            items.attr( 'total_nr', items.messages.length );
        },

        sendMessageStatesToServer: function() {
            var self = this;
            var items = self.options.message_data.attr( 'items' );

            $.each( items.messages, function( ii, msg ) {
                var obj = null;
                $.each( self.options.message_server_data, function( iii, dat ) {
                    if( msg.id + '' === dat.id + '' ) {
                        obj = dat;
                    }
                } );
                if( ! obj ) {
                    obj = { 'id': msg.attr( 'id' ) };
                    self.options.message_server_data.push( obj );
                }
                if( msg.attr( 'read' ) >= 0 ) {
                    obj.read = msg.attr( 'read' );
                }
                if( msg.attr( 'deleted' ) >= 0 ) {
                    obj.deleted = msg.attr( 'deleted' );
                }
            } );

            $.post(
                Utils.getSWCreatorAjaxUrl(),
                {
                    'action': 'set_message_states',
                    'message_states': JSON.stringify( self.options.message_server_data ),
                    'id': scc_data.page_id,
                    'ajax_nonce': scc_data.ajax_nonce
                }
            ).done( function( /*data*/ ) {
            } );
        },

        setMessageRead: function( id ) {
            var self = this;
            var items = self.options.message_data.attr( 'items' );

            $.each( items.messages, function( ii, msg ) {
                if( msg.attr( 'id' ) + '' === id + '' ) {
                    msg.attr( 'read', 1 );
                }
            } );

            self.saveMsgStateThrottledObject();

            self.updateMessageTotals();
        },

        setMessageDeleted: function( id, del ) {
            var self = this;
            var items = self.options.message_data.attr( 'items' );

            $.each( items.messages, function( ii, msg ) {
                if( msg.attr( 'id' ) + '' === id + '' ) {
                    msg.attr( 'deleted', del );
                }
            } );

            self.saveMsgStateThrottledObject();

            self.updateMessageTotals();
        },

        updatePluginFailed: function( $buttons ) {
            $buttons.html( '<b>' + __( 'Update FAILED. Please go to the Wordpress admin plugins page.' ) + '</b>' );
        },

        updatePlugin: function( data, $buttons, msg, map, $messageDialog ) {
            var data = JSON.parse( data );
            var self = this;
            var reg = new RegExp( data.cls + '">.*</div><!--butend' + data.cls + '-->' );
            
            $buttons.html( '<b>' + __( 'Updating...' )  + '</b>' );

            wp.ajax.post( 'update-plugin', {
                _ajax_nonce: scc_data.ajax_updates_nonce,
                plugin: data.plugin,
                slug: data.slug
            } )
            .done( function() {
                // $buttons.html( __( '<b>Update was successful.</b>' ) );
                msg.attr( 'html', msg.attr( 'html' ).replace( reg, data.cls + '"><b>' + __( 'Update was successful.' ) + '</b></div><!--butend' + data.cls + '-->' ) );
                map.attr( 'html', msg.attr( 'html' ) );

                var $hideOnSucces = $messageDialog.find( '.swc_msg_hide_on_succes' );
                $hideOnSucces.hide();
            } )
            .fail( function() {
                self.updatePluginFailed( $buttons );
            } );
        },

        updateThemeFailed: function( $buttons ) {
            $buttons.html( '<b>' + __( 'Update FAILED. Please go to the Wordpress admin themes page.' ) + '</b>' );
        },

        updateTheme: function( data, $buttons, msg, map, $messageDialog ) {
            var data = JSON.parse( data );
            var self = this;
            var reg = new RegExp( data.cls + '">.*</div><!--butend' + data.cls + '-->' );

            $buttons.html( '<b>' + __( 'Updating...' ) + '</b>' );

            var updateData = {
                'id': scc_data.page_id,
                'ajax_nonce': scc_data.ajax_nonce,
                'action': 'upgrade_ssd'
            };

            $.post(
                Utils.getSWCreatorAjaxUrl(),
                updateData
            ).done( function( data ) {
                if( ! data || ( data && ! data.success ) ) {
                    self.updateThemeFailed( $buttons );
                } else {
                    // $buttons.html( __( '<b>Update was successful.</b>' ) );
                    msg.attr( 'html', msg.attr( 'html' ).replace( reg, data.cls + '"><b>' + __( 'Update was successful.' ) + '</b></div><!--butend' + data.cls + '-->' ) );
                    map.attr( 'html', msg.attr( 'html' ) );

                    var $hideOnSucces = $messageDialog.find( '.swc_msg_hide_on_succes' );
                    $hideOnSucces.hide();
                }
            } ).fail( function() {
                self.updateThemeFailed( $buttons );
            } );
            
        },

        '.swc_back_button click': function( /*el, ev*/ ) {
            var self = this;

            evt( 'editor_drag_handlers_hide' );

            if( scc_data.area === 'main' ) {
                if( this.options.state_saving === 0 ) {
                    self.go_location_back();
                    this._super();
                } else {
                    alert( this.options.save_leave_msg );
                }
            } else {
                self.Page.checkPubStatus( self.Page.newest_content === undefined ? null : self.Page.newest_content, false );
                if( this.options.page_model_map.attr( 'is_published_same' ) && ! this.options.page_model_map.attr( 'is_style_changed' ) ) {
                    // delete new area template when it has not been changed
                    if( scc_data.area_new_template ) {
                        evt( 'delete_area' ).then( function( /*data*/ ) {
                            self.go_location_back();
                        } );
                    } else {
                        self.go_location_back();
                    }
                } else {
                    self.yesNoPanel = panelStackInstance.addPanel( YesNo, {
                        'title': __( 'Publish changes?' ),
                        'yes_name': __( 'Publish' ),
                        'no_name': __( 'Cancel. Forget changes' ),
                        'evt_el': $( this.element ),
                        'lcname': scc_data.area
                    } );
                }
            }
        },

        ' evt_swc_yes': function( /*el, ev, opts*/ ) {
            var self = this;

            self.yesNoPanel.closePanel();
            self.element.find( '.swc_panel_content' )
                .css( 'font-size', '18px' )
                .html( __( 'Publishing. Please wait...' ) );
            evt( 'publish_content_now' ).then( function( /*data*/ ) {
                self.go_location_back();
            } );
        },

        ' evt_swc_no': function( /*el, ev, opts*/ ) {
            var self = this;

            self.markCloseOnFocus();
            self.yesNoPanel.closePanel();

            // delete new area template when canceled
            if( scc_data.area_new_template ) {
                evt( 'delete_area' ).then( function( /*data*/ ) {
                    self.go_location_back();
                } );
            } else {
                self.go_location_back();
            }
        },

        '.swc_notifications click': function() {
            if( this.options.message_srv_data_received ) {
                new MessagesPanel(
                    $( '<div></div>' ).appendTo( 'body' ),
                    { 'message_data': this.options.message_data }
                );
            }
        },

        '.swc_help_button click': function( /*el, ev*/ ) {
            var helpUrl = ( scc_data.ss2_hosting_name === 'AMH' )
                ? 'https://www.alphamegahosting.com/swiftysite/help/'
                : '';

            if( helpUrl ) {
                var win = window.open( helpUrl, '_blank' );

                if( win ) {
                    win.focus();
                }
            } else {
                new HelpPanel(
                    $( '<div></div>' ).appendTo( 'body' ),
                    {
                        'dialog_data': new Map( {
                            'url': 'https://www.swifty.online/plugins_inbox/scc/support-question-mark/?rss3=hlp1'
                        } )
                    }
                );
            }
        },

        '.swc_main_save click': function() {
            this.Page.savePage();
        },

        '.swc_panel_button_add_content click': function() {
            panelStackInstance.addPanel( AddContentPanel, { 'wrap_at_bottom': true } );
        },

        '.swc_panel_button_add_column click': function() {
            panelStackInstance.addPanel( PickColumns, {
                '$row': null,
                'swc_between_cols': 20
            } );
        },

        '.swc_panel_button_add_preset click': function() {
            panelStackInstance.addPanel( AddPresetPanel, {} );
        },

        '.swc_panel_button_publish click': function() {
            // never publish while saving
            if( this.options.state_saving === 0 ) {
                panelStackInstance.addPanel( Publish );
            } else {
                alert( __( 'We are still saving. Please try again in a minute.' ) );
            }
        },

        '.swc_manage_versions click': function() {
            panelStackInstance.addPanel( ManageVersions, {
                'page_model_map': this.options.page_model_map
            } );
        },

        '.swc_panel_button_page_options click': function() {
            panelStackInstance.addPanel( PageOptionsPanel, {} );
        },

        '.swc_panel_button_change_style click': function() {
            panelStackInstance.addPanel( AreaStylePanel, {} );
        },

        '{window} evt_swc_swifty_editor_row_dialog': function( el, ev, opts ) {
            panelStackInstance.addPanel( PanelRowMain, opts );
        },

        '{window} evt_swc_swifty_editor_row_edit_dialog': function( el, ev, opts ) {
            opts.mode = 'directedit';
            panelStackInstance.addPanel( PanelRowMain, opts );
        },

        '{window} evt_swc_swifty_editor_row_delete_dialog': function( el, ev, opts ) {
            opts.mode = 'delete';
            panelStackInstance.addPanel( PanelRowMain, opts );
        },

        '{window} evt_swc_swifty_editor_row_move_dialog': function( el, ev, opts ) {
            opts.mode = 'move';
            panelStackInstance.addPanel( PanelRowMain, opts );
        },

        '{window} evt_swc_swifty_editor_image_dialog': function( el, ev, opts ) {
            panelStackInstance.addPanel( PanelImageConvert, opts );
        },

        '{window} evt_swc_swifty_area_select': function( el, ev, opts ) {
            panelStackInstance.addPanel( PanelAreaSelect, opts );
        },

        '{window} evt_swc_show_main_menu': function( /*el, ev, opts*/ ) {
            var self = this;

            self.options.map.attr( 'show_main_menu', true );

            if( scc_data.swifty_welcome_state !== 'clicked' ) {
                new WelcomePanel(
                    $( '<div></div>' ).appendTo( 'body' ),
                    {}
                );
            }
        },

        '{window} evt_swc_set_message_read': function( el, ev, opts ) {
            this.setMessageRead( opts.id );
        },

        '{window} evt_swc_set_message_deleted': function( el, ev, opts ) {
            this.setMessageDeleted( opts.id, opts.deleted );
        },

        '{window} evt_swc_go_update_plugin': function( el, ev, opts ) {
            this.updatePlugin( opts.data, opts.$buttons, opts.msg, opts.map, opts.$messageDialog );
        },

        '{window} evt_swc_go_update_theme': function( el, ev, opts ) {
            this.updateTheme( opts.data, opts.$buttons, opts.msg, opts.map, opts.$messageDialog );
        }
    } );
} );
// dorh Must be turned into...?  evt( 'add_exec', { 'status': 'hold', 'for': 'ck_inited' } );
if( typeof swifty_add_exec === 'function' ) {
    swifty_add_exec( { 'status': 'hold', 'for': 'ck_inited' } );
}

// Set RequireJs baseUrl. Must not be set in require_config or the build will fail.
if( typeof requirejs !== 'undefined' ) {
    requirejs.s.contexts._.config.baseUrl = scc_data.swcreator_url;
}

// Define jQuery because it should already be loaded by php in WordPress
swifty.define( 'jquery', [], function() {
    return jQuery;
});

// dorh Remove from global scope
var swifty_getUrlParameter = function( name ) {
    var results = new RegExp( '[\?&]' + name + '=([^&#]*)' ).exec( window.location.href );
    if( results == null ) {
        return null;
    }
    else {
        return results[ 1 ] || 0;
    }
};

// dorh Remove from global scope
var swifty_addMustacheHelpers = function( Mustache, __, View ) {
    Mustache.registerHelper( '__', __ );

    Mustache.registerHelper( 'eq', function( val, cmp, options ) {
        if( typeof( val ) !== 'string' ) {
            val = val();
        }
        if( typeof( cmp ) !== 'string' ) {
            cmp = cmp();
        }

        if( val === cmp ) {
            return options.fn( this );
        }

        return options.inverse( this );
    } );

    Mustache.registerHelper( 'renderStache', function( tmpl, context ) {

        if( typeof( tmpl ) !== 'string' ) {
            tmpl = tmpl();
        }
        return View.render( tmpl, context.scope );
    } );

    Mustache.registerHelper( 'convertFAIcons', function( /*opts*/ ) {
        var self = this;
        if( self.attr( 'icon' ) && /fa-/.test( self.attr( 'icon' ) ) ) {
            self.attr( 'fa_icon', self.attr( 'icon' ) );
            self.attr( 'icon', null );
        }
    } );

    Mustache.registerHelper( 'replace', function( val, fnd, repl, options ) {
        if( typeof( val ) !== 'string' ) {
            val = val();
        }
        if( typeof( fnd ) !== 'string' ) {
            fnd = fnd();
        }
        if( typeof( repl ) !== 'string' ) {
            repl = repl();
        }

        var re = new RegExp( fnd, 'g' );
        return val.replace( re, repl );
    } );
};

if( swifty_getUrlParameter( 'swcreator_iframe' ) ) {
    scc_data.in_iframe = true;
}

if( scc_data.in_iframe ) {

    // The page with CKeditor

    swifty.require( [
        'jquery',
        'swiftylib/mustache',
        'swiftylib/view',
        'swiftylib/i18n/__',
        'js/diverse/iframe_page',
        // No return value:
        'js/components/editor_ckeditor/editor_ckeditor',
        'css!cssDir/swcreator_ui.css',
        'css!//netdna.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css'
    ], function( $, Mustache, View, __, IframePage ) {
        

        swifty_addMustacheHelpers( Mustache, __, View );

        $( function() {
            // For mobile / tablet preview buttons
            $( 'body' ).wrapInner( '<div class="swc_display"></div>' );

            var iframePage = new IframePage( $( 'body' ), {} );

            var idn = '__stache_main_tmpl__';
            can.view.mustache( idn, '<swifty_editor_ckeditor selector="' + iframePage.getMap().selector + '"></swifty_editor_ckeditor>' );
            $( 'body' ).append( new View( idn )( {}, {} ) );
        } );
    } );

} else {

    // The user interface panels

    swifty.require( [
        'jquery',
        'swiftylib/mustache',
        'swiftylib/view',
        'js/panels/panel_stack/panel_stack_instance',
        'js/diverse/utils',
        'swiftylib/i18n/__',
        'js/panels/main/main',
        // No return value:
        'css!cssDir/swcreator_ui.css',
        'css!//netdna.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css'
    ], function( $, Mustache, View, panelStackInstance, Utils, __, MainPanel ) {
        

        swifty_addMustacheHelpers( Mustache, __, View );

        $( function() {
            if( !scc_data.in_iframe && window.self === window.top ) {
                // dorh Remove all content for all themese
                $( '.swifty_area_frame' ).html( '' );

                $( 'body' ).css( 'background-color', '#eeeeee' );

                // replace swcreator_edit by swcreator_iframe
                var url = Utils.updateQueryString( 'swcreator_edit', null, window.location.href );
                url = Utils.updateQueryString( 'swcreator_iframe', scc_data.area, url );
                url = Utils.updateQueryString( 'swcreator_area_template', scc_data.area_template, url );
                $( '<iframe id="swc_iframe" class="swifty_event_frame" src="' + url + '"></iframe>' ).appendTo( 'body' );
            }

            var browser_warning = __( 'It seems you are using a browser that is not fully compatible with SwiftySite.\n\n' +
            'Right now only Chrome, Firefox and Safari (version 9 or higher) work completely reliable.\n\n' +
            'Please use one of these browsers te work on your site.\n\n' +
            '(Ofcourse your visitors can view your site with any browser on any device.)', 'swifty-content-creator' );

            if( ! ( bowser.chrome || bowser.firefox || ( bowser.safari && bowser.version >= 9 ) ) ) {
                alert( browser_warning );
            }

            panelStackInstance.addPanel( MainPanel, {} );

            if( typeof( window.swiftyCheckImageSizesToBeDetermined ) === 'function' ) {
                window.swiftyCheckImageSizesToBeDetermined( scc_data.page_id );
            }
        } );

    } );

}
;
swifty.define("js/swcreator", function(){});

